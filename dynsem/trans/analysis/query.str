module analysis/query

imports
  include/ds
  ds

imports
  analysis/constructors
  analysis/lib-analysis
  analysis/analysis-rules

rules
  
//   type-of:
//     Int(_) -> IntType()
//   
//   type-of:
//     Real(_) -> RealType()
//   
//   type-of:
//     String(_) -> StringType()
//   
//   type-of:
//     True() -> BoolType()
//   
//   type-of:
//     False() -> BoolType()
// 
//   type-of:
//     Fresh() -> IntType()
// 
//   type-of:
//     dec -> <lookup-def(|Vars()); lookup-prop(|Type())> v
//     where
//       <?Var(v) + ?MatchedVar(v) + ?VarRef(v)> dec
// 
//   type-of:
//     Con(c, _) -> ty
//     where
//       <lookup-def(|Constructors()); lookup-prop(|Type())> c => ConstructorType(_, ty)
//   
//   type-of:
//     As(v, _) -> <type-of> v
//   
//   type-of:
//     List([]) -> ListType(ALPHATYPE())
//   
//   type-of:
//     ListTail([h], _) -> ListType(<type-of> h)
//   
//   type-of:
//     Cast(_, ty-trm) -> <rw-type> ty-trm
//   
//   type-of:
//     SortFunCall(fun-name, par, _) -> ty
//     where
//     	<type-of> par => par-ty;
//       <lookup-def(|Types())> par-ty => par-def;
//       <lookup-native-fun-def(|fun-name)> par-def => fun-def;
//       <lookup-prop(|Type())> fun-def => FunctionType(_, ty)
// 
//   type-of:
//     MapSelect(map, key) -> vty
//     where
//       <type-of> map => map-ty;
//       <lookup-def(|Types())> map-ty => map-ty-def;
//       <lookup-prop(|SortKind())> map-ty-def => SemanticCompSort();
//       <lookup-prop(|SuperType())> map-ty-def => MapType(_, vty)

  type-of-applicable-arrow:
    (arrow-type*, con-ty) -> <fetch-elem(where(\ ArrowType(ma-ty, _) -> <type-coerce-direct> (con-ty, ma-ty) \))> arrow-type*

  get-arrow-source-type:
    ArrowType(src-ty, _) -> src-ty
  
  get-arrow-target-type:
    ArrowType(_, tgt-ty) -> tgt-ty

rules /* variable scheme queries */

  get-unique-matching-varscheme =
    get-matching-varschemes;
    ?[<id>]

  get-matching-varschemes =
    not(is-string);
    (?Var(<id>) + ?VarRef(<id>));
    get-matching-varschemes

  get-matching-varschemes:
    used-word -> <lookup-def-all(|VarSchemes()); filter(is-name-matches-varscheme(|used-word))>
    where is-string
  
  is-name-matches-varscheme(|used-word):
    scheme-def -> scheme-def
    where
      scheme-name := <def-get-name> scheme-def
    where
      used-word-chars := <explode-string> used-word;
      scheme-word-chars := <explode-string> scheme-name;
      used-word-suffix-chars := <left-match> (used-word-chars, scheme-word-chars);
      if not(!used-word-suffix-chars => [])
      then
	      if not(<Hd> used-word-suffix-chars => '_')
	      then
	        <filter(not(?'\''); not(MkSingleton; dec-chars-to-int))> used-word-suffix-chars => []
	      end
	    end













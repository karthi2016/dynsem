module analysis/analysis-rules

imports
  include/ds
  analysis/lib-analysis
  analysis/constructors
  analysis/rename
  analysis/query
	pp
  ds
  lib-ds

rules /* syntactic checks */

  post-analysis-checks = alltd(post-analysis-check)
  
  post-analysis-check:
    r@Rule(_, _, Relation(_, Source(lhs, _), _, _)) -> r
    where
      <not(?Con(_, _) + ?As(_, Con(_, _)) + ?Cast(_, ListSort(_)))> lhs;
      add-msg(|Warning(), lhs, $[Left hand side of reduction must be a constructor pattern or a list cast pattern])
  
  post-analysis-check:
    dec -> dec
    where
      <?Var(v) + ?MatchedVar(v)> dec
    where
      <lookup-def(|Vars()); not(lookup-prop(|Use()))> v;
      add-msg(|Warning(), dec, $[Variable [<unrename-var> v] is never read])

rules /* store variables */
  
  store-rules = 
    {| MemoTyPath, MemoTyTrans:
      where(prime-typaths);
      Rules(map(store-rule <+ where(add-msg(|Error(), <id>, $[Rule could not be type checked]))))
    |}

  store-rule:
    r@Rule(_, _, Relation(_, Source(lhs, _), arr@NamedDynamicEmitted(_, arrow-name), _)) -> r
    where
      lhs-ty := <try(?As(_, <id>)); ?Con(<id>, _); lookup-def(|Constructors()); lookup-prop(|Type()); ?ConstructorType(_, <id>)> lhs
      <+
      lhs-ty := <?Cast(_, <id>); rw-type> lhs
    where
      if arrow-def := <lookup-def(|Arrows())> arrow-name
      then
	      arrow-ty* := <lookup-props(|Type())> arrow-def;
	      if <type-of-applicable-arrow> (arrow-ty*, lhs-ty) => arrow-ty
	      then
	        {| InArrow:
	          rules(InArrow: _ -> arrow-def);
	          <store-rule> (arrow-ty, r)
	        |}
	      else
	        arrow-ma-ty* := <map(?ArrowType(<id>, _))> arrow-ty*;
	        add-msg(|Error(), lhs, $[Expected one of: [<pp-type> arrow-ma-ty*] but found [<pp-type> lhs-ty]])
	      end
	    else
        add-msg(|Error(), arr, $[Arrow [arrow-name] is not declared])
      end

  store-rule:
    (ArrowType(ma-ty, bu-ty), r@Rule(p*, _, Relation(Reads(r*), Source(lhs, sc*), _, Target(rhs, tc*)))) -> r
    where
      <infer-type-of-top> (ma-ty, lhs);
      <map(labelcomp-to-type-term-pair; infer-type-of-top)> [r*, sc*];
      <map(type-check-premise-top)> p*;
      <infer-type-of-top> (bu-ty, rhs);
      <map(labelcomp-to-type-term-pair; infer-type-of-top)> tc*

  labelcomp-to-type-term-pair:
    LabelComp(ty, v) -> (<rw-type> ty, v)
  
  labelcomp-to-type-term-pair:
  	VarLabelComp(v) -> (scheme-ty, v)
  	where
  	  scheme-def := <get-unique-matching-varscheme> v;
  	  scheme-ty := <lookup-prop(|Type())> scheme-def

  infer-type-of-top =
  	infer-type-of
    <+
    type-of-failure

  type-of-failure:
    (ty, t) -> ty
    where
      ty-str := <ensure(pp-type)> ty;
      t-ty-str := <type-of; pp-type <+ !"(unknown)"> t;
      add-msg(|Error(), t, $[Type check failed: term of type [t-ty-str] is incompatible with type [ty-str]]);
      <debug(!"Type check failed, msg created: ")> t

  infer-type-of:
    (ty, Wld()) -> ty
  
  infer-type-of:
    (ty, dec) -> ty
    where
      <?Var(v) + ?MatchedVar(v)> dec
    where
      <not(get-unique-matching-varscheme)> v;
      <store-def(|Vars())> v => v-def;
      <store-prop(|Type(), v-def)> ty

  infer-type-of:
    (ty, dec) -> ty
    where
      <?Var(v) + ?MatchedVar(v)> dec
    where
      scheme-def := <get-unique-matching-varscheme> v;
      scheme-ty := <lookup-prop(|Type())> scheme-def;
      ty' := <type-coerce-direct> (ty, scheme-ty);
      <store-def(|Vars())> v => v-def;
      <store-prop(|Type(), v-def)> ty'

  infer-type-of:
    (ty, r@VarRef(v)) -> ty'
    where
      <lookup-def(|Vars())> v => v-def;
      <store-prop(|Use(), v-def)> r;
      <lookup-prop(|Type())> v-def => v-ty;
      <type-coerce-full> (v-ty, ty) => ty'

  infer-type-of:
    (ty, Int(_)) -> IntType()
    where
      <type-coerce-direct> (IntType(), ty)

  infer-type-of:
    (ty, bool) -> BoolType()
    where
      <?True() + ?False()> bool;
      <type-coerce-direct> (BoolType(), ty)

  infer-type-of:
    (ty, String(_)) -> StringType()
    where
      <type-coerce-direct> (StringType(), ty)

  infer-type-of:
    (ty, Fresh()) -> IntType()
    where
      <type-coerce-direct> (IntType(), ty)
  
  infer-type-of:
    (ty, ref@VarRef(v)) -> ty
    where
      <not(lookup-def(|Vars()))> v => v-ty;
      add-msg(|Error(), ref, $[Variable [<unrename-var> v] cannot be resolved])
  
  infer-type-of:
    (ty, Con(c, child*)) -> ty-con
    where
      ConstructorType(fchild-ty*, ty-con) := <lookup-def(|Constructors()); lookup-prop(|Type())> c;
      (
        <type-coerce-direct> (ty-con, ty)
        <+
        <type-coerce-sym(type-coerce-impl-reduction(type-coerce-direct))> (ty, ty-con)
      );
      <zip; map(infer-type-of-top)> (fchild-ty*, child*)
  
  infer-type-of:
    (NONETYPE(), Cast(t, ty-trm)) -> ty-cast
    where
      ty-cast := <rw-type> ty-trm;
      ty-t := <infer-type-of-top> (NONETYPE(), t)

  infer-type-of:
    (ty, Cast(t, ty-trm)) -> t-ty'
    where
      debug(!1);
      <rw-type> ty-trm => ty-cast;
      debug(!2);
      <type-coerce-direct> (ty, ty-cast) => ty-cast';
      debug(!3);
      <infer-type-of-top> (ty-cast', t) => t-ty'
      ;debug(!4)

  infer-type-of:
  	(ty, Cast(t, ty-trm)) -> ty'
  	where
  		<rw-type> ty-trm => ty-cast;
      <not(type-coerce-direct)> (ty-cast, ty);
      ty' := <type-coerce-impl-reduction(type-coerce-direct)> (ty, ty-cast);
  		<infer-type-of-top> (ty', t)

  infer-type-of:
  	(ty, As(v, pat)) -> ty'
  	where
  	  <infer-type-of-top> (ty, pat) => ty';
  	  <infer-type-of-top> (ty', v)

  infer-type-of:
  	(ty, List([])) -> ty'
  	where
  		<type-coerce-direct> (ListType(ALPHATYPE()), ty) => ty'
  
  infer-type-of:
    (ty, ListTail([h], t)) -> ty'
    where
      <infer-type-of-top> (ty, t) => l-ty@ListType(ALPHATYPE());
      <infer-type-of-top> (NONETYPE(), h) => head-ty;
      <type-coerce-direct> (ListType(head-ty), ty) => ty'

  infer-type-of:
    (ty, ListTail([h], t)) -> ty'
    where
      <infer-type-of-top> (ty, t) => l-ty@ListType(elem-ty);
      <not(?ALPHATYPE())> elem-ty;
      <infer-type-of-top> (elem-ty, h) => head-ty;
      <type-coerce-direct> (ListType(head-ty), ty) => ty'

  infer-type-of:
    (ty, SortFunCall(fun-name, par, arg*)) -> ty''
    where
      <infer-type-of-top> (NONETYPE(), par) => parent-ty;
      <lookup-def(|Types())> parent-ty => parent-def;
      <lookup-prop(|SortKind())> parent-def => NativeSort();
      <lookup-native-fun-def(|fun-name)> parent-def => fun-def;
      <lookup-prop(|Type())> fun-def => FunctionType(farg*, ty');
      <zip; map(infer-type-of-top)> (farg*, arg*);
      <type-coerce-direct> (ty', ty) => ty''

  infer-type-of:
    (ty, Map([])) -> ty'
    where
      <type-coerce-direct> (MapType(ALPHATYPE(), ALPHATYPE()), ty) => ty'

  infer-type-of:
    (ty, MapSelect(map-trm, key-trm)) -> val-ty'
    where
      <infer-type-of-top> (NONETYPE(), map-trm) => maybe-map-ty;
      if <?MapType(key-ty, val-ty)> maybe-map-ty
      then
        id
      else
        <lookup-def(|Types()); lookup-prop(|SuperType())> maybe-map-ty => MapType(key-ty, val-ty)
      end;
      <infer-type-of-top> (key-ty, key-trm) => key-ty;
      <type-coerce-direct> (val-ty, ty) => val-ty'
  
  infer-type-of:
    (ty, Map([Bind(key-val, val-val)])) -> ty'
    where
      <infer-type-of-top> (NONETYPE(), key-val) => key-ty;
      <infer-type-of-top> (NONETYPE(), val-val) => val-ty;
      map-ty := MapType(key-ty, val-ty);
      <type-coerce-direct> (map-ty, ty) => ty'

  infer-type-of:
    (ty, mx@MapExtend(map1, map2)) -> maps-ty
    where
      <infer-type-of-top> (NONETYPE(), map1) => map1-ty;
      <infer-type-of-top> (NONETYPE(), map2) => map2-ty;
      (
        <type-coerce-sym(type-coerce-direct)> (map1-ty, map2-ty) => maps-ty
        <+
        add-msg(|Error(), mx, $[Type [<ensure(pp-type)> map1-ty] is not coercible to type [<ensure(pp-type)> map2-ty]])
      );
      <type-coerce-direct> (maps-ty, ty)

  lookup-native-fun-def(|fun-name):
    parent-def -> <lookup-def(|NativeDTFun(parent-def))> fun-name
  
  lookup-native-fun-def(|fun-name):
    parent-def -> <lookup-native-fun-def(|fun-name)> sup-def
    where
      <not(lookup-def(|NativeDTFun(parent-def)))> fun-name
    where
      <lookup-prop(|SuperType()); lookup-def(|Types())> parent-def => sup-def;
      <lookup-prop(|SortKind())> sup-def => NativeSort()

rules
  
  type-check-build =
  	type-check-build-num
    <+ type-check-build-str
    <+ type-check-build-bool
    <+ type-check-build-fresh
    <+ type-check-build-var
    <+ type-check-build-con
    <+ type-check-build-list
    <+ type-check-build-map
    <+ type-check-build-cast
    <+ type-check-build-nativefuncall
  	<+ type-err-build-match-symbols; fail
    <+ type-err-build; fail
  
  type-err-build-match-symbols:
    t -> t
    where 
      ?Wld() + ?MatchedVar(_) + ?Var(_)
    where 
      add-msg(|Error(), t, $[Match symbol in build pattern])
  
  type-err-build:
    t -> t
    where
      add-msg(|Error(), t, $[Type error])
  
  type-check-build-num:
  	Int(_) -> IntType()
  
  type-check-build-num:
    Real(_) -> RealType()
  
  type-check-build-str:
    String(_) -> StringType()
  
  type-check-build-bool:
    True() -> BoolType()
  
  type-check-build-bool:
    False() -> BoolType()

  type-check-build-fresh:
    Fresh() -> IntType()
  
  type-check-build-var:
    r@VarRef(v) -> v-ty
    where
      v-def := <lookup-def(|Vars())> v;
      v-ty := <lookup-prop(|Type())> v-def;
      <store-prop(|Use(), v-def)> r
  
  type-check-build-var:
    r@VarRef(v) -> <fail>
    where
      <not(lookup-def(|Vars()))> v;
      add-msg(|Error(), r, $[Variable [<unrename-var> v] cannot be resolved])
  
  type-check-build-con:
    Con(c, aparam*) -> ty
    where
      ConstructorType(fparam-ty*, ty) := <lookup-def(|Constructors()); lookup-prop(|Type())> c;
      aparam-ty* := <map(type-check-build-con)> aparam*;
      <zip(type-coerce-full)> (aparam-ty*, fparam-ty*)

  type-check-build-list:
    List([]) -> ListType(ALPHATYPE())

  type-check-build-list:
    ListTail([h], t) -> <type-coerce-full> (ListType(h-ty), t-ty)
    where
      t-ty := <type-check-build> t;
      h-ty := <type-check-build> h

  type-check-build-map:
    Map([]) -> MapType(ALPHATYPE(), ALPHATYPE())

  type-check-build-map:
    Map([Bind(k-t, v-t)]) -> MapType(k-ty, v-ty)
    where
      k-ty := <type-check-build> k-t;
      v-ty := <type-check-build> v-t
  
  type-check-build-map:
    MapExtend(map1, map2) -> <type-coerce-full> (map1-ty, map2-ty)
    where
      map1-ty := <type-check-build> map1;
      map2-ty := <type-check-build> map2

  type-check-build-map:
    MapSelect(m-t, k-t) -> val-ty
    where
      MapType(key-ty, val-ty) := <type-check-build> m-t;
      k-ty := <type-check-build> k-t;
      <type-coerce-full> (k-ty, key-ty)

  type-check-build-cast:
    Cast(t, ty-t) -> <type-coerce-full> (t-ty, cast-ty)
    where
      t-ty := <type-check-build> t;
      cast-ty := <rw-type> ty-t

  type-check-build-nativefuncall:
    SortFunCall(fun-name, parent-t, param-t*) -> fun-ty
    where
      parent-ty := <type-check-build-nativefuncall> parent-t;
      parent-def := <lookup-def(|Types())> parent-ty;
      NativeSort() := <lookup-prop(|SortKind())> parent-def;
      fun-def := <lookup-native-fun-def(|fun-name)> parent-def;
      FunctionType(fparam-ty*, fun-ty) := <lookup-prop(|Type())> fun-def;
      param-ty* := <map(type-coerce-full)> param-t*;
      <zip; map(type-coerce-full)> (param-ty*, fparam-ty*)

  lookup-native-fun-def(|fun-name):
    parent-def -> <lookup-def(|NativeDTFun(parent-def))> fun-name
  
  lookup-native-fun-def(|fun-name):
    parent-def -> <lookup-native-fun-def(|fun-name)> sup-def
    where
      <not(lookup-def(|NativeDTFun(parent-def)))> fun-name
    where
      <lookup-prop(|SuperType()); lookup-def(|Types())> parent-def => sup-def;
      <lookup-prop(|SortKind())> sup-def => NativeSort()

rules // type rules for match-sides
  
  type-check-match(|in-ty) =
    type-check-match-num(|in-ty)
    <+ type-check-match-bool(|in-ty)
    <+ type-check-match-str(|in-ty)
    <+ type-check-match-wld(|in-ty)
    <+ type-check-match-var(|in-ty)
    <+ type-check-match-as(|in-ty)
    <+ type-check-match-con(|in-ty)
    <+ type-check-match-cast(|in-ty)
    <+ type-check-match-list(|in-ty)
    <+ type-err-match(|in-ty); fail
  
  type-err-match(|in-ty):
  	t -> t
  	where
  		in-ty-str := <ensure(pp-type)> in-ty;
  		t-ty-str := <type-of; pp-type <+ !"no-type"> t;
  		add-msg(|Error(), t, $[Term of type [t-ty-str] found, but expected [in-ty-str]])

  type-check-match:
    (t1, t2) -> <type-check-match(|t1)> t2
  
  type-check-match-num(|in-ty):
    Int(_) -> <type-coerce-full> (IntType(), in-ty)
  
  type-check-match-num(|in-ty):
    Real(_) -> <type-coerce-full> (RealType(), in-ty)
  
  type-check-match-bool(|in-ty):
    True() -> <type-coerce-full> (BoolType(), in-ty)

  type-check-match-bool(|in-ty):
    False() -> <type-coerce-full> (BoolType(), in-ty)
  
  type-check-match-str(|in-ty):
    String(_) -> <type-coerce-full> (StringType(), in-ty)
  
  type-check-match-wld(|in-ty):
    Wld() -> in-ty
  
  type-check-match-var(|in-ty):
    dec -> ty
    where
      ?Var(v) + ?MatchedVar(v)
    where
      <not(lookup-def(|Vars()))> v;
      if scheme-def := <get-unique-matching-varscheme> v
      then
        scheme-ty := <lookup-prop(|Type())> scheme-def;
        ty := <type-coerce-full> (scheme-ty, in-ty)
      else
        ty := in-ty
      end;
      v-def := <store-def(|Vars())> v;
      <store-prop(|Type(), v-def)> ty
  
  type-check-match-var(|in-ty):
    dec -> <fail>
    where
      ?Var(v) + ?MatchedVar(v)
    where
      <lookup-def(|Vars())> v;
      add-msg(|Error(), dec, $[Duplicate variable [<unrename-var> v]])
  
  type-check-match-as(|in-ty):
  	As(v, p) -> ty
  	where
  		<type-check-match(|in-ty)> v;
  		ty := <type-check-match(|in-ty)> p

  type-check-match-cast(|in-ty):
  	Cast(t, ty-trm) -> <type-coerce-full> (t-ty, in-ty)
  	where
  		cast-ty := <rw-type> ty-trm;
  		t-ty := <type-check-match(|cast-ty)> t
  		
  type-check-match-con(|in-ty):
    Con(c, aparam*) -> <type-coerce-full> (ty, in-ty)
    where
      ConstructorType(fparam-ty*, ty) := <lookup-def(|Constructors()); lookup-prop(|Type())> c;
      <zip(type-check-match)> (fparam-ty*, aparam*)
  
  type-check-match-list(|in-ty):
  	List([]) -> <type-coerce-full> (ListType(ALPHATYPE()), in-ty)
  
  type-check-match-list(|in-ty):
  	ListTail([h], t) -> <type-coerce-full> (l-ty, in-ty)
  	where
  		<?ListType(in-el-ty)> in-ty
    where
    	t-ty@ListType(t-el-ty) := <type-check-match(|in-ty)> t;
    	h-ty := <type-check-match(|in-el-ty)> h;
    	l-ty := <type-coerce-full> (ListType(h-ty), t-ty)

rules
  
  type-check-premise-top =
  	type-check-premise
    <+
  	where(
  		?p;
  		p-str := <ensure(pp-dynsem-Premise-string)> p;
    	add-msg(|Error(), p, $[Premise type check failed: [p-str]]);
    	<debug(!"Premise check failed: ")> p
  	)

  type-check-premise:
  	f@Formula(TermEq(lhs, rhs)) -> f
  	where
  	  <type-check-build> lhs;
  	  <type-check-build> rhs

  		// <infer-type-of-top> (NONETYPE(), lhs);
  		// <infer-type-of-top> (NONETYPE(), rhs)
  
  type-check-premise:
    f@Formula(TermNeq(lhs, rhs)) -> f
    where
      <infer-type-of-top> (NONETYPE(), lhs);
      <infer-type-of-top> (NONETYPE(), rhs)

  type-check-premise:
    f@Formula(Match(lhs, rhs)) -> f
    where
      lhs-ty := <type-check-build> lhs;
      rhs-ty := <type-check-match(|lhs-ty)> rhs 
      
      // <infer-type-of-top> (NONETYPE(), lhs) => lhs-ty;
      // <infer-type-of-top> (lhs-ty, rhs) => rhs-ty
  
  type-check-premise:
  	f@Formula(Relation(Reads(r*), Source(lhs, sc*), NamedDynamicEmitted(_, arrow-name), Target(rhs, tc*))) -> f
    where
    	<infer-type-of-top> (NONETYPE(), lhs) => lhs-ty;
    	if arrow-def := <lookup-def(|Arrows())> arrow-name
    	then
	      arrow-ty* := <lookup-props(|Type())> arrow-def;
	      if <type-of-applicable-arrow> (arrow-ty*, lhs-ty) => ArrowType(bu-ty, ma-ty)
	      then
	        <infer-type-of-top> (bu-ty, lhs);
	        <infer-type-of-top> (ma-ty, rhs);
	        <map(labelcomp-to-type-term-pair; infer-type-of-top)> [r*, sc*, tc*]
	      else
	        arrow-ma-ty* := <map(?ArrowType(<id>, _))> arrow-ty*;
	        add-msg(|Error(), lhs, $[Expected one of: [<pp-type> arrow-ma-ty*] but found [<pp-type> lhs-ty]])
	      end
	    else
	      add-msg(|Error(), arrow-name, $[Arrow [arrow-name] is not declared])
	    end
      
  type-check-premise:
  	f@Formula(NMatch(lhs, rhs)) -> f
  	where
  		<infer-type-of-top> (NONETYPE(), lhs);
  		<infer-type-of-top> (NONETYPE(), rhs)

  type-check-premise:
    f@Formula(TypeCast(r@VarRef(v-name), ty-term)) -> f
    where
      <rw-type> ty-term => ty;
      <lookup-def(|Vars())> v-name => v-def;
      <store-prop(|Use(), v-def)> r; 
      <lookup-prop(|Type())> v-def => v-ty;
      <store-prop(|Type(), v-def)> ty;
      if <not(type-coerce-direct)> (ty, v-ty)
      then
        add-msg(|Warning(), f, $[Term might be uncoerceable to [<pp-type> ty]])
      end

  type-check-premise:
    f@Formula(TypeCheck(r@VarRef(v-name), ty-term)) -> f
    where
      <rw-type> ty-term => ty;
      <lookup-def(|Vars())> v-name => v-def;
      <store-prop(|Use(), v-def)> r; 
      <lookup-prop(|Type())> v-def => v-ty;
      if <not(type-coerce-direct)> (ty, v-ty)
      then
        add-msg(|Warning(), f, $[Term might be uncoerceable to [<pp-type> ty]])
      end

  type-check-premise:
  	f@TryOr(PremiseBlock(l*), PremiseBlock(r*)) -> f
    with
      <map(type-check-premise-top)> l*;
      <map(type-check-premise-top)> r*

  type-check-premise:
    f@MergePoint(cond, PremiseBlock(l*), PremiseBlock(r*)) -> f
    with
    	<type-check-premise-top> cond;
      <map(type-check-premise-top)> l*;
      <map(type-check-premise-top)> r*
  
  type-check-premise = ?AllFail()

rules
  
  type-coerce-full =
    type-coerce-base
    <+ type-coerce(type-coerce-full)
    <+ type-coerce-impl-constructor(type-coerce-full)
    <+ type-coerce-impl-reduction(type-coerce-full)
  
  type-coerce-direct =
    type-coerce-base
    <+ type-coerce(type-coerce-direct)
    <+ type-coerce-impl-constructor(type-coerce-direct)

  type-coerce-simple =
  	type-coerce-base
  	<+ type-coerce(type-coerce-simple)
  
  type-coerce-base = eq; Fst

  type-coerce-sym(coerce-s) =
    coerce-s
    <+ swap; coerce-s
  
  
  type-coerce-base:
    (ty, NONETYPE()) -> ty
  
  type-coerce-base:
    (ALPHATYPE(), ty) -> ty
  
  type-coerce(coerce-s):
  	(IntType(), RealType()) -> RealType()

  type-coerce(coerce-s):
    (ListType(ALPHATYPE()), to-ty@ListType(_)) -> to-ty

  type-coerce(coerce-s):
    (ListType(ty-from), ListType(ty-to)) -> ListType(<coerce-s> (ty-from, ty-to))
  
  // type-coerce(coerce-s):
  //   (ty-from, ty-to) -> <coerce-s> (sup-ty, ty-to)
  //   where
  //     <lookup-def(|Types()); lookup-prop(|SuperType())> ty-from => sup-ty

  type-coerce(coerce-s):
    (MapType(a-k-ty, a-v-ty), to-ty) -> to-ty
    where
      <lookup-def(|Types())> to-ty => to-ty-def;
      <lookup-prop(|SortKind())> to-ty-def => SemanticCompSort();
      <lookup-prop(|SuperType())> to-ty-def => MapType(e-k-ty, e-v-ty);
      <coerce-s> (a-k-ty, e-k-ty);
      <coerce-s> (a-v-ty, e-v-ty)

  type-coerce-impl-constructor(coerce-s):
    ty-tup@(_, _) -> <get-typath(coerce-s); last> ty-tup

  // initialize the memo table with the implicit constructors and arrows as paths
  prime-typaths = 
    lookup-def-all(|Constructors());
    filter(where(lookup-prop(|ConsKind()) => ImplicitCons()));
    map({in-ty, out-ty: \ /* scoping the vars is required due to Stratego bug */
      c-def -> c-def
      where
        <lookup-prop(|Type())> c-def => ConstructorType([in-ty], out-ty);
        rules(
          MemoTyPath: (in-ty, out-ty) -> [c-def]
          MemoTyTrans:+ in-ty -> out-ty
        )
    \})

  get-typath(coerce-strategy):
    t@(ty-from, ty-to) -> path*
    where
    	anti-cycle(
	      ( <MemoTyPath> t => path* )
	      <+
	      (
	        <bagof-MemoTyTrans> ty-from => ty-inter*;
	        ty-inter := <fetch-elem(\ ty -> <coerce-strategy> (ty, ty-to) \)> ty-inter*;
	        path1* := <MemoTyPath> (ty-from, ty-inter);
	        path2* := <get-typath(coerce-strategy)> (ty-inter, ty-to);
	        path* := [path1*, path2*];
	        rules(
	          MemoTyPath: t -> path*
	          MemoTyTrans:+ ty-from -> ty-to
	        )
	      )
      )
  
  anti-cycle(s):
  	t -> t'
  	where {|AntiCycle:
  		<not(AntiCycle)> t;
  		rules(AntiCycle:+ t -> t);
  		<s> t => t'
    |}
  		

  type-coerce-impl-reduction(coerce-s) = type-coerce-impl-reduction(coerce-s|<InArrow>)

  type-coerce-impl-reduction(coerce-s|arrow-def):
    (ty-reduce-from, ty-reduce-to) -> ty-to'
    where
      arrow-ty* := <lookup-props(|Type())> arrow-def;
      ArrowType(_, bu-ty) := <type-of-applicable-arrow> (arrow-ty*, ty-reduce-from);
      ty-to' := <type-coerce-sym(coerce-s)> (ty-reduce-to, bu-ty)





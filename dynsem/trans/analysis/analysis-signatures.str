module analysis/analysis-signatures

imports
  include/ds
  analysis/lib-analysis
  analysis/constructors
  analysis/analysis-rules

rules /* store signatures */
  
  store-signatures =
    Signatures(map(
      store-sorts
      <+ store-constructors
      <+ store-native-operators
      <+ store-arrows
      <+ store-native-datatypes
      <+ store-semantic-components
    ))
  
  store-built-ins =
    <store-def(|Types())> IntType() => def-int
    ; <store-def(|Types())> RealType() => def-real
    ; <store-def(|Types())> BoolType() => def-bool
    ; <store-def(|Types())> StringType() => def-st
    ; <store-def(|Types())> ValueType() => def-value

  store-sorts = Sorts(map(store-sort)) + InternalSorts(map(store-sort))

  store-sort:
    decl@SortDecl(ty) -> decl
    where
      <store-def(|Types())> ty => ty-def

  store-sort:
    decl@InjDecl(ty, sty-name) -> decl
    where
      <id-to-type> sty-name => sty;
      <store-def(|Types())> ty => ty-def;
      <store-prop(|SuperType(), ty-def)> sty

  store-sort:
    decl@InternalSortDecl(ty) -> decl
    where
      <store-def(|Types())> ty => ty-def

  store-sort:
    decl@InternalInjDecl(ty, sty-name) -> decl
    where
      <id-to-type> sty-name => sty;
      <store-def(|Types())> ty => ty-def;
      <store-prop(|SuperType(), ty-def)> sty

  store-constructors =
    Constructors(map(store-constructor))
    + InternalConstructors(map(store-constructor))
    + NativeConstructors(map(store-constructor))
    + Values(map(store-constructor))
  
  store-constructor:
    d@ConsDecl(c, child*, s) -> d
    with
      <store-def(|Constructors())> c => c-def;
      <store-prop(|Type(), c-def)> ConstructorType(<rw-type> child*, <rw-type> s);
      <store-prop(|ConsKind(), c-def)> LanguageCons()

  store-constructor:
    d@InternalConsDecl(c, child*, s) -> d
    with
      <store-def(|Constructors())> c => c-def;
      <store-prop(|Type(), c-def)> ConstructorType(<rw-type> child*, <rw-type> s);
      <store-prop(|ConsKind(), c-def)> InternalCons()

  store-constructor:
    d@NativeConsDecl(c, child*, s) -> d
    with
      <store-def(|Constructors())> c => c-def;
      <store-prop(|Type(), c-def)> ConstructorType(<rw-type> child*, <rw-type> s);
      <store-prop(|ConsKind(), c-def)> NativeOpCons()

  store-constructor:
    d@ValueDecl(v, child*) -> d
    with
      <store-def(|Constructors())> v => v-def;
      <store-prop(|Type(), v-def)> ConstructorType(<rw-type> child*, ValueType())
  
  store-arrows = ArrowDeclarations(map(store-arrow))
  
  store-arrow:
    d@ArrowDecl(in-srt, arrow, out-srt) -> d
    with
      <store-def(|Arrows())> arrow => arrow-def;
      <store-prop(|Type(), arrow-def)> ArrowType(<rw-type> in-srt, <rw-type> out-srt)

  store-native-operators = NativeOperators(map(store-native-operator))
  
  store-native-operator:
    d@NativeOpDecl(c, child*, s) -> d
    with
      <store-def(|Constructors())> c => c-def;
      <store-prop(|Type(), c-def)> ConstructorType(<rw-type> child*, <rw-type> s);
      <store-prop(|ConsKind(), c-def)> NativeOpCons()

  store-native-datatypes = NativeDataTypes(map(store-native-datatype))

  store-native-datatype:
    d@NativeBaseTypeDecl(jstring, name, func*) -> d
    with
      <store-def(|NativeType())> name => name-def;
      <store-prop(|NativeTypeJString(), name-def)> jstring;
      <map(store-native-datatype-op(|name-def))> func*

  store-native-datatype:
    d@NativeSubTypeDecl(javastring, name, sup, func*) -> d
    with
      <store-def(|NativeType())> name => name-def;
      <store-prop(|NativeTypeJString(), name-def)> javastring;
      <store-prop(|SuperType(), name-def)> sup;
      <map(store-native-datatype-op(|name-def))> func*
      
  store-native-datatype-op(|par-def):
    d@NativeFunctionDecl(name, arg*, s) -> d
    with
      <store-def(|NativeDTFun(par-def))> name => name-def;
      <store-prop(|Type(), name-def)> FunctionType(<rw-type> arg*, <rw-type> s)

  store-semantic-components = SemanticComponents(map(store-semantic-component))
  
  store-semantic-component:
    d@SemanticComponent(name, MapSort(key-ty, val-ty)) -> d
    with
      <store-def(|Types())> name => name-def;
      <store-prop(|SuperType(), name-def)> MapType(<rw-type> key-ty, <rw-type> val-ty)

rules
  
  check-signatures = alltd(check-signature)
  
  check-signature =
    ( ?SimpleSort(s) + ?InjDecl(_, s) + ?InternalInjDecl(_, s) );
    <not(lookup-def(|Types()) + lookup-def(|NativeType()))> <id-to-type> s;
    add-msg(|Error(), s, $[Sort [s] is not declared])

  check-signature =
    ?Con(cname, _);
    <not(lookup-def(|Constructors()))> cname;
    add-msg(|Error(), cname, $[Constructor [cname] is not declared])
  
  check-signature =
    (
      ?NativeOpDecl(c, _, _)
      + ?ConsDecl(c, _, _)
      + ?InternalConsDecl(c, _, _)
      + ?NativeConsDecl(c, _, _)
      + ?ValueDecl(c, _)
    );
    <lookup-defs(|Constructors())> c => [_, _ | _];
    add-msg(|Error(), c, $[Duplicate constructor [c]])

  check-signature =
    ?decl@ArrowDecl(in-srt, name, out-srt);
    in-ty := <rw-type> in-srt;
    out-ty := <rw-type> out-srt;
    arrow-def := <lookup-def(|Arrows())> name;
    arrow-ty* := <lookup-props(|Type()); filter(not(?ArrowType(in-ty, out-ty))); make-set> arrow-def;
    <fetch-elem(?ArrowType(<id>, _); !(<id>, in-ty); type-coerce-sym)> arrow-ty*;
    add-msg(|Error(), decl, $[Arrow LHS overlaps with another arrow with the same name])
    

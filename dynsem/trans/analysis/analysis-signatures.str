module analysis/analysis-signatures

imports
  include/ds
  analysis/lib-analysis
  analysis/constructors
  analysis/analysis-rules
  analysis/query

rules /* store signatures */
  
  store-signatures =
    Signatures(map(
      store-sorts
      <+ store-constructors
      <+ store-native-operators
      <+ store-arrows
      <+ store-native-datatypes
      <+ store-variable-schemes
    ))
  
  store-built-ins =
    <store-def(|Types())> IntType() => def-int; <store-prop(|SortKind(), def-int)> SystemSort()
    ; <store-def(|Types())> RealType() => def-real; <store-prop(|SortKind(), def-real)> SystemSort()
    ; <store-def(|Types())> BoolType() => def-bool; <store-prop(|SortKind(), def-bool)> SystemSort()
    ; <store-def(|Types())> StringType() => def-str; <store-prop(|SortKind(), def-str)> SystemSort()

  store-sorts = Sorts(map(store-sort))

  store-sort:
    decl@SortDecl(ty) -> decl
    where
      <store-def(|Types())> ty => ty-def;
      <store-prop(|SortKind(), ty-def)> LanguageSort()

  store-constructors =
    Constructors(map(store-constructor))
    + NativeConstructors(map(store-constructor))
  
  store-constructor:
    d@ConsDecl(c, child*, s, Annos(anno*)) -> d
    with
      <store-def(|Constructors())> c => c-def;
      <store-prop(|Type(), c-def)> ConstructorType(<rw-type> child*, <rw-type> s);
      if <fetch-elem(?ImplicitAnno())> anno*
      then
        <store-prop(|ConsKind(), c-def)> ImplicitCons()
      else
        <store-prop(|ConsKind(), c-def)> LanguageCons()
      end

  store-constructor:
    d@NativeConsDecl(c, child*, s) -> d
    with
      <store-def(|Constructors())> c => c-def;
      <store-prop(|Type(), c-def)> ConstructorType(<rw-type> child*, <rw-type> s);
      <store-prop(|ConsKind(), c-def)> NativeCons()

  store-arrows = ArrowDeclarations(map(store-arrow))
  
  store-arrow:
    d@ArrowDecl(in-srt, arrow, out-srt) -> d
    with
      <store-def(|Arrows())> arrow => arrow-def;
      <store-prop(|Type(), arrow-def)> ArrowType(<rw-type> in-srt, <rw-type> out-srt)

  store-native-operators = NativeOperators(map(store-native-operator))
  
  store-native-operator:
    d@NativeOpDecl(c, child*, s) -> d
    with
      <store-def(|Constructors())> c => c-def;
      <store-prop(|Type(), c-def)> ConstructorType(<rw-type> child*, <rw-type> s);
      <store-prop(|ConsKind(), c-def)> NativeOpCons()

  store-native-datatypes = NativeDataTypes(map(store-native-datatype))

  store-native-datatype:
    d@NativeBaseTypeDecl(jstring, name, func*) -> d
    with
      <store-def(|Types())> name => name-def;
      <store-prop(|SortKind(), name-def)> NativeSort();
      <store-prop(|NativeTypeJString(), name-def)> jstring;
      <map(store-native-datatype-op(|name-def))> func*

  store-native-datatype:
    d@NativeSubTypeDecl(javastring, name, sup, func*) -> d
    with
      <store-def(|Types())> name => name-def;
      <store-prop(|SortKind(), name-def)> NativeSort();
      <store-prop(|NativeTypeJString(), name-def)> javastring;
      <store-prop(|SuperType(), name-def)> sup;
      <map(store-native-datatype-op(|name-def))> func*
      
  store-native-datatype-op(|par-def):
    d@NativeFunctionDecl(name, arg*, s) -> d
    with
      <store-def(|NativeDTFun(par-def))> name => name-def;
      <store-prop(|Type(), name-def)> FunctionType(<rw-type> arg*, <rw-type> s)

  store-variable-schemes = VariableSchemes(map(store-variable-scheme))
  
  store-variable-scheme:
    d@VariableScheme(prefix, ty) -> d
    with
      <store-def(|VarSchemes())> prefix => scheme-def;
      <store-prop(|Type(), scheme-def)> <rw-type> ty

rules
  
  check-signatures = alltd(check-signature)
  
  check-signature =
    ?SimpleSort(s);
    <id-to-type; not(lookup-def(|Types()))> s;
    add-msg(|Error(), s, $[Sort [s] is not declared])

  check-signature =
    (
      ?SortDecl(s)
      + ?NativeBaseTypeDecl(_, s, _)
      + ?NativeSubTypeDecl(_, s, _, _)
    );
    <lookup-defs(|Types())> s => [_, _ | _];
    add-msg(|Error(), s, $[Duplicate sort [s]])
  
  check-signature =
    ?vs@VariableScheme(prefix, _);
    <get-matching-varschemes> prefix => [_, _ | _];
    add-msg(|Error(), vs, $[Duplicate or overlapping variable prefix [prefix]])
  
  check-signature =
    ?Con(cname, _);
    <not(lookup-def(|Constructors()))> cname;
    add-msg(|Error(), cname, $[Constructor [cname] is not declared])
  
  check-signature =
    (
      ?NativeOpDecl(c, _, _)
      + ?ConsDecl(c, _, _, _)
      + ?NativeConsDecl(c, _, _)
    );
    <lookup-defs(|Constructors())> c => [_, _ | _];
    add-msg(|Error(), c, $[Duplicate constructor [c]])

  check-signature =
    ?ConsDecl(c, [_, _ | _], _, <id>);
    fetch-elem(?ImplicitAnno());
    add-msg(|Error(), c, $[Only unary constructors may be implicit])

  check-signature =
    ?decl@ArrowDecl(in-srt, name, out-srt);
    in-ty := <rw-type> in-srt;
    out-ty := <rw-type> out-srt;
    arrow-def := <lookup-def(|Arrows())> name;
    arrow-ty* := <lookup-props(|Type()); filter(not(?ArrowType(in-ty, out-ty))); make-set> arrow-def;
    <fetch-elem(?ArrowType(<id>, _); !(<id>, in-ty); type-coerce-sym(type-coerce-full(id)))> arrow-ty*;
    add-msg(|Error(), decl, $[Arrow LHS overlaps with another arrow with the same name])
    

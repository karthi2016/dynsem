module analysis/store-rules

imports
  include/ds
  analysis/lib-analysis
  analysis/constructors
  analysis/coercion
  ds

rules /* store variables */
  
  store-rules = map(store-rule)
  
  store-rule:
    r@Rule(p*, _, Relation(Reads(r*), Source(lhs, sc*), NamedDynamicEmitted(_, arrow-name), Target(rhs, tc*))) -> r
    where
      debug(!1);
      ArrowType(ma-ty, bu-ty) := <lookup-def(|Arrows()); lookup-prop(|Type())> arrow-name;
      <type-of-top> (ma-ty, lhs);
      
      fail
  
  type-of-top = 
    ?(ty, t); 
    ( 
      <type-of> t
      <+ 
      <add-msg(|Error(), "Type check failed")> t
    )
  
  type-of:
    (ty, dec) -> ty
    where
      <?Var(v) + ?MatchedVar(v)> dec
    where
      <store-def(|Vars())> v => v-def;
      <store-prop(|Type(), v-def)> ty
  
  type-of:
    (ty, VarRef(v)) -> ty
    where
      <lookup-def(|Vars()); lookup-prop(|Type())> v => v-ty;
      <type-coerce> (v-ty, ty) // TODO continue here
      
  
  type-of:
    (ty, Con(c, child*)) -> ty-con
    where
      ConstructorType(child-ty*, ty-con) := <lookup-def(|Constructors()); lookup-prop(|Type())> c;
      <zip; map(type-of)> (child-ty*, child*)

//   store-rule:
//     r@Rule(p*, _, Relation(Reads(r*), Source(lhs, sc*), NamedDynamicEmitted(_, arrow-name), Target(rhs, tc*))) -> r
//     with
//     	debug(!1);
//     	AType(ma-ty, bu-ty) := <lookup-def(|Arrows()); lookup-prop(|Type())> arrow-name;
//     	debug(!2);
//     	<store-variables> (ma-ty, lhs);
//     	debug(!3);
//     	<map(\ LabelComp(l, r) -> (l, r) \; store-variables)> [r*, sc*];
//     	debug(!4);
//     	<map(store-premise)> p*
//     	;debug(!5)
// 
//   store-variables:
//     (ty@LType(_), List([])) -> ty
//   
//   store-variables:
//     (ty@LType(ety), ListTail([hd], tl)) -> ty
//     with
//       <store-variables> (ety, hd);
//       <store-variables> (ty, tl)
// 
//   store-premise:
//     f@Formula(Match(lhs, rhs)) -> f
//     with
//       lhs-ty := <type-of> lhs;
//       <store-variables> (lhs-ty, rhs)
// 
//   store-premise:
//     f@TryOr(PremiseBlock(l*), PremiseBlock(r*)) -> f
//     with
//       <map(store-premise)> l*;
//       <map(store-premise)> r*
//   
//   store-premise:
//     f@MergePoint(cond, PremiseBlock(l*), PremiseBlock(r*)) -> f
//     with
//       <map(store-premise)> l*;
//       <map(store-premise)> r*
// 
//   type-of:
//     VarRef(v) -> <lookup-def(|Vars()); lookup-prop(|Type())> v
//   
//   type-of:
//     Con(c, _) -> <lookup-def(|Constructors()); lookup-prop(|Type())> c
// 
//   type-of:
//   	List([]) -> LType("Term")
// 
//   type-of:
//   	ListTail([h], tl) -> LType(<type-of> h)


rules
  
  // type-coerce-or-err = type-coerce <+ ?(ty1, ty2)
  
  type-coerce:
    (ty-from, ty-to) -> <fail>



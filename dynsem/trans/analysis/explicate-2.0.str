module analysis/explicate-2.0

imports
  signatures/-

rules

  explication-2-explicate-module:
    mod@Module(name, section*) -> Module($[[name]_explicated2], section'*)
    where
      section'* := <explication-2-explicate-top> section*
  
  explication-2-explicate-top = fail


rules

  explicate-2-analysis-module =
    // store inter-arrow dependencies
    // store arrow semantic components
    id

/*

Semantic components are labelled: L1 S, L2 S, L3 S

we declare semantic components like all other things:

signature semantic components
  L1 : S1
  L2 : (X, Y)

an arrow -A-> has RO components and RW components:
  Sc(-A->) = { C(L1, RO), C(L2, RO), C(L3, RW) }

an arrow has imports on the semantic components of other arrows. a dependence entry for arrow -A->
to arrow -B-> indicates an import for all components except those explicitly excluded:

  ScImp(-A->) = { Imp(-B->, [L1]), Imp(-B->, [L1, L2]), ... } 

above, rule -A-> imports all components of -B-> except for component L1. The components in the intersection of the exclusion set of all imports
are not imported. 

A rule over -A-> having a premise call to -B-> which explicitly mentions components L1 and L2; the premise excludes those components from the imported components.


Algorithm:

Given a rule over arrow -A->, for each premise over -B-> with explicit components Ls:
  - Sc(-B->) = Sc(-B->) + Ls
  - ScImp(-A->) = ScImp(-A->) + Imp(-B->, Ls)




*/




//signature
//  sorts
//    Arrow
//
//  constructors
//    Arr: Type * String -> Arrow
//
//strategies
//  
//  /*
//  * Given a specification initialize the interarrow dependency list
//  * with the declared arrows.
//  * 
//  * @type: Module -> List(Tuple(Arr, []))
//  */
//  explicate-2-deplist-init =
//    collect-all(?ArrowDecl(_, _, _, _, _, _));
//    nub;
//    map(\ ArrowDecl(_, s, _, arrow, _, _) -> (Arr(s, arrow), []) \)
//  
//  explicate-2-deplist-add(|deplist):
//    (from, to@Arr(_, _)) -> <map((?from, try(not(fetch-elem(?to)); ![to | <id>])))> deplist
//  
//  /*
//  * Given a specification populate the interarrow dependency list
//  *
//  * @type: Module -> List(Tuple(Arr, List(Arr)))
//  */
//  explicate-2-deplist-build =
//    ?mod;
//    <env-alltd(explicate-2-deplist-build-rule)> (mod, <explicate-2-deplist-init> mod) 
//  
//  explicate-2-deplist-build-rule:
//    (Rule(prem*, _, Relation(_, _, NamedDynamicEmitted(_, "init"), _)), deplist) -> <fail>
//
////  explicate-2-deplist-build-intern(|deplist) =
////    env-alltd(
//    
//    
////    ArrowDecl(
////              ArrowROs([MapSort(SimpleSort("String"), SimpleSort("V"))])
////            , SimpleSort("lookup__Meta")
////            , ArrowRWs([MapSort(SimpleSort("Int"), SimpleSort("V"))])
////            , "default"
////            , SimpleSort("V")
////            , ArrowRWs([MapSort(SimpleSort("Int"), SimpleSort("V"))])
////            )
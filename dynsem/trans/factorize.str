module factorize

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/ds
  ds
  lib-ds
  lib/editor-common.generated
  sugar
  mark-references
  tmp-factorization-extra
  
strategies
    
  factorize-module :
    Module(name, section*) -> Module(name, section'*)
    where
      section'* := <fixvars; map(try(factorize-rules))> section*
        
  factorize-rules = alltd(factorize-rule)
  
  fixvars = alltd(fixvar)
  
  fixvar:
    VarRef(x) -> Var(x)
  
  fixvar:
    MatchedVar(x) -> Var(x)
  
rules
  
  factorize-rule :
    Rule(prem1*, infer, 
          Relation(Reads(read*), Source(lhs,sc*), NamedDynamicEmitted(em1*, arrow), Target(rhs,tc*))) -> 
    Rule(prem7*, infer, 
          Relation(Reads(read'*), Source(lhs',sc'*), NamedDynamicEmitted(em1*, arrow), Target(rhs',tc'*)))
    with
    	while-counting(
    	  (prem2*, read'*) := <factorize-source-components> read*;
	      (prem3*, lhs') := <try-factor(factorize-lhs)> lhs;
	      (prem4*, sc'*) := <factorize-source-components> sc*;
	      (prem5*, rhs') := <try-factor(factorize-rhs)> rhs;
	      (prem6*, tc'*) := <factorize-target-components> tc*;
	      prem7* := <factorize-premises> [prem3*, prem2*, prem4*, prem1*, prem5*, prem6*]
	    )

  // factorize-rule :
  //   Rule(prem1*, infer, TermEq(lhs, rhs)) -> Rule(prem4*, infer, TermEq(lhs', rhs'))
  //   with
  //   	while-counting(
	 //    	(prem2*, lhs') := <factorize-lhs> lhs;
	 //      (prem3*, rhs') := <lift-constructors-from-rhs> rhs;
	 //      // prem4* := <lift-constructors-from-premises> [prem2*, prem1*, prem3*]
	 //      prem4* := [prem2*, prem1*, prem3*]
	 //    )

rules // lift constructor sub-terms in match
  
  try-factor(f) = try-factor(f, id)
  
  try-factor(f, succ) = f; try(succ) <+ !([], <id>)

  factorize-lhs:
  	Con(c, t1*) -> (p*, Con(c, t2*))
  	where
  		(p*, t2*) := <map(lift-match-on-cond(not(?Var(_)), ?succ)); unzip; (concat, id)> t1*;
  		!succ
  
  factorize-rhs = lift-build-on-cond(not(?Var(_)), ?succ); where(!succ)
  
  factorize-source-components = map(factorize-source-components); unzip; (concat, id)
  
  factorize-source-components:
    c@LabelComp(_, Var(_)) -> ([], c)
  
  factorize-source-components:
    LabelComp(ty, t) -> ([Formula(Match(Var(v), t))], LabelComp(ty, Var(v)))
    where
      <not(?Var(_))> t;
      v := <next-variable>
  
  factorize-target-components = map(factorize-source-components); unzip; (concat, id)
  
  factorize-target-components:
    c@LabelComp(_, Var(_)) -> ([], c)
  
  factorize-target-components:
    LabelComp(ty, t) -> ([Formula(Match(t, Var(v)))], LabelComp(ty, Var(v)))
    where
      <not(?Var(_))> t;
      v := <next-variable>
  
  factorize-premises = repeat(some(factorize-premise); flatten-list)
  
  factorize-premise =
    factorize-match-in-premise
    <+ factorize-termeq-in-premise
    <+ factorize-relation-in-premise
    
  factorize-match-in-premise:
    Formula(Match(lhs, rhs)) -> [p-lhs*, Formula(Match(lhs', rhs))]
    where
      (p-lhs*, lhs') := <factorize-build> lhs
  
  factorize-match-in-premise:
    Formula(Match(lhs, rhs)) -> [Formula(Match(lhs, rhs')), p-rhs*]
    where
      (p-rhs*, rhs') := <factorize-match> rhs
  
  factorize-match-in-premise:
    Formula(Match(lhs, rhs)) -> [Formula(TermEq(lhs, rhs))]
    where
      <is-constant> rhs
  
  factorize-termeq-in-premise = fail
  
  factorize-relation-in-premise = fail
  
  // factorize-relation-in-premise:
  // 	Formula(Relation(Reads(read*), Source(lhs,sc*), NamedDynamicEmitted(em1*, arrow), Target(rhs,tc*))) ->
  //   [p1*, p2*, p3*, Formula(Relation(Reads(read'*), Source(lhs',sc'*), NamedDynamicEmitted(em1*, arrow), Target(rhs',tc'*))), p4*, p5*]
  //   where
  //     (p1*, read'*) := <factorize-target-components> read*;
  //     
  //     
  //     (p2*, lhs') := <factorize-rhs> lhs;
  //     (p3*, sc'*) := <factorize-target-components> sc*;
  //     (p4*, rhs') := <factorize-lhs> rhs;
  //     (p5*, tc'*) := <factorize-source-components> tc*;
  //     fail

rules

  factorize-match = 
    factorize-constructors-in-match
    <+ factorize-listtail-in-match

  factorize-constructors-in-match:
    Con(c, t1*) -> (prem*, Con(c, t2*))
    where
      let cond = not(?Var(_))
      in
        (prem*, t2*) := <map(lift-match-on-cond(cond, ?success)); unzip; (concat, id)> t1*;
        !success
      end
  
  factorize-listtail-in-match:
    ListTail([x], xs) -> (prem*, ListTail([x], xs'))
    where
    	let cond = not(?Var(_))
    	in
        (prem*, xs') := <lift-match-on-cond(cond, ?success)> xs;
        !success
      end


  
  lift-match-on-cond(c, succ):
    t -> ([], t)
    where <not(c)> t
  
  lift-match-on-cond(c, succ):
    t -> ([Formula(Match(Var(x), t))], Var(x))
    where
       <c> t; try(succ);
       x := <next-variable>



  factorize-build =
    factorize-constructors-in-build
    <+ factorize-listtail-in-build
    <+ factorize-mapselect-in-build

  factorize-constructors-in-build:
    Con(c, t1*) -> (prem*, Con(c, t2*))
    where
      let cond = not(?Var(_))
      in
        (prem*, t2*) := <map(lift-build-on-cond(cond, ?success)); unzip; (concat, id)> t1*;
        !success
      end
  
  factorize-listtail-in-build:
    ListTail([x], xs) -> (prem*, ListTail([x], xs'))
    where
      let cond = not(?Var(_))
      in
        (prem*, xs') := <lift-build-on-cond(cond, ?success)> xs;
        !success
      end
  
  factorize-mapselect-in-build:
    MapExtend(l, r) -> (prem*, MapExtend(l, r'))
    where
      let cond = not(?Var(_))
      in
        (prem*, r') := <lift-build-on-cond(cond, ?success)> r;
        !success
      end
    
  lift-build-on-cond(c, succ):
    t -> ([], t)
    where <not(c)> t
  
  lift-build-on-cond(c, succ):
    t -> ([Formula(Match(t, Var(x)))], Var(x))
    where
      <c> t; try(succ);
      x := <next-variable>

  is-constant = ?Int(_) + ?Real(_) + ?String(_) + ?True() + ?False()
	
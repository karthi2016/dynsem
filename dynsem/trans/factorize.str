module factorize

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/ds
  ds
  lib-ds
  lib/editor-common.generated
  sugar
  mark-references
  
strategies
    
  factorize-module :
    Module(name, section*) -> Module(name, section'*) 
    where
      section'* := <map(try(factorize-rules))> section*
        
  factorize-rules = alltd(factorize-rule)
    
rules
  
  factorize-rule :
    Rule(prem1*, infer, 
          Relation(reads, Source(lhs,sc*), NamedDynamicEmitted(em1*, arrow), Target(rhs,tc*))) -> 
    Rule(prem6*, infer, 
          Relation(reads, Source(lhs',sc*), NamedDynamicEmitted(em1*, arrow), Target(rhs',tc'*)))
    with
    	while-counting(
	      (prem2*, lhs') := <factorize-match> lhs;
	      (prem3*, rhs') := <lift-constructors-from-rhs> rhs;
	      (prem4*, tc'*) := <lift-constructors-from-tc> tc*;
	      prem5* := <lift-constructors-from-premises> [prem2*, prem1*, prem3*, prem4*];
	      prem6* := <lift-mapselect-from-premises> prem5*
	    )
          
  factorize-rule :
    Rule(prem1*, infer, TermEq(lhs, rhs)) -> Rule(prem4*, infer, TermEq(lhs', rhs'))
    with
    	while-counting(
	    	(prem2*, lhs') := <factorize-match> lhs;
	      (prem3*, rhs') := <lift-constructors-from-rhs> rhs;
	      prem4* := <lift-constructors-from-premises> [prem2*, prem1*, prem3*]
	    )

rules // lift constructor sub-terms in match
  
  factorize-match =
    factorize-constructors-in-match
    <+ factorize-listtail-in-match
    <+ factorize-constant-in-match
    <+ !([], <id>)
     
  
  factorize-constructors-in-match:
    Con(c, t1*) -> (prem*, Con(c, t2*))
    where (prem*, t2*) := <map(factorize-match); unzip; (concat, id)> t1*

  factorize-constructors-in-match:
    t@Con(c, _) -> ([Formula(Match(Var(x), t))], Var(x))
    with x := <next-variable>

  factorize-listtail-in-match:
  	l@List([]) -> ([Formula(Match(Var(x), l))], Var(x))
  	with x := <next-variable>
  
  factorize-listtail-in-match:
    lt@ListTail([elem], tl) -> ([Formula(Match(Var(x), lt))], Var(x))
    with
      x := <next-variable>

  factorize-constant-in-match:
    t@Int(_) -> ([Formula(TermEq(Var(x), t))], Var(x))
    with x := <next-variable>

  factorize-constant-in-match:
    t@Real(_) -> ([Formula(TermEq(Var(x), t))], Var(x))
    with x := <next-variable>

  factorize-constant-in-match:
    t@String(s) -> ([Formula(TermEq(Var(x), t))], Var(x))
    with x := <next-variable>

rules // lift constructor sub-terms in build
  
  lift-constructors-from-rhs:
    t@Con(c, t*) -> ([Formula(Match(t, Var(x)))], Var(x))
    where
      x := <next-variable>

  lift-constructors-from-rhs:
    mex@MapExtend(_, _) -> ([Formula(Match(mex, Var(x)))], Var(x))
    where
      x := <next-variable>

  lift-constructors-from-rhs:
    m@Map(_) -> ([Formula(Match(m, Var(x)))], Var(x))
    where
      x := <next-variable>

  lift-constructors-from-rhs:
    l@List([]) -> ([Formula(Match(l, Var(x)))], Var(x))
    where
      x := <next-variable>

  lift-constructors-from-rhs:
    l@ListTail(_, _) -> ([Formula(Match(l, Var(x)))], Var(x))
    where
      x := <next-variable>

  lift-constructors-from-rhs:
    bool -> ([Formula(Match(bool, Var(x)))], Var(x))
    where
      ?True() + ?False()
    where
      x := <next-variable>

  lift-constructors-from-rhs:
    t -> ([], t)
    where <not(?Con(_,_) + ?MapExtend(_, _) + ?Map(_) + ?List(_) + ?ListTail(_, _))> t

rules // lift from output components
  
  lift-constructors-from-tc:
    [] -> ([], [])
  
  lift-constructors-from-tc:
    [ x | xs ] -> ([prem1*, prem2*], [x' | xs'])
    with
      (prem1*, x') := <lift-constructors-from-tc> x;
      (prem2*, xs') := <lift-constructors-from-tc> xs

  lift-constructors-from-tc:
    tc@LabelComp(name, VarRef(_)) -> ([], tc)
  
  lift-constructors-from-tc:
    LabelComp(name, t) -> ([Formula(Match(t, MatchedVar(x)))], LabelComp(name, VarRef(x)))
    with
      x := <next-variable>
  
rules // lift from build
  
  lift-constructors-from-build :
    t -> ([], t)
    where <not(?Con(_,_))> t    
        
  lift-constructors-from-build :
    Con(c, t1*) -> (prem*, Con(c, t2*))
    where (prem*@[_|_], t2*) := <map(lift-constructor-from-build); unzip; (concat, id)> t1*
    
  lift-constructor-from-build :
    t@Con(c, _) -> ([Formula(TermEq(t, Var(x)))], Var(x))
    where x := <next-variable>   
    
  lift-constructor-from-build :
    t -> ([], t)
    where <not(?Con(_,_))> t

rules // lift constructors from sub-terms in premises
  
  lift-constructors-from-premises :
    [] -> []  
    
  lift-constructors-from-premises :
    [prem | prem1*] -> prem3*
    where if prem2* := <lift-constructors-from-premise> prem then
            prem3* := <lift-constructors-from-premises> [prem2*, prem1*]
          else
            prem3* := [prem | <lift-constructors-from-premises> [prem1*]]
          end

  lift-constructors-from-premise :
    Formula(TermEq(lhs, rhs)) -> [prem1*, Formula(TermEq(lhs', rhs')), prem2*]  
    where (prem1*, lhs') := <lift-constructors-from-build> lhs;
          (prem2*, rhs') := <factorize-match> rhs;
          (not(<?[]> prem1*) <+ not(<?[]> prem2*))

  lift-constructors-from-premise :
    Formula(TermEq(lhs, rhs)) -> [prem1*, Formula(TermEq(lhs', rhs')), prem2*]  
    where (prem1*, lhs') := <lift-constructors-from-build> lhs;
          (prem2*, rhs') := <factorize-match> rhs;
          (not(<?[]> prem1*) <+ not(<?[]> prem2*))
  
  lift-constructors-from-premise :
    Formula(Match(lhs, Con(c, t1*))) -> [Formula(Match(lhs, Con(c, t2*))), ma*]
    where
      <fetch-elem(?Con(_, _) + ?ListTail(_, _) + ?List(_))> t1*;
      (ma*, t2*) := <map(factorize-match); unzip; (concat, id)> t1*

  lift-constructors-from-premise :
    Formula(Match(lhs, As(x, t))) -> <lift-constructors-from-premises> [Formula(Match(lhs, t)), Formula(Match(lhs, Var(x)))]

  lift-constructors-from-premise :
    Formula(Match(lhs, ListTail([c@Con(_, _)], xs))) -> <lift-constructors-from-premises> [Formula(Match(lhs, ListTail([Var(x)], xs))), Formula(Match(Var(x), c))]
    where
      x := <next-variable>
  
  lift-constructors-from-premise :
    Formula(Match(lhs, ListTail([elem], xs))) -> <lift-constructors-from-premises> [Formula(Match(lhs, ListTail([elem], Var(xs-lifted)))), Formula(Match(Var(xs-lifted), xs))]
    where
      <not(?Var(_) + ?VarRef(_))> xs
    where
      xs-lifted := <next-variable>
  
  lift-constructors-from-premise :
    Formula(Relation(reads, source, relation, Target(As(v, t), tc*))) ->
      <lift-constructors-from-premises> [Formula(Relation(reads, source, relation, Target(Var(x), tc*))), Formula(Match(Var(x), As(v, t))) ]
      with
      	x := <next-variable>

  lift-constructors-from-premise :
    Formula(Relation(reads, source, relation, Target(con@Con(_, _), tc*))) ->
      <lift-constructors-from-premises> [Formula(Relation(reads, source, relation, Target(Var(x), tc*))), Formula(Match(Var(x), con)) ]
    with
      x := <next-variable>

  lift-constructors-from-premise :
    Formula(Relation(Reads(rd*), Source(s, sc*), relation, target)) ->
      <lift-constructors-from-premises> [prem1*, prem2*, Formula(Relation(Reads(rd'*), Source(s, sc'*), relation, target))]
    where
      <fetch-elem(?LabelComp(_, MapExtend(_, _)))> sc*
      <+
      <fetch-elem(?LabelComp(_, MapExtend(_, _)))> rd*
    with
      (prem1*, sc'*) := <map(lift-mapextend-from-comp); unzip; (concat, id)> sc*;
      (prem2*, rd'*) := <map(lift-mapextend-from-comp); unzip; (concat, id)> rd*

  lift-constructors-from-premise :
    Formula(Relation(Reads(rd*), Source(s, sc*), relation, target)) ->
      <lift-constructors-from-premises> [prem1*, prem2*, Formula(Relation(Reads(rd'*), Source(s, sc'*), relation, target))]
    where
      <fetch-elem(?LabelComp(_, True()) + ?LabelComp(_, False()))> sc*
      <+
      <fetch-elem(?LabelComp(_, True()) + ?LabelComp(_, False()))> rd*
    with
      (prem1*, sc'*) := <map(lift-boollit-from-comp); unzip; (concat, id)> sc*;
      (prem2*, rd'*) := <map(lift-boollit-from-comp); unzip; (concat, id)> rd*
      
  lift-constructors-from-premise :
    Formula(Relation(reads, Source(con@Con(_, _), sc*), relation, target)) ->
      <lift-constructors-from-premises> [Formula(Match(con, MatchedVar(x))), Formula(Relation(reads, Source(VarRef(x), sc*), relation, target))]
    with
      x := <next-variable>

  lift-mapextend-from-comp :
    LabelComp(name, mex@MapExtend(_, _)) -> ([Formula(Match(mex, MatchedVar(x)))], LabelComp(name, VarRef(x)))
    with
      x := <next-variable>
  
  lift-mapextend-from-comp :
    lc@LabelComp(name, t) -> ([], lc)
    where
      <not(?MapExtend(_, _))> t 

  lift-boollit-from-comp :
    LabelComp(name, lit) -> ([Formula(Match(lit, MatchedVar(x)))], LabelComp(name, VarRef(x)))
    where
      <?True() + ?False()> lit
    with
      x := <next-variable>
  
  lift-boollit-from-comp :
    lc@LabelComp(name, t) -> ([], lc)
    where
      <not(?True() + ?False())> t 

rules // lift map access from premises that do both match and bind
  
  lift-mapselect-from-premises:
    [prem | prem1* ] -> prem3*
    with
      if prem2* := <lift-mapselect-from-premise> prem then
        prem3* := <lift-mapselect-from-premises> [prem2*, prem1*]
      else
        prem3* := [prem | <lift-mapselect-from-premises> prem1* ]
      end
  
  lift-mapselect-from-premises:
    [] -> []
  
  lift-mapselect-from-premise:
    Formula(TermEq(lhs@MapSelect(_, _), rhs)) ->
      [Formula(TermEq(lhs, Var(x))), Formula(TermEq(VarRef(x), rhs))]
    where
      <?Con(_, _)> rhs
      + <?String(_)> rhs
      + <?Int(_)> rhs
      + <?Real(_)> rhs
    with
      x := <next-variable>
  
  lift-mapselect-from-premise:
    Formula(TermEq(lhs@MapSelect(_, _), rhs@VarRef(_))) ->
      [Formula(TermEq(lhs, Var(x))), Formula(TermEq(VarRef(x), rhs))]
    with
      x := <next-variable>

	
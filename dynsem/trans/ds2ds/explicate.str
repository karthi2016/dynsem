module ds2ds/explicate

imports
  signatures/ds-sig
  lib-ds
  
strategies
  
  explicate-module :
    mod@Module(name, section*) -> Module($[[name]_explicated], section'*)
    where
      section'* := <m-in-extracted-components(explicate-rules)> section*
      
  explicate-rules :
    rs -> <alltd(explicate-rule)> rs

rules // group rules by name
  
rules
  
  explicate-rule :
    r@Rule(_, _, Relation(_, _, NamedDynamicEmitted(_, "init"), _)) -> r
  
  explicate-rule :
    Rule(prem1*, infer, Relation(Reads(r1*), Source(lhs, sc1*), NamedDynamicEmitted(e1*, arrow), Target(rhs, tc1*))) ->   
      Rule(prem3*, infer, Relation(Reads(r2*), Source(lhs, sc2*), NamedDynamicEmitted(e2*, arrow), Target(rhs, tc2*)))
    where
      <not(?"init")> arrow
    with { CompNum:
      rules( CompNum: LabelComp(name, _) -> <CompNum> name ); // auto-unbox
      <CompList; map({?comp; rules( CompNum: comp -> 1 )})> arrow;
    	r2*    := <ReadableComps; map(\ comp -> <mk-label-comp(|<CompNum> comp)> comp \)> arrow;
      sc2*   := <ChangeableComps; map(\ comp -> <mk-label-comp(|<CompNum> comp)> comp \)> arrow;
      init*  := <map(\ comp -> <exp-label-comp-init(|<CompNum> comp)> comp \)> [r1*, sc1*];
      prem2* := <explicate-premises> prem1*;
      tc2*   := <ChangeableComps; map(\ comp -> <mk-label-comp(copy-comp(|tc1*)|<CompNum> comp)> comp \)> arrow;
      e2*    := <WritableComps; map(\ comp -> <copy-comp(|e1*) <+ concat-changeables(|<CompNum> comp)> comp \)> arrow;
      prem3* := [init* | prem2*]
    }
  
rules // components from lhs

  exp-label-comp-init(|num):
    LabelComp(name, t) -> Formula(Match(VarRef(<get-sort-name; comp-var(|num)> name), t))
 
rules // components in rhs
           
  copy-comp(|comps) :
    comp-name -> <fetch-elem(?LabelComp(comp-name,_))> comps
      
  concat-changeables(|num) :
    comp-name -> LabelComp(comp-name, Con("Concat", [List(<range; map(\i -> VarRef(<comp-var(|i)>comp-name) \)>(2, <inc>num))]))
    where <gt> (num, 2)

  concat-changeables(|num) :
    comp-name -> LabelComp(comp-name, VarRef(<comp-var(|2)>comp-name))
    where <eq> (num, 2)

  concat-changeables(|num) :
    comp-name -> LabelComp(comp-name, List([]))
    where <eq> (num, 1)
    
rules // premisses
                        
  explicate-premises:
    [] -> []
        
  explicate-premises:
    [prem1 | prem1*] -> [prem2*, prem3*]
    with
      prem2* := <explicate-premise> prem1;
      prem3* := <explicate-premises> prem1*
  
  explicate-premise:
    f@AllFail() -> [f]
  
  explicate-premise:
    form@Formula(Match(_, _)) -> [form]

  explicate-premise:
    form@Formula(NMatch(_, _)) -> [form]
  
  explicate-premise:
    form@Formula(TermEq(_, _)) -> [form]
  
  explicate-premise:
    form@Formula(TermNeq(_, _)) -> [form]

  explicate-premise:
    form@Formula(TypeCast(_, _)) -> [form]

  explicate-premise:
    form@Formula(TypeCheck(_, _)) -> [form]
    
  explicate-premise :
    Formula(Relation(Reads(r1*), Source(lhs, sc1*), NamedDynamicEmitted(e1*, arrow), Target(rhs, tc1*))) -> 
      [Formula(Relation(Reads(r2*), Source(lhs, sc2*), NamedDynamicEmitted(e2*, arrow), Target(rhs, tc2*))) | init*]
    with
      r2*   := <ReadableComps;  map(\ comp -> <mk-label-comp(copy-comp(|r1*)| <CompNum> comp)> comp \)> arrow; 
      sc2*  := <ChangeableComps;  map(\ comp -> <mk-label-comp(copy-comp(|sc1*)| <CompNum> comp)> comp \)> arrow;
      e2*   := <WritableComps; map(inc-comp-num; \ comp -> <mk-label-comp(|<CompNum> comp )> comp \)> arrow;
      tc2*  := <ChangeableComps; map(inc-comp-num; \ comp -> <mk-label-comp(|<CompNum> comp)> comp \)> arrow;
      if <?([], [_|_])> (e2*, e1*) then
        fatal-err-msg(|$[Arrow [arrow] does NOT emit writables, but they are explicitly expected in premises reducing over [arrow]])
      end;
      init* := <map(\ comp -> <exp-label-comp-init(|<CompNum> comp)> comp \)> [e1*, tc1*]
  
  explicate-premise:
    MergePoint(cform, PremiseBlock(prem1*), PremiseBlock(prem2*)) -> [MergePoint(cform, PremiseBlock(prem1'*), PremiseBlock(prem2'*))]
    with
    	{| CompNum:
        prem1'* := <explicate-premises> prem1*
      |};
      {| CompNum:
        prem2'* := <explicate-premises> prem2*
      |}
  
  explicate-premise:
    CaseMatch(tb, case*) -> [CaseMatch(tb, case'*)]
    with
      case'* := <map(explicate-case)> case*
  
  explicate-case:
    CaseOtherwise(prem*) -> CaseOtherwise(prem'*)
    with
      {| CompNum:
        prem'* := <explicate-premises> prem*
      |}

  explicate-case:
    CasePattern(pat, prem*) -> CasePattern(pat, prem'*)
    with
      {| CompNum:
        prem'* := <explicate-premises> prem*
      |}
  
  inc-comp-num:
    comp -> comp
    with 
      next-num := <CompNum; inc> comp;
      rules( CompNum : comp -> next-num )


module analysis/explicate-2.0

imports
  signatures/-
  analysis/-

rules

  explication-2-explicate-module:
    mod@Module(name, section*) -> Module($[[name]_explicated2], section'*)
    where
      Module(_, section'*) := <explication-2-explicate-top> mod
  
  explication-2-explicate-top =
    m-in-analysis(explication-2-gather-data; unrename-all); unmark-vars

signature
  sorts
    Import Component ArrowDef CompDef CompKind
  
  constructors
    Impo : ArrowDef * List(Component) -> Import  
    Comp : CompDef * CompKind -> Component
    RO : CompKind
    RW : CompKind

strategies
  
  explication-2-api-init-storage(sto-comps, sto-imps) =
    comps-table := <new-hashtable; sto-comps>;
    imps-table := <new-hashtable; sto-imps>;
    arrow-def* := <lookup-def-all(|Arrows())>;
    <map(\ arrow-def -> <hashtable-put(|arrow-def, [])> comps-table \)> arrow-def*;
    <map(\ arrow-def -> <hashtable-put(|arrow-def, [])> imps-table \)> arrow-def*
  
  explication-2-api-get-components(|comps, imps):
    arrow-def -> <hashtable-get(|arrow-def)> comps
  
  explication-2-api-add-components(|comps, imps):
    (arrow-def, new-compo*) -> compo*
    where
      old-compo* := <hashtable-get(|arrow-def)> comps;
      compo* := <nub> [new-compo*, old-compo*];
      <hashtable-put(|arrow-def, compo*)> comps
  
  explication-2-api-get-imports(|comps, imps):
    arrow-def -> <hashtable-get(|arrow-def)> imps
  
  explication-2-api-add-imports(|comps, imps):
    (arrow-def, new-imp*) -> imp*
    where
      old-imp* := <hashtable-get(|arrow-def)> imps;
      imp* := <nub> [new-imp*, old-imp*];
      <hashtable-put(|arrow-def, imp*)> imps
  
rules

  explication-2-gather-data =
    where(explication-2-api-init-storage(?comps-table, ?imps-table));
    where(explication-2-gather-data-arrowdecl(|comps-table, imps-table));
    where(alltd(explication-2-gather-data-rule(|comps-table, imps-table)));
    where(explication-2-compute-explicated-arrows(|comps-table, imps-table));
    explication-2-explicate-arrow-decls-module(|comps-table, imps-table)
  
  explication-2-gather-data-arrowdecl(|comps-table, imps-table) =
      lookup-def-all(|Arrows());
      map(explication-2-associate-decl-components(|comps-table, imps-table))

  explication-2-associate-decl-components(|comps-table, imps-table) =
    ?arrow-def;
    ro* := <lookup-prop(|ROs()); map(\ Label(x) -> Comp(<lookup-def(|Components())> x, RO()) \)> arrow-def;
    rw* := <lookup-prop(|RWs()); map(\ Label(x) -> Comp(<lookup-def(|Components())> x, RW()) \)> arrow-def;
    <explication-2-api-add-components(|comps-table, imps-table)> (arrow-def, [ro*, rw*])

  explication-2-gather-data-rule(|comps-table, imps-table):
    r@Rule(prem*, infer, Relation(reads, src@Source(lhs, _), arr, _)) -> r
    where // figure out which arrow definition we are using
      arrow-name := <get-arrow-name> arr;
      lhs-ty := <rulelhs-get-type> lhs;
      arrow-def* := <lookup-defs(|Arrows())> arrow-name;
      arrow-def := <get-applicable-arrowdef(type-coerce-full(id))> (arrow-def*, lhs-ty)
    where // associate components used in conclusion
      ro* := <explication-2-use-to-comp> reads;
      rw* := <explication-2-use-to-comp> src;
      <explication-2-api-add-components(|comps-table, imps-table)> (arrow-def, [ro*, rw*])
    where // store premise-derived information
      imp* := <filter(explication-2-gather-data-premise(|comps-table, imps-table); not(?Impo(arrow-def, _)))> prem*;
      <explication-2-api-add-imports(|comps-table, imps-table)> (arrow-def, imp*)
  
  explication-2-gather-data-premise(|comps-table, imps-table):
    Formula(Relation(reads, src@Source(lhs, _), arr, _)) -> Impo(arrow-def, <nub> [ex-ro*, ex-rw*])
    where // figure out which are definition we are using
      arrow-name := <get-arrow-name> arr;
      lhs-ty := <type-of> lhs;
      arrow-def* := <lookup-defs(|Arrows())> arrow-name;
      arrow-def := <get-applicable-arrowdef(flip(type-coerce-full(id)))> (arrow-def*, lhs-ty)
    where // associate components used in premise
      ro* := <explication-2-use-to-comp> reads;
      rw* := <explication-2-use-to-comp> src;
      <explication-2-api-add-components(|comps-table, imps-table)> (arrow-def, [ro*, rw*])
    where // compute imports
      ex-ro* := <explication-2-use-to-compdef> reads;
      ex-rw* := <explication-2-use-to-compdef> src
  
  explication-2-use-to-comp:
    Reads(r*) -> <map(\ LabelComp(Label(x), _) -> Comp(<lookup-def(|Components())> x, RO()) \)> r*
  
  explication-2-use-to-comp:
    Source(_, w*) -> <map(\ LabelComp(Label(x), _) -> Comp(<lookup-def(|Components())> x, RW()) \)> w*
  
  explication-2-use-to-compdef:
    Reads(r*) -> <map(\ LabelComp(Label(x), _) -> Comp(<lookup-def(|Components())> x, RO()) \)> r*
  
  explication-2-use-to-compdef:
    Source(_, w*) -> <map(\ LabelComp(Label(x), _) -> Comp(<lookup-def(|Components())> x, RW())\)> w*
  
  explication-2-compute-explicated-arrows(|comps-table, imps-table) =
    arrow-def* := <lookup-def-all(|Arrows())>;
    stack := <range; map(!arrow-def*); concat> (1, <length> arrow-def*);
    <explication-2-compute-explicated-arrows-work(|comps-table, imps-table)> stack
  
  explication-2-compute-explicated-arrows-work(|comps-table, imps-table):
    [] -> []
  
  explication-2-compute-explicated-arrows-work(|comps-table, imps-table):
    [arrow-def | defs] -> <explication-2-compute-explicated-arrows-work(|comps-table, imps-table)> defs
    where
      debug(!"i1");
      impo* := <explication-2-api-get-imports(|comps-table, imps-table)> arrow-def;
      debug(!"i2");
      imported-arrow* := <map(?Impo(<id>, _)); nub> impo*;
      debug(!"i3");
      compo* := <mapconcat(explication-2-compute-imported-comps(|impo*, comps-table, imps-table))> imported-arrow*;
      debug(!"i4");
      <explication-2-api-add-components(|comps-table, imps-table)> (arrow-def, compo*)
      ;debug(!"i5")
  
  explication-2-compute-imported-comps(|impo*, comps-table, imps-table):
    arrow-def -> new-compo*
    where
      debug(!"i6");
      compo* := <explication-2-api-get-components(|comps-table, imps-table)> arrow-def;
      excluded-compo* := <debug(!"i6a"); filter(?Impo(arrow-def, <id>)); debug(!"i6b"); !(<id>, compo*); foldl(debug(!"i6c"); isect; debug(!"i6d")); debug(!"i6e")> impo*;
      debug(!"i7");
      new-compo* := <diff> (compo*, excluded-compo*)
      ;debug(!"i8")
  
  explication-2-explicate-arrow-decls-module(|comps-table, imps-table):
    Module(name, section*) -> Module(name, section'*)
    where
      section'* := <map(try(Signatures(map(try(ArrowDeclarations(map(explication-2-explicate-arrow-decl(|comps-table, imps-table))))))))> section*

  explication-2-explicate-arrow-decl(|comps-table, imps-table):
    ArrowDecl(_, lhs-s, _, arrow-name, rhs-s, _) -> <debug(!"ex9")> ArrowDecl(ArrowROs(ro*), lhs-s, ArrowRWs(rw*), arrow-name, rhs-s, ArrowRWs(rw*))
    where
      lhs-ty := <rw-type> lhs-s;
      arrow-def* := <lookup-defs(|Arrows())> arrow-name;
      arrow-def := <get-applicable-arrowdef(type-coerce-full(id))> (arrow-def*, lhs-ty);
      (ro-comp*, rw-comp*) := <explication-2-api-get-components(|comps-table, imps-table); partition(?Comp(_, RO()))> arrow-def;
      (ro*, rw*) := <(map(\ Comp(x, _) -> Label(<def-get-name> x) \), map(\ Comp(x, _) -> Label(<def-get-name> x) \))> (ro-comp*, rw-comp*)


/*
Arrow explication algorithm in O(N^2) steps

Let arrow stack S.

Pop R in S:
  associate components Imps(-R->) into Comps(-R->)
  
*/

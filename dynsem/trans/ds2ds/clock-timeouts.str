module ds2ds/timeout-rules

imports
  coq-semantics/-
  signatures/-
  ds
  analysis/-
  lib-ds
  ds2ds/explicate-arrow-types

// Adds a timeout rule to relations indicated as being timeoutable

rules

  add-timeouts(|ds2v_timeouts):
    mod -> mod''
    with
       // Augment relations with with timeouts where applicable
      mod' := <foldr(!mod,
                      \ ((arrow_name, src_sort), mod) -> mod'
                        where
                          mod' := <bottomup(try(\ ArrowDecl(ArrowROs(ros), src_sort, rws, arrow_name, tgt_sort, rws') ->
                                                   ArrowDecl(ArrowROs([SimpleSort("nat")|ros]), src_sort, rws, arrow_name, tgt_sort, rws') \));
                                    bottomup(try(add-clocks-to-rule(|arrow_name, src_sort)))> mod \)> ds2v_timeouts;
      // Add timeout rules
      rs :=
        <map({ rs, sig, ros, rws, to_sort, rws', arrow_name, src_sort :
              ?(arrow_name, src_sort);
              <alltd(?ArrowDecl(ArrowROs([SimpleSort("nat")|ros]), src_sort, ArrowRWs(rws), arrow_name, to_sort, ArrowRWs(rws')))> mod';
              ro_vars := <map(\ sort -> LabelComp(sort, Var(<newname> "_lifted")) \)> ros;
              rw_vars := <map(\ sort -> LabelComp(sort, Var(<newname> "_lifted")) \)> rws;
              rw'_vars := <map(\ LabelComp(sort, Var(x)) -> LabelComp(sort, VarRef(x)) \)> rw_vars;
              r := Rule([], "---------",
                    Relation(Reads([LabelComp(SimpleSort("nat"), Con("O", []))|ro_vars]),
                                    Source(Cast(Var(<newname> "_lifted"), src_sort), rw_vars),
                                    NamedDynamicEmitted([], arrow_name, src_sort),
                                    Target(<mk-timeout-val> to_sort, rw'_vars)));
              <store-rule> r; // Invoke DynSem analysis on rule
              !r
           })> ds2v_timeouts;
      mod'' := <alltd(\ Rules(rs0) -> Rules(<concat> [rs0, rs])\)> mod'

rules // Adding timeouts with sensible clock variable names

  add-clocks-to-rule(|arrow_name, src_sort):
    rule@Rule(prems, d, Relation(Reads(ros), src, lbl, tgt)) ->
      Rule(prems', d, Relation(Reads([LabelComp(SimpleSort("nat"), Con("S", [Var(i)]))|ros]), src, lbl, tgt))
    with
      // Generate fresh clock variable name
      pvars := <extract-variables> prems;
      svars := <extract-variables> Relation(Reads(ros), src, lbl, tgt);
      vars := <concat> [pvars, svars];
      !"i";
      i := <repeat(\ vname -> <concat-strings> (vname, "'") where <elem> (vname, vars) \)>;
      prems' := <map(add-clocks-to-premise(|i, arrow_name, src_sort))> prems

  add-clocks-to-premise(|i, arrow_name, src_sort):
    Formula(Relation(Reads(ros), s, a@NamedDynamicEmitted(lbl, arrow_name, src_sort), Target(target, rws))) ->
      Formula(Relation(Reads([LabelComp(SimpleSort("nat"), VarRef(i))|ros]), s, a, Target(target, rws)))
  
  add-clocks-to-premise(|i, arrow_name, src_sort):
    p -> p
    where
      not(!p; ?Formula(Relation(Reads(ros), s, a@NamedDynamicEmitted(lbl, arrow_name, src_sort), Target(target, rws))))

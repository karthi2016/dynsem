module generator/interpreter/pre-generation

imports
  include/ds
  ds
  pp
  lib-ds
  sugar
  explicate
  factorize
  mark-references
  generator/interpreter/unification
  
rules
  
rules /* rename variables */

  escape-variable-names:
    t -> <alltd(Var(escape-identifier) <+ VarRef(escape-identifier) <+ MatchedVar(escape-identifier))> t
  
  escape-identifier = string-replace(|"'", "_")

rules
  
  fuse-sections:
    Module(mod, body*) -> Module(mod, [import, Signatures(signatures), Rules(rule-decl*)]) 
    with
      import       := <collect-all(?Imports(<id>)); concat; !Imports(<id>)> body*;
      sort-decl    := <collect-all(?Sorts(<id>)); concat; !Sorts(<id>)> body*;
      semcomp-decl := <collect-all(?SemanticComponents(<id>)); concat; !SemanticComponents(<id>)> body*;
      intsort-decl := <collect-all(?InternalSorts(<id>)); concat; !InternalSorts(<id>)> body*;
      natty-decl   := <collect-all(?NativeDataTypes(<id>)); concat; !NativeDataTypes(<id>)> body*;
      cons-decl    := <collect-all(?Constructors(<id>)); concat; !Constructors(<id>)> body*;
      intcons-decl := <collect-all(?InternalConstructors(<id>)); concat; !InternalConstructors(<id>)> body*;
      natcons-decl := <collect-all(?NativeConstructors(<id>)); concat; !NativeConstructors(<id>)> body*;
      natops-decl  := <collect-all(?NativeOperators(<id>)); concat; !NativeOperators(<id>)> body*;
      values-decl  := <collect-all(?Values(<id>)); concat; !Values(<id>)> body*;
      arrow-decl   := <collect-all(?ArrowDeclarations(<id>)); concat; !ArrowDeclarations(<id>)> body*;
      signatures    := [ sort-decl, intsort-decl, cons-decl, semcomp-decl, intcons-decl, natcons-decl, natops-decl, values-decl, arrow-decl, natty-decl ];
      rule-decl*    := <collect-all(?Rules(<id>)); concat> body*

signature
  constructors
    OptMap: List(Term) -> Term

rules /* optimize environments */

  optimize-environments = alltd(optimize-environment)

  optimize-environment:
    mex@MapExtend(_, _) -> OptMap(<implode-env-extend; eliminate-env-blanks> mex)

  optimize-environment:
    map@Map(_) -> OptMap(<implode-env-extend; eliminate-env-blanks> map)

  implode-env-extend:
    MapExtend(map1, map2) -> [ bind1*, bind2* ]
    with
      bind1* := <implode-env-extend> map1;
      bind2* := <implode-env-extend> map2

  implode-env-extend:
    Map([]) -> [ Map([]) ]
  
  implode-env-extend:
    Map([bind@Bind(_, _)]) -> [ bind ]
  
  implode-env-extend:
    v@VarRef(_) -> [ v ]
  
  eliminate-env-blanks:
    [ Map([]), bind | xsbind ] -> <eliminate-env-blanks> [bind | xsbind]
  
  eliminate-env-blanks:
    [ bind | xsbind ] -> [bind | <eliminate-env-blanks> xsbind ]
    where
      <not(?Map([]))> bind
  
  eliminate-env-blanks:
    [] -> []

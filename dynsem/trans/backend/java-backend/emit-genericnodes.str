module backend/java-backend/emit-genericnodes

imports
  include/ds
  libjava-front
  
imports
  analysis/constructors
  analysis/lib-analysis

imports
  backend/java-backend/utils
  backend/java-backend/analysis-extra
  backend/java-backend/lib-ds2java
  backend/java-backend/emit-arrows
  backend/java-backend/emit-maputils

rules
  
  ds2java-genericnodes:
    Module(_, _) -> <map(debug(!"A "); def-get-name; debug(!"B "); ds2java-genericnode; debug(!"C "))> def-ty* 
    where
      def-ty* := <lookup-def-all(|Types()); filter(where(lookup-prop(|SortKind()) => LanguageSort()))>

  ds2java-genericnode:
    ty -> 
      compilation-unit |[ 
        package ~x:<AutoPackageName>;
        
        import org.metaborg.meta.interpreter.framework.*;
        import org.spoofax.interpreter.terms.*;
        import org.spoofax.jsglr.client.imploder.ImploderAttachment;
        import org.spoofax.interpreter.core.Tools;
        
        @SuppressWarnings("unused")
        public class ~x:gennodename extends AbstractNode implements ~x:sortname, IGenericNode {
          
          public IStrategoTerm aterm;
          
          public ~x:gennodename(INodeSource source, IStrategoTerm term) {
            this.setSourceInfo(source);
            this.aterm = term;
          }
          
          @Override
          public <T> T match(Class<T> clazz) {
            return specialize(1).match(clazz);
          }
          
          @Override
          public void specializeChildren(int depth){
            throw new InterpreterException("Operation not supported");
          }
          
          @Override
          public ~x:sortname specialize(int depth) {
            if(replaced()) {
              return (~x:sortname) replacement();
            }
            if (aterm instanceof IStrategoAppl) {
              final IStrategoAppl term = (IStrategoAppl) aterm;
              final String name = term.getName();
              final INodeSource source = NodeSource.fromStrategoTerm(term);

              ~bstm*:<mapconcat(debug(!1); ds2java-consdecl-specializer; debug(!2))> c-def*
            }
            IGenericNode replacement = null;
            
            ~bstm*:<foldr(![], debug(!3); ds2java-sortinj-specializer; debug(!4))> ty-def*
            
            throw new RewritingException(aterm.toString());
            
          }
          
          @Override
          public IStrategoTerm toStrategoTerm(ITermFactory factory) {
            return aterm;
          }

          ~exec*

        }
      ]|
    where
      sortname := <ds2java-sort-classname> ty;
      gennodename := $[Generic_[sortname]];
      c-def* := <lookup-def-all(|Constructors()); filter(where(lookup-prop(|Type()) => ConstructorType(_, ty)); where(lookup-prop(|ConsKind()) => LanguageCons()))>;
      ty-def* := <lookup-def-all(|Types()); filter(where(lookup-prop(|SuperType()) => ty); where(lookup-prop(|SortKind()) => LanguageSort()))>;
      exec* := <lookup-applicable-arrow-def; map(ds2java-arrow-specializedispatch)> ty

  ds2java-consdecl-specializer:
  	c-def ->
			bstm* |[
			  if(name.equals(~e:Lit(String([Chars(<escape> c-name)]))) && term.getSubtermCount() == ~i:<length; int-to-string> c-c-ty*) {
			    ~x:sortname replacement = replace(new ~x:consname(source, e*));
			    if (depth > 0) {
			      replacement.specializeChildren(depth - 1);
			    }
			    return replacement;
		    }
			]|
    where
      debug(!11);
      c-name := <def-get-name> c-def;
      debug(!12);
      ConstructorType(c-c-ty*, c-ty) := <lookup-prop(|Type())> c-def;
      debug(!13);
      sortname := <ds2java-sort-classname> c-ty;
      debug(!14);
      consname := <ds2java-constr-classname> c-name;
      debug(!15);
      e* := <map-with-index((\ idx -> e |[ term.getSubterm(~i:<int-to-string> idx)]| \, id); ds2java-gennode-instantiation)> c-c-ty*
      ;debug(!16)
  
  subterm-at-index:
    idx -> e |[ term.getSubterm(~i:<int-to-string> idx) ]|

  ds2java-gennode-instantiation:
    (e_trm, ty) -> e |[ new ~x:gennodename(NodeSource.fromStrategoTerm(e_trm), e_trm) ]|
    where
      not(!ty => ListType(_));
      ty-def := <lookup-def(|Types())> ty;
      <not(lookup-prop(|SortKind()) => SystemSort())> ty-def;
      <not(lookup-prop(|SortKind()) => SemanticCompSort())> ty-def;
      gennodename := $[Generic_[<ds2java-sort-classname> ty]]

  ds2java-gennode-instantiation:
    (e_trm, lty@ListType(e-ty)) -> e |[ new x_listname(NodeSource.fromStrategoTerm(e_trm)).fromStrategoTerm(e_trm) ]|
    where
      x_listname := <ds2java-sort-classname> lty
  
  ds2java-gennode-instantiation:
    (e_trm, ty) -> e |[ AutoMapUtils.x_tosemcomp(e_trm) ]|
    where
      ty-def := <lookup-def(|Types())> ty;
      <lookup-prop(|SortKind())> ty-def => SemanticCompSort();
      ty-name := <def-get-name> ty-def;
      x_tosemcomp := <ds2java-aterm2map-name> ty-name
 
  ds2java-gennode-instantiation:
    (e_trm, StringType()) -> e |[ Tools.asJavaString(e_trm) ]|

  ds2java-gennode-instantiation:
    (e_trm, IntType()) -> e |[ Tools.asJavaInt(e_trm) ]|

  ds2java-gennode-instantiation:
    (e_trm, RealType()) -> e |[ Tools.asJavaDouble(e_trm) ]|
  
  // TODO
  ds2java-gennode-instantiation:
    (e_trm, BoolType()) -> e |[ 55 ]| // TODO: maybe there is some actual conversion convention we could use

  ds2java-sortinj-specializer:
  	(ty-def, bstm*) ->
			bstm* |[
				try {
					if(replacement != null) {
						replacement.replace(this);
					}
					replacement = new ~x:gennodename(getSourceInfo(), aterm);
					return (~x:sortname) replace(replacement).specialize(1);
				} catch(RewritingException ~x:<newname>) {
					bstm*
				}
			]|
		where
			sortname := <def-get-name; ds2java-sort-classname> ty-def;
			gennodename := $[Generic_[sortname]]

  ds2java-arrow-specializedispatch:
    (arrow-def, ArrowType(_, bu-ty)) ->
      class-body-dec |[
        public ~x:<ds2java-returnclassname> (arrow-def, bu-ty) ~x:execname(param*){
        	return specialize(1).~x:execname(e*);
        }
      ]|
    where
      execname := <ds2java-methodname> (arrow-def, bu-ty);
      param* := <lookup-arrow-inputs; map-with-index(ds2java-method-paramdecl)> arrow-def;
      e* := <lookup-arrow-inputs; map-with-index(\ (idx, _) -> e |[ ~x:$[_[idx]] ]| \)> arrow-def



module backend/java-backend/emit-genericnodes

imports
  include/ds
  libjava-front
  
imports
  analysis/constructors
  analysis/lib-analysis

imports
  backend/java-backend/utils
  backend/java-backend/analysis-extra
  backend/java-backend/lib-ds2java
  backend/java-backend/emit-arrows

rules
  
  ds2java-genericnodes:
    Module(_, _) -> <map(def-get-name; ds2java-genericnode)> def-ty* 
    where
      def-ty* := <lookup-def-all(|Types()); filter(where(lookup-prop(|SortKind()) => LanguageSort()))>

  ds2java-genericnode:
    ty -> 
      compilation-unit |[ 
        package ~x:<AutoPackageName>;
        
        import org.metaborg.meta.interpreter.framework.*;
        import org.spoofax.interpreter.terms.*;
        import org.spoofax.jsglr.client.imploder.ImploderAttachment;
        import org.spoofax.interpreter.core.Tools;
        
        public class ~x:gennodename extends AbstractNode implements ~x:sortname, IGenericNode {
          
          public IStrategoTerm aterm;
          
          public ~x:gennodename(INodeSource source, IStrategoTerm term) {
            this.setSourceInfo(source);
            this.aterm = term;
          }
          
          @Override
          public <T> T match(Class<T> clazz) {
            return specialize(1).match(clazz);
          }
          
          @Override
          public void specializeChildren(int depth){
            throw new InterpreterException("Operation not supported");
          }
          
          @Override
          @SuppressWarnings("unused")
          public ~x:sortname specialize(int depth) {
            if(replaced()) {
              return (~x:sortname) replacement();
            }
            if (aterm instanceof IStrategoAppl) {
              final IStrategoAppl term = (IStrategoAppl) aterm;
              final String name = term.getName();
              final INodeSource source = NodeSource.fromStrategoTerm(term);

              ~bstm*:<mapconcat(ds2java-consdecl-specializer)> c-def*
            }
            IGenericNode replacement = null;
            
            ~bstm*:<foldr(![], ds2java-sortinj-specializer)> ty-def*
            
            throw new RewritingException(aterm.toString());
            
          }
          
          @Override
          public IStrategoTerm toStrategoTerm(ITermFactory factory) {
            return aterm;
          }

          ~exec*

        }
      ]|
    where
      sortname := <ds2java-sort-classname> ty;
      gennodename := $[Generic_[sortname]];
      c-def* := <lookup-def-all(|Constructors()); filter(where(lookup-prop(|Type()) => ConstructorType(_, ty)); where(lookup-prop(|ConsKind()) => LanguageCons()))>;
      ty-def* := <lookup-def-all(|Types()); filter(where(lookup-prop(|SuperType()) => ty); where(lookup-prop(|SortKind()) => LanguageSort()))>;
      exec* := <lookup-applicable-arrow-def; map(ds2java-arrow-specializedispatch)> ty

  ds2java-consdecl-specializer:
  	c-def ->
			bstm* |[
			  if(name.equals(~e:Lit(String([Chars(<escape> c-name)]))) && term.getSubtermCount() == ~i:<length; int-to-string> c-c-ty*) {
			    ~x:sortname replacement = replace(new ~x:consname(source, e*));
			    if (depth > 0) {
			      replacement.specializeChildren(depth - 1);
			    }
			    return replacement;
		    }
			]|
    where
      c-name := <def-get-name> c-def;
      ConstructorType(c-c-ty*, c-ty) := <lookup-prop(|Type())> c-def;
      sortname := <ds2java-sort-classname> c-ty;
      consname := <ds2java-constr-classname> c-name;
      e* := <map-with-index((dec, id); ds2java-gennode-instantiation)> c-c-ty*
      
  ds2java-gennode-instantiation:
    (idx, ty) -> e |[ new ~x:gennodename(source, term.getSubterm(~i:<int-to-string> idx)) ]|
    where
      not(!ty => ListType(_));
      ty-def := <lookup-def(|Types())> ty;
      <not(lookup-prop(|SortKind()) => SystemSort())> ty-def;
      gennodename := $[Generic_[<ds2java-sort-classname> ty]]

  ds2java-gennode-instantiation:
    (idx, lty@ListType(e-ty)) -> e |[ new x_listname(NodeSource.fromStrategoTerm(term.getSubterm(i))).fromStrategoTerm(term.getSubterm(i)) ]|
    where
      i := <int-to-string> idx;
      x_listname := <ds2java-sort-classname> lty

  ds2java-gennode-instantiation:
    (idx, StringType()) -> e |[ Tools.asJavaString(term.getSubterm(~i:<int-to-string> idx)) ]|

  ds2java-gennode-instantiation:
    (idx, IntType()) -> e |[ Tools.asJavaInt(term.getSubterm(~i:<int-to-string> idx)) ]|

  ds2java-gennode-instantiation:
    (idx, RealType()) -> e |[ Tools.asJavaDouble(term.getSubterm(~i:<int-to-string> idx)) ]|

  ds2java-sortinj-specializer:
  	(ty-def, bstm*) ->
			bstm* |[
				try {
					if(replacement != null) {
						replacement.replace(this);
					}
					replacement = new ~x:gennodename(getSourceInfo(), aterm);
					return (~x:sortname) replace(replacement).specialize(1);
				} catch(RewritingException ~x:<newname>) {
					bstm*
				}
			]|
		where
			sortname := <def-get-name; ds2java-sort-classname> ty-def;
			gennodename := $[Generic_[sortname]]

  ds2java-arrow-specializedispatch:
    (arrow-def, ArrowType(_, bu-ty)) ->
      class-body-dec |[
        public ~x:<ds2java-returnclassname> (arrow-def, bu-ty) ~x:execname(param*){
        	return specialize(1).~x:execname(e*);
        }
      ]|
    where
      execname := <ds2java-methodname> (arrow-def, bu-ty);
      param* := <lookup-arrow-inputs; map-with-index(ds2java-method-paramdecl)> arrow-def;
      e* := <lookup-arrow-inputs; map-with-index(\ (idx, _) -> e |[ ~x:$[_[idx]] ]| \)> arrow-def



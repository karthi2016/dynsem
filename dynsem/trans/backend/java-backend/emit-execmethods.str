module backend/java-backend/emit-execmethods

imports
  include/ds
  ds

imports
  analysis/lib-analysis
  analysis/constructors

imports
  backend/java-backend/analysis-extra
  backend/java-backend/lib-ds2java
  backend/java-backend/emit-arrows

signature
  constructors
  	NoOpPremise: Premise

rules
  
  ds2java-execmethods(|rule*):
    c -> <map(ds2java-execmethod(|rule*))> applicable-arrow*
    where
      ConstructorType(c-c-ty*, c-ty) := <lookup-def(|Constructors()); lookup-prop(|Type())> c;
      applicable-arrow* := <lookup-def(|Types()); lookup-applicable-arrow-def> c-ty
      
  ds2java-execmethod(|rule*):
    (arrow-def, ArrowType(_, bu-ty)) ->
      class-body-dec |[
        public ~x:<ds2java-returnclassname> (arrow-def, bu-ty) ~x:execname(param*){
          this.specializeChildren(0);
          
          bstm*
        }
      ]|
    where
      execname := <ds2java-methodname> (arrow-def, bu-ty);
      param* := <lookup-arrow-inputs; map-with-index(ds2java-method-paramdecl)> arrow-def;
      arrow-name := <def-get-name> arrow-def;
      rule := <fetch-elem(?Rule(_, _, Relation(_, _, NamedDynamicEmitted(_, arrow-name), _)))> rule*;
      bstm* := <ds2java-rulestatements> rule
  
  ds2java-rulestatements:
    Rule(prem*, _, Relation(Reads(r*), Source(Con(c, patt-var*), sc*), NamedDynamicEmitted(_, arrow-name), tgt)) -> [component*, patternbound*, premstms*]
    where
    	// bind reads and incoming changeables
    	component* := <map-with-index(ds2java-componentbind)> [r*, sc*];
    	// bind pattern bound variables
    	patternbound* := <map-with-index(ds2java-patternboundbind)> patt-var*;
    	// compile the premises
    	premstms* := <foldr(![], ds2java-premise(|tgt))> prem*
  
  ds2java-componentbind:
  	(idx, LabelComp(_, Var(v))) -> bstm |[ final ~x:typename ~x:v = ~x:$[_[idx]]; ]|
  	where
  		typename := <lookup-def(|Vars()); lookup-prop(|Type()); ds2java-sort-classname> v

  ds2java-patternboundbind:
  	(idx, Var(v)) -> bstm |[ final ~x:typename ~x:v = this.~x:$[_[idx]]; ]|
  	where
  		typename := <lookup-def(|Vars()); lookup-prop(|Type()); ds2java-sort-classname> v

  ds2java-premise(|tgt):
    (TryOr(PremiseBlock(p1*), PremiseBlock(p2*)), []) ->
      bstm* |[
      	{
      		// bstm1*
      	}
      	{
      		// bstm2*
      	}
      ]|
    where with(fail|"Not implemented")

  ds2java-premise(|tgt):
    (MergePoint(p, PremiseBlock(p1*), PremiseBlock(p2*)), []) ->
      bstm* |[
      	
      ]|
    where with(fail|"Not implemented")
  
//   // ds2java-premise(|tgt):
//   //   ()
//   
//   // BUILD => PATTERN  
//   ds2java-premiseop:
//     (Formula(Match(VarRef(v), r)), on-success*, on-failure*) -> <fail>
// 
//   // BUILD => VARDEF
//   ds2java-premiseop:
//     (Formula(Match(b, MatchedVar(v))), on-success*, on-failure*) -> <fail>
//   
//   // STHING =!=> STHING
//   ds2java-premiseop:
//     (Formula(NMatch(l, r)), on-success*, on-failure*) -> <ds2java-premiseop> (Formula(Match(l, r)), on-failure*, on-success*)
//   
//   // variable : TYPE
//   ds2java-premiseop:
//     (Formula(TypeCheck(VarRef(v), ty-trm)), on-success*, on-failure*) ->
//       bstm* |[
//         if(~x:v instanceof ~x:tyname) {
//           bstm1*
//         }else{
//           bstm2*
//         }
//       ]|
//     where
//       ty := <rw-type> ty-trm;
//       tyname := <ds2java-sort-classname> ty;
//       v-new := <newname>;
//       // <store-def
//       // store definition
//       // update type
//       // on-success'* := <alltd(?VarRef(v); !VarRef(v-new))> on-success*
//       bstm1* := <fail>
//       
//   
//   // BUILD == BUILD
//   ds2java-premiseop:
//     (Formula(TermEq(l, r)), on-success*, on-falure*) -> <fail>
//   
//   // BUILD != BUILD
//   ds2java-premiseop:
//     (Formula(TermNeq(l, r)), on-success*, on-failure*) -> <ds2java-premiseop> (Formula(TermEq(l, r)), on-failure*, on-success*)
// 
// 
// 
// 
//       
// 

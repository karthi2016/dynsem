module backend/java-backend/emit-maputils

imports
  ds
  libjava-front

imports
  analysis/constructors
  analysis/lib-analysis

imports
	backend/java-backend/utils
	backend/java-backend/lib-ds2java
	backend/java-backend/emit-atermconversion
	backend/java-backend/emit-genericnodes
	
rules
  
  ds2java-maputils =
    collect-all(?MapSort(_, _); rw-type);
    make-set;
    ds2java-maputils-maps;
    MkSingleton
  
  ds2java-maputils-maps:
    map-ty* ->
      compilation-unit |[
        package ~x:<AutoPackageName>;
        
        import java.util.Map;
        import java.util.Map.Entry;
				import java.util.TreeMap;
        import org.spoofax.interpreter.terms.*;
        import org.spoofax.interpreter.core.Tools;
        import org.metaborg.meta.interpreter.framework.*;
        import com.github.krukow.clj_ds.PersistentMap;
        import com.github.krukow.clj_lang.PersistentTreeMap;
        
        public class AutoMapUtils {
          ~conv*
        }
      ]|
    where
      conv* := <mapconcat(ds2java-maputils-map)> map-ty*
  
  ds2java-maputils-map:
    m-ty@MapType(k-ty, v-ty) ->
      class-body-dec* |[
        public static IStrategoTerm x_toterm(PersistentMap<x_kty, x_vty> map, ITermFactory factory) {
          IStrategoConstructor bindCons = factory.makeConstructor("Bind", 2);

          IStrategoTerm[] kids = new IStrategoTerm[map.size() + 1];

          int idx = 0;
          for (Entry<x_kty, x_vty> entry : map.entrySet()) {
            kids[idx] = factory.makeAppl(bindCons,
                        e_keytrm, e_valtrm);
            idx++;
          }
          
          return factory.makeAppl(factory.makeConstructor("Map", 2), kids);
        }
        
        public static x_maptype x_fromterm(IStrategoTerm term) {        
			    final Map<x_kty, x_vty> result = new TreeMap<x_kty, x_vty>();
			    if (Tools.isTermAppl(term)) {
			      IStrategoAppl appl = (IStrategoAppl) term;
			      if (Tools.hasConstructor(appl, "Map", 2)) {
		          for (int idx = 1; idx < term.getSubtermCount(); idx++) {
		            IStrategoTerm kid = term.getSubterm(idx);
		            if (Tools.isTermAppl(kid)) {
		              IStrategoAppl bindAppl = (IStrategoAppl) kid;
		              if (Tools.hasConstructor(bindAppl, "Bind", 2)) {
		                result.put(e_key, e_value);
		              }
		            }
		          }
		          return PersistentTreeMap.create(result);
			
			      }
			    }
			
			    throw new RewritingException("Malformed map");
			  }
      ]|
    where
      x_toterm := <ds2java-map2aterm-name> m-ty;
      x_fromterm := <ds2java-aterm2map-name> m-ty;
      x_maptype := <ds2java-type-to-unboxed-type> m-ty;
      x_kty := <ds2java-type-to-boxed-type> k-ty;
      x_vty := <ds2java-type-to-boxed-type> v-ty;
      e_keytrm := <ds2java-atermconversion-name(| e |[ entry.getKey() ]|)> k-ty;
      e_valtrm := <ds2java-atermconversion-name(| e |[ entry.getValue() ]|)> v-ty;
      e_key := <ds2java-gennode-instantiation> (e |[ bindAppl.getSubterm(0) ]|, k-ty);
      e_value := <ds2java-gennode-instantiation> (e |[ bindAppl.getSubterm(1) ]|, v-ty)

  ds2java-map2aterm-name:
    m-ty@MapType(_, _) -> $[[<ds2java-type-to-identifier> m-ty]2aterm]

  ds2java-aterm2map-name:
    m-ty@MapType(_, _) -> $[aterm2[<ds2java-type-to-identifier> m-ty]]

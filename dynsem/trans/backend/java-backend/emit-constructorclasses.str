module backend/java-backend/emit-constructorclasses

imports
  include/ds

imports
  analysis/constructors
  analysis/lib-analysis

imports
  backend/java-backend/utils
  backend/java-backend/lib-ds2java
  backend/java-backend/emit-arrows
  backend/java-backend/analysis-extra
  backend/java-backend/emit-execmethods

rules
  
  // generate classes for constructors
  ds2java-constructorclasses:
    Module(_, section*) -> <map(def-get-name; ds2java-constructorclass(|rule*))> constr-def*
    where
      rule* := <fetch-elem(?Rules(<id>))> section*;
      constr-def* := <lookup-def-all(|Constructors()); filter(not(lookup-prop(|ConsKind()) => NativeOpCons()))>
  
  // generate class for constructor
  ds2java-constructorclass(|rule*):
    c ->
	    compilation-unit |[
	      package ~x:<AutoPackageName>;
	      
	      import org.metaborg.meta.interpreter.framework.*;
	
	      public class x_consname extends AbstractNode implements ~x:<ds2java-sort-classname> c-ty {
	        
	        private boolean hasSpecialized;

	        ~fdec*
	        
	        public x_consname(INodeSource source, param0*) {
            this.setSourceInfo(source);
            bstm0*
          }
	        
	        @Override
	        public boolean equals(Object obj) {
	          if (this == obj) {
	            return true;
	          }
	          if (obj == null) {
	            return false;
	          }
	          if (getClass() != obj.getClass()) {
	            return false;
	          }
	          
	          final x_consname other = (x_consname) obj;
	          
	          bstm1*
	        
	          return true;
	        }
	        
	        @Override
	        public void specializeChildren(int depth) {
            if (!hasSpecialized) {
              bstm2*
              hasSpecialized = true;
            }
          }

	        ~exec*

	        ~fget*
	        
	      }
	    ]|
    where
    	x_consname := <ds2java-constr-classname> c;
      c-def := <lookup-def(|Constructors())> c;
      ConstructorType(c-c-ty*, c-ty) := <lookup-prop(|Type())> c-def
    where
      fdec* := <map-with-index(ds2java-fielddecl)> c-c-ty*;
    	param0* := <map-with-index(ds2java-method-paramdecl)> c-c-ty*;
    	bstm0* := <map-with-index(ds2java-fieldinit)> c-c-ty*;
    	fget* := <map-with-index(ds2java-getter)> c-c-ty*;
    	bstm1* := <map-with-index(ds2java-field-eq-check)> c-c-ty*;
    	bstm2* := <map-with-index(ds2java-field-specializer)> c-c-ty*;
    	exec* := <ds2java-execmethods> c
  
  // generate equality check for a field that is of native type
  ds2java-field-eq-check:
    (idx, ty) -> 
      bstm* |[
        if (x_idx != other.x_idx) {
          return false;
        }
      ]|
    where
      <ds2java-type-is-primitive> ty;
      x_idx := <mkidx> idx
  
  // generate equality check for a field that is of user type
  ds2java-field-eq-check:
      (idx, ty) -> 
      bstm* |[
        if (x_idx == null) {
          if (other.x_idx != null) {
            return false;
          }
        } else if (!x_idx.equals(other.x_idx)) {
          return false;
        }
      ]|
    where
      <not(ds2java-type-is-primitive)> ty;
      x_idx := <mkidx> idx

  // no specializer code for a non-adoptable child
  ds2java-field-specializer:
  	(_, ty) -> []
  	where
  		<not(type-is-adoptable + type-is-adoptable-list)> ty

  // specializer code for an adoptable non-list child
	ds2java-field-specializer:
	  (idx, ty) ->
	    stm |[
	      if (x_idx instanceof IGenericNode) {
	        ((IGenericNode) x_idx).specialize(depth);
	      }
	    ]|
	  where
	  	<type-is-adoptable> ty;
	  	<not(type-is-adoptable-list)> ty;
	  	x_idx := <mkidx> idx

  // specializer code for adoptable children
	ds2java-field-specializer:
		(idx, ty) ->
		  stm |[
		    for (x_ty x_idxelem : x_idx) {
		      if (x_idxelem instanceof IGenericNode) {
		        ((IGenericNode) x_idxelem).specialize(depth);
		      }
		    }
		  ]|
		where
		  <type-is-adoptable-list> ty;
		  x_ty := <?ListType(<id>); ds2java-sort-classname> ty;
		  x_idx := <mkidx> idx;
		  x_idxelem := $[[x_idx]_elem]

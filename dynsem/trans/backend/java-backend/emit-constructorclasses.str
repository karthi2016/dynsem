module backend/java-backend/emit-constructorclasses

imports
  include/ds

imports
  analysis/constructors
  analysis/lib-analysis

imports
  backend/java-backend/utils
  backend/java-backend/lib-ds2java
  backend/java-backend/emit-arrows
  backend/java-backend/emit-execmethods
  backend/java-backend/emit-atermconversion
  backend/java-backend/emit-specializercode

rules
  
  // generate classes for constructors
  ds2java-constructorclasses:
    Module(_, section*) -> <map(def-get-name; ds2java-constructorclass(|rule*))> constr-def*
    where
      rule* := <fetch-elem(?Rules(<id>))> section*;
      constr-def* := <lookup-def-all(|Constructors()); filter(where(lookup-prop(|ConsKind()); not(?NativeOpCons() + NativeCons())))>
  
  // generate class for constructor
  ds2java-constructorclass(|rule*):
    c ->
	    compilation-unit |[
	      package ~x:<AutoPackageName>;
	      
	      import org.metaborg.meta.interpreter.framework.*;
	      import org.spoofax.interpreter.terms.*;
	      import com.github.krukow.clj_lang.PersistentTreeMap;

        @SuppressWarnings("unused")
	      public class x_consname extends AbstractNode implements ~x:<ds2java-sort-classname> c-ty {
	        

	        ~fdec*
	        
	        public x_consname(INodeSource source, param0*) {
            this.setSourceInfo(source);
            bstm0*
          }
	        
	        @Override
	        public boolean equals(Object obj) {
	          if (this == obj) {
	            return true;
	          }
	          if (obj == null) {
	            return false;
	          }
	          if (getClass() != obj.getClass()) {
	            return false;
	          }
	          
	          final x_consname other = (x_consname) obj;
	          
	          bstm1*
	        
	          return true;
	        }

          ~specializer*
          
	        ~exec*

	        ~fget*

          ~atermconvert
	        
	      }
	    ]|
    where
    	x_consname := <ds2java-constr-classname> c;
      c-def := <lookup-def(|Constructors())> c;
      ConstructorType(c-c-ty*, c-ty) := <lookup-prop(|Type())> c-def
    where
      fdec* := <map-with-index(ds2java-fielddecl)> c-c-ty*;
    	param0* := <map-with-index(ds2java-method-paramdecl)> c-c-ty*;
    	bstm0* := <map-with-index(ds2java-fieldinit)> c-c-ty*;
    	fget* := <map-with-index(ds2java-getter)> c-c-ty*;
    	bstm1* := <map-with-index(ds2java-field-eq-check)> c-c-ty*;
    	specializer* := <ds2java-specializer-method> c-c-ty*;
    	exec* := <ds2java-execmethods(|rule*)> c;
    	atermconvert := <ds2java-atermconversion-constructor> c
  
  // generate equality check for a field that is of native type
  ds2java-field-eq-check:
    (idx, ty) -> 
      bstm* |[
        if (x_idx != other.x_idx) {
          return false;
        }
      ]|
    where
      <ds2java-type-is-primitive> ty;
      x_idx := <mkidx> idx
  
  // generate equality check for a field that is of user type
  ds2java-field-eq-check:
      (idx, ty) -> 
      bstm* |[
        if (x_idx == null) {
          if (other.x_idx != null) {
            return false;
          }
        } else if (!x_idx.equals(other.x_idx)) {
          return false;
        }
      ]|
    where
      <not(ds2java-type-is-primitive)> ty;
      x_idx := <mkidx> idx



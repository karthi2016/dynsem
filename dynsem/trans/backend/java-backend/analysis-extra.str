module backend/java-backend/analysis-extra

imports
  include/ds
  lib-ds
  analysis/constructors
  analysis/lib-analysis
  analysis/analysis-rules
  
signature
  constructors
    ArrowReadables: Property
    ArrowChangeables: Property

rules
  
  m-in-backend-extra-analysis(s) =
    where(backend-extra-analyze);
    s
  
  backend-extra-analyze =
    log-timed( store-arrows-components | "Java backend extra analysis")
 
  lookup-arrow-readables = lookup-prop(|ArrowReadables())
  lookup-arrow-changeables = lookup-prop(|ArrowChangeables())
  lookup-arrow-inputs = ?a-def; <conc> (<lookup-arrow-readables> a-def, <lookup-arrow-changeables> a-def)
 
  store-arrows-components =
    ?m@Module(_, _);
    
    lookup-def-all(|Arrows());
    map(store-arrow-components(|m))
  
  store-arrow-components(|m) =
  	?arrow-def;
    arrow-name := <def-get-name> arrow-def;
    if <collect-one(?Rule(_, _, Relation(_, _, NamedDynamicEmitted(_, arrow-name), _)))> m => Rule(_, _, Relation(Reads(r*), Source(_, sc*), _, _))
    then
	    <map(?LabelComp(<rw-type>, _)); store-prop(|ArrowReadables(), arrow-def)> r*;
	    <map(?LabelComp(<rw-type>, _)); store-prop(|ArrowChangeables(), arrow-def)> sc*
	  else
	    <store-prop(|ArrowReadables(), arrow-def)> [];
	    <store-prop(|ArrowChangeables(), arrow-def)> []
	  end

  lookup-applicable-arrow-def:
    type -> <lookup-def-all(|Arrows()); filter(\ a-def -> (a-def, <lookup-props(|Type()); fetch-elem(where(is-applicable-arrow-def(|type)))> a-def) \); make-set>

  is-applicable-arrow-def(|type-name) =
    ?ArrowType(type-name, _)
    <+
    ?ArrowType(ltype-name, _);
    <type-coerce> (type-name, ltype-name)

  lookup-arrow-def:
    (c-ty, arrow-name) -> <fetch-elem(where(Fst; def-get-name; ?arrow-name))> arrow*
    where
      <lookup-applicable-arrow-def> c-ty => arrow*
      

  type-is-adoptable = where(lookup-def(|Types()); lookup-prop(|SortKind()); (?LanguageSort() + ?InternalSort()))

  type-is-adoptable-list = where(?ListType(<id>); type-is-adoptable)
  

module coq-semantics/codegen

imports
  coq-semantics/-
  ds
  signatures/-
  coq-signatures/-
  coq-signatures/extensions/-
  coq-signatures/tactic/-
  
rules // Sort-to-type generation

  sort-to-coq:
    SimpleSort(x) -> x

  sort-to-coq:
    MapSort(x, y) -> Apply(Apply(maptype, x'), y')
    with
      maptype := <coq-map-type>;
      x' := <sort-to-coq> x;
      y' := <sort-to-coq> y
 
rules // AST sort constructors to inductive types in Coq

  // The (0|1) for this relation is used to indicate whether we are generating a new inductive type (1) or not (0). 
  //   sort-decls-to-coq \subseteq List(SortName) x List(SortName) x (0|1)
  //                               x List(Induc) x List(SortName) 
  sortdecls-to-coq(|sort_decl_map, sort_dep_map):
    (srts, seen_sorts, w) -> (res, seen_sorts'')
    with
      // If the list of sort names is empty, we are done generating sort constructors 
      ( [] := srts; res := []; seen_sorts'' := seen_sorts )
        <+ 
      [sort_name|sort_names] := srts;
      // If the constructors for the current sort has already been generated, don't generate it again.
      ( ( <elem> (sort_name, seen_sorts);
         // Generate the constructors for the rest of the sort names
         (res, seen_sorts'') := <sortdecls-to-coq(|sort_decl_map, sort_dep_map)> (sort_names, seen_sorts, w) )
        <+
      // Otherwise, generate it
      ( constrctors := <hashtable-get(|sort_name)> sort_decl_map;
        // Generate its constructors
        coq_constrctors := <map(sort-constructor-to-coq(|sort_name))> constrctors;
        deps := <hashtable-get(|sort_name)> sort_dep_map;
        // Generate the constructors for the sorts on which the sort depends
        (coq_deps, seen_sorts') := <sortdecls-to-coq(|sort_decl_map, sort_dep_map)> (deps, [sort_name|seen_sorts], 0);
        // Only make a `| ` if the list of constructors is non-empty:
        (([] := coq_constrctors; decls := ListDecl(coq_constrctors))
          <+ decls := ListDeclBar(coq_constrctors));
        // Generate the constructors for the rest of the sort names
        (coq_inductives, seen_sorts'') := <sortdecls-to-coq(|sort_decl_map, sort_dep_map)> (sort_names, seen_sorts', w);
        // Wrap the result appropriately based on the (0|1) flag
        (!w; ?0 < (res := <concat> [[Induc(sort_name, None(), Type(), decls)], coq_deps, coq_inductives])
                + (res := [Inductive([Induc(sort_name, None(), Type(), decls)|coq_deps])|coq_inductives])
        )
      ) )

  sort-constructor-to-coq(|sort_name):
    (constructor_name, args) ->
      ConsDecl(constructor_name,
               None(),
               OptType(c))
    with
      args' := <map(sort-to-coq)> args;
      c := <foldr(!sort_name, mk-arrow)> args'

rules // Rule generation

  // The (0|1) for this relation is used to indicate whether we are generating a new inductive type (1) or not (0). 
  //   arrowdecls-to-coq \subseteq List(ArrowName) x List(ArrowName) x (0|1)
  //                               x List(Induc) x List(ArrowName)
  arrowdecls-to-coq(|arrow_decl_map, arrow_dep_map):
    (arrows, seen_arrows, w) -> (res, seen_arrows'')
    with
      // If the list of arrow names is empty, we are done generating arrow constructors 
      ( [] := arrows; res := []; seen_arrows'' := seen_arrows )
        <+ 
      [arrow_name|arrow_names] := arrows;
      // If the constructors for the current arrow has already been generated, don't generate it again.
      ( (<elem> (arrow_name, seen_arrows); 
        // Generate the constructors for the rest of the sort names
        (res, seen_arrows'') := <arrowdecls-to-coq(|arrow_decl_map, arrow_dep_map)> (arrow_names, seen_arrows, w) )
        <+
      // Otherwise, generate it
      ( (ruls, sig) := <hashtable-get(|arrow_name)> arrow_decl_map;
        // Generate its type signature
        coq_type_sig := <arrowsig-to-coq> sig;
        // Generate its constructors
        coq_ruls := <map(rule-to-coq(|arrow_name))> ruls;
        deps := <hashtable-get(|arrow_name)> arrow_dep_map;
        // Generate the constructors for the sorts on which the sort depends
        (coq_deps, seen_arrows') := <arrowdecls-to-coq(|arrow_decl_map, arrow_dep_map)> (deps, [arrow_name|seen_arrows], 0);
        // Only make a `| ` if the list of constructors is non-empty:
        (([] := coq_ruls; decls := ListDecl(coq_ruls))
          <+ decls := ListDeclBar(coq_ruls));
        // Generate the constructors for the rest of the sort names
        (coq_inductives, seen_arrows'') := <arrowdecls-to-coq(|arrow_decl_map, arrow_dep_map)> (arrow_names, seen_arrows', w);
        // Wrap the result appropriately based on the (0|1) flag
        (!w; ?0 < (res := <concat> [[Induc(arrow_name, None(), coq_type_sig, decls)], coq_deps, coq_inductives])
                + (res := [Inductive([Induc(arrow_name, None(), coq_type_sig, decls)|coq_deps])|coq_inductives])
        )
      ) )

  arrowsig-to-coq:
    (ro_ents, from_sort, from_rw_ents, to_sort, to_rw_ents) -> typ
    with
      // Collect read-only entity types, if any
      ((ArrowROs(ros) := ro_ents)
        <+ ros := []);
      // Collect readable read-write entity types, if any
      ((ArrowRWs(from_rws) := from_rw_ents)
        <+ from_rws := []); 
      // Collect written read-write entity types, if any
      ((ArrowRWs(to_rws) := to_rw_ents)
        <+ to_rws := []);
      pre_type := <concat> [ros, [from_sort], from_rws, [to_sort], to_rws];
      typ := <map(sort-to-coq); foldr(!Prop(), mk-arrow)> pre_type

  rule-to-coq(|rel_name):
    rule ->
      ConsDecl(ident_name,
               OptBinders(idents),
               OptType(rl))
    with
      (conc, prems) := <get-premises-and-conclusion> rule;
      // Rule name
      name := <extract-name-from-formula> conc;
      rname := <concat-strings> [rel_name, "_", name];
      ident_name := <newname> rname;
      // Variables
      pvars := <extract-variables> prems;
      svars := <extract-variables> conc;
      vars := <concat> [pvars, svars];
      idents := <map(mk-bind)> vars;
      // Conclusion
      c := <formula-to-coq> conc;
      // Premises
      ps := <map(formula-to-coq)> prems;
      rl := <foldr(!c, mk-arrowln)> ps // arrows nested to the right, with the conclusion as final element
  
  mk-arrowln:
    (x, y) -> ArrowLn(x, y)

  mk-arrow:
    (x, y) -> Arrow(x, y)
      
  mk-bind:
    s -> Bind(s)

rules // Formulae generation

  formula-to-coq:
    Formula(r) -> r'
    with
      r' := <formula-to-coq> r

  formula-to-coq:
    Relation(r,
             Source(sterm, rws),
             arrow, 
             Target(tterm, rws')) ->
      tt'
    with
      rel_name := <get-arrow-name> arrow;
      res0 := <aux-ent-to-coq> (rel_name, r);
      st := <term-to-coq> sterm;
      st' := <foldl(labelcomp-pair-to-coq; mk-app-rev)> (rws, Apply(res0, st));
      tt := <term-to-coq> tterm;
      tt' := <foldl(labelcomp-pair-to-coq; mk-app-rev)> (rws', Apply(st', tt))
      
rules // Auxiliary entity generation

  aux-ent-to-coq:
    (trm, NoReads()) -> trm

  aux-ent-to-coq:
    (trm, Reads(reads)) -> res
    with
      res := <foldl(labelcomp-pair-to-coq; mk-app-rev)> (reads, trm)

  labelcomp-pair-to-coq:
    (LabelComp(_, trm), rel_name) ->
      (res, rel_name)
    with
      res := <term-to-coq> trm

rules // Term generation

  term-to-coq:
    Con(c, ts) -> app
    with
      l := <length; int-to-string> ts;
      name := <concat-strings> [c, l];
      ts' := <map(term-to-coq)> ts;
      app := <foldl(mk-app-rev)> (ts', name) // application nested to the left

  term-to-coq:
    Map(bindings) -> map
    with
      bindings' := <map(term-to-coq)> bindings;
      nil := <coq-map-nil>;
      cons := <coq-map-cons>;
      map := <foldr(!nil, \ (x, y) -> Apply(Apply(cons, x), y) \ )> bindings'  
  
  term-to-coq:
    Bind(x, y) -> cons
    with
      x' := <term-to-coq> x;
      y' := <term-to-coq> y;
      cons := <coq-map-bind> (x', y')

  term-to-coq:
    MapSelect(m, t) -> Apply(Apply(ml, m'), t')
    with
      ml := <coq-map-lookup>;
      m' := <term-to-coq> m;
      t' := <term-to-coq> t

  term-to-coq:
    MapExtend(m1, m2) ->
      Apply(Apply(Apply(mu, m2'), x'), y')
    with
      ((Map([Bind(x, y)]) := m1) 
        <+ debug(!"Please use map updates of the form {x |--> y, m}. Other kinds of updates are currently not supported."); fail);
      mu := <coq-map-update>;
      m2' := <term-to-coq> m2;
      x' := <term-to-coq> x;
      y' := <term-to-coq> y

  mk-app-rev:
    (x, y) -> Apply(y, x)

  term-to-coq:
    VarRef(x) -> x

  term-to-coq:
    Var(x) -> x
  
//  term-to-coq:
//    MatchedVar(x) -> x

rules // Extracting the source constructor name

  extract-name-from-formula:
    Relation(_, Source(c, _), _, _) -> name
    with
      name := <extract-name-from-term> c

  extract-name-from-formula:
    Relation(_, Source(c), _, _) -> name
    with
      name := <extract-name-from-term> c

  extract-name-from-term:
    Con(name, _) -> name

rules // Extracting variables

  // Lists
  extract-variables:
    [] -> []
  
  extract-variables:
    [t|ts] -> zs
    with
      xs := <extract-variables> t;
      ys := <extract-variables> ts;
      zs := <concat> [xs, ys]
  
  // Formulas and relations
  extract-variables:
    Formula(r) -> xs
    with
      xs := <extract-variables> r
      
  extract-variables:
    Relation(reads, Source(s, writes), arrow, Target(t, writes')) -> xs
    with
      xs0 := <extract-variables> reads;
      xs1 := <extract-variables> s;
      xs2 := <extract-variables> writes;
      xs3 := <extract-variables> arrow;
      xs4 := <extract-variables> t;
      xs5 := <extract-variables> writes';
      xs := <concat> [xs0, xs1, xs2, xs3, xs4, xs5]
  
  extract-variables:
    Relation(reads, Source(s), arrow, Target(t)) -> xs
    with
      xs0 := <extract-variables> reads;
      xs1 := <extract-variables> s;
      xs3 := <extract-variables> arrow;
      xs4 := <extract-variables> t;
      xs := <concat> [xs0, xs1, xs3, xs4]
  
  // Reads
  extract-variables:
    Reads(rs) -> xs
    with
      xs := <extract-variables> rs
      
  extract-variables:
    NoReads() -> []

  // Arrows
  extract-variables:
    NamedDynamicEmitted(emitted, _, _) -> xs
    with
      xs := <extract-variables> emitted 
  
  extract-variables:
    NamedDynamic(_) -> []
  
  // Terms
  extract-variables:
    Var(x) -> [x]
  
  extract-variables:
    Con(_, ts) -> xs
    with
      xs := <extract-variables> ts

  extract-variables:
    VarRef(_) -> []
  
  // Labelled components
  extract-variables:
    LabelComp(_, c) -> xs
    with
      xs := <extract-variables> c
  
  // Maps
  extract-variables:
    Map(r) -> xs
    with
      xs := <extract-variables> r
  
  extract-variables:
    MapSelect(t1, t2) -> xs
    with
      xs1 := <extract-variables> t1;
      xs2 := <extract-variables> t2;
      xs := <concat> [xs1, xs2]
      
  extract-variables:
    MapExtend(m, t) -> xs
    with
      xs1 := <extract-variables> m;
      xs2 := <extract-variables> t;
      xs := <concat> [xs1, xs2]
      
  extract-variables:
    Bind(x, y) -> zs
    with
      xs := <extract-variables> x;
      ys := <extract-variables> y;
      zs := <concat> [xs, ys]
  
module coq-semantics/err-rules

imports
  coq-semantics/-
  signatures/-
  ds
  analysis/-
  ds2ds/explicate-arrow-types
  lib-ds

rules // Introduce timeout value as a constructor for all sorts
      
  mk-timeout-val(|sort_decls):
    sort -> Con(timeout_name', [])
    with
      sort_name := <get-sort-name> sort;
      suffix := <string-as-chars(\ [x|_] -> x' where x' := <upper-case-chars> [x] \)> sort_name;
      timeout_name := <conc-strings> ("Timeout", suffix);
      // Check if constructor name is already defined
      cnames := <get-all-constructor-names> sort_decls;
      if <elem> (timeout_name, cnames)
      then
        timeout_name' := <newname> timeout_name
      else
        timeout_name' := timeout_name
      end
    
rules // Introduce rules for propagating exceptions

  add-propagation-rules(mkerr|):
    arrow_decl_map -> 1
    with
      arrow_decl_keys := <hashtable-keys> arrow_decl_map;
      rules_ := <map({ rs', sig, rs'', key, to_sort:
                       ?key;
                       (rs', sig@(_, _, _, to_sort, _)) := <hashtable-get(|key)> arrow_decl_map;
                       err := <mkerr> to_sort;
                       rs'' := <map(add-propagation-to-rule(|err)); concat> rs';
                       <hashtable-put(|key, (rs'', sig))> arrow_decl_map })> arrow_decl_keys
  
  add-propagation-rules(mkerr|arrow_sigs):
    arrow_decl_map -> 1
    with
      arrow_decl_keys := <hashtable-keys> arrow_decl_map;
      rules_ := <map({ rs, rs', sig, key, to_sort, err:
                       ?key;
                       if <elem> (key, arrow_sigs)
                       then
                         (rs, sig@(_, _, _, to_sort, _)) := <hashtable-get(|key)> arrow_decl_map;
                         err := <mkerr> to_sort;
                         rs' := <map(add-propagation-to-rule(|err, arrow_sigs)); concat> rs;
                         <hashtable-put(|key, (rs', sig))> arrow_decl_map
                       end })> arrow_decl_keys
  
  add-propagation-to-rule(|err):
    Rule(prems, d, conc@Relation(_, _, _, Target(target, _))) ->
      rules'
    with
      rules' := <add-propagation-to-premises(|err, d, conc)> (prems, [], [])
  
  add-propagation-to-rule(|err, arrow_sigs):
    Rule(prems, d, conc@Relation(_, _, _, Target(target, _))) ->
      rules'
    with
      rules' := <add-propagation-to-premises(|err, arrow_sigs, d, conc)> (prems, [], [])

  add-propagation-to-premises(|err, d, conc):
    ([], seen_prems, rs) -> [Rule(seen_prems, d, conc)|rs]

  add-propagation-to-premises(|err, arrow_sigs, d, conc):
    ([], seen_prems, rs) -> [Rule(seen_prems, d, conc)|rs]
  
  // FIXME: Are rws always variables in premises? The following assumes they are
  add-propagation-to-premises(|err, d, conc):
    ([Formula(Relation(r, s, a, Target(target, rws)))|prems], seen_prems, rs) ->
      rs'
    where
      // If target is a variable, and this variable occurs in a
      // in tail position, wrong is automatically propagated.
      ( [] := prems;
        Var(x) := target;
        Relation(_, _, _, Target(VarRef(x), rws')) := conc;
        // Check that read-write components are either equal terms, or the same variable
        ( <equal> (rws, rws') <+
          (rws := <bottomup(try(\ VarRef(x) -> Var(x) \))> rws') ); 
        rs' := rs )
      <+
      // Otherwise, add a rule for propagating error
      ( prems' := <concat> [seen_prems, [Formula(Relation(r, s, a, Target(err, rws)))]];
        seen_prems' := <concat> [seen_prems, [Formula(Relation(r, s, a , Target(target, rws)))]];
        // If target of formula is a variable, check that the variable is not an error (otherwise the error rule should match)
        if ((VarRef(y) := target) <+ (Var(y) := target))
        then seen_prems'' := <concat> [seen_prems', [Formula(NMatch(VarRef(y), err))]]
        else seen_prems'' := seen_prems'
        end;
        Relation(cr, cs, ca, Target(_, crws)) := conc;
        rs' := <add-propagation-to-premises(|err, d, conc)> (prems, seen_prems'', [Rule(prems', d, Relation(cr, cs, ca, Target(err, crws)))|rs]) )
  
  add-propagation-to-premises(|d, conc):
    ([p|prems], seen_prems, rs) ->
      rs'
    where
      not(!p; ?Formula(Relation(_, _, _, _)));
      seen_prems' := <concat> [seen_prems, [p]]; 
      rs' := <add-propagation-to-premises(|d, conc)> (prems, seen_prems', rs)

  // FIXME: Are rws always variables in premises? The following assumes they are
  add-propagation-to-premises(|err, arrow_sigs, d, conc):
    ([Formula(Relation(r, s, a@NamedDynamicEmitted(_, arrow_name, src_sort), Target(target, rws)))|prems], seen_prems, rs) ->
      rs'
    where
      // If target is a variable, and this variable occurs in a
      // in tail position, error is automatically propagated.
      ( [] := prems;
        Var(x) := target;
        Relation(_, _, _, Target(VarRef(x), rws')) := conc;
        // Check that read-write components are either equal terms, or the same variable
        ( <equal> (rws, rws') <+
          (rws := <bottomup(try(\ VarRef(x) -> Var(x) \))> rws') );
        rs' := [Rule(seen_prems, d, conc)|rs] )
      <+
      // Otherwise, if the relation signature is in arrow_sigs, add a rule for propagating error
      ( !((arrow_name, src_sort), arrow_sigs);
        <elem> ((arrow_name, src_sort), arrow_sigs);
        prems' := <concat> [seen_prems, [Formula(Relation(r, s, a, Target(err, rws)))]];
        seen_prems' := <concat> [seen_prems, [Formula(Relation(r, s, a , Target(target, rws)))]];
        // If target of formula is a variable, check that the variable is not an error (otherwise the error rule should match)
        if ((VarRef(y) := target) <+ (Var(y) := target))
        then seen_prems'' := <concat> [seen_prems', [Formula(NMatch(VarRef(y), err))]]
        else seen_prems'' := seen_prems'
        end;
        Relation(cr, cs, ca, Target(_, crws)) := conc;
        rs' := <add-propagation-to-premises(|err, arrow_sigs, d, conc)> (prems, seen_prems'', [Rule(prems', d, Relation(cr, cs, ca, Target(err, crws)))|rs]) )
  
  add-propagation-to-premises(|err, arrow_sigs, d, conc):
    ([p|prems], seen_prems, rs) ->
      rs'
    where
      not(!p; ?Formula(Relation(r, s, a@NamedDynamicEmitted(_, arrow_name, src_sort), Target(target, rws))); <elem> ((arrow_name, src_sort), arrow_sigs));
      seen_prems' := <concat> [seen_prems, [p]]; 
      rs' := <add-propagation-to-premises(|err, arrow_sigs, d, conc)> (prems, seen_prems', rs)

rules // Utilities for sort declarations

  get-all-constructor-names:
    sort_decls -> cnames
    with
      cnames := <hashtable-keys;
                 map({ key : ?key; <hashtable-get(|key)> sort_decls; map(\ (cname, _) -> cname \) });
                 concat> sort_decls

rules // Analyze totality of premises

rules // Introduce "wrong" transitions for non-total premises
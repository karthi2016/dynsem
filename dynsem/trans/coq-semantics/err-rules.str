module coq-semantics/err-rules

imports
  coq-semantics/-
  signatures/-
  ds
  analysis/-
  ds2ds/explicate-arrow-types
  lib-ds

rules // Introduce wrong value as a constructor for all sorts

//  add-err-constructors(|err_prefix):
//    (sort_decl_map, arrow_decl_map) -> 1
//    with
//      arrow_decl_keys := <hashtable-keys> arrow_decl_map;
//      // For each sort that is used in a result position,
//      result_sorts := <map({ to_sort, key: ?key;
//                             (_, (_, _, _, to_sort, _)) := <hashtable-get(|key)> arrow_decl_map;
//                             !to_sort });
//                       nub> arrow_decl_keys;
//      // Add an error constructor for [errname]
//      <map({ sort_name, constructors_ : ?SimpleSort(sort_name);
//             constructors_ := <hashtable-get(|sort_name)> sort_decl_map;
//             err_name := 
//             <hashtable-put(|sort_name, [(errname, [])|constructors_])> sort_decl_map })> result_sorts
//   
  add-err-constructors(|errname, arrow_sigs):
    (sort_decl_map, arrow_decl_map) -> 1
    with
      arrow_decl_keys := <hashtable-keys> arrow_decl_map;
      // For each sort that is used in a result position of an arrow in the arrow_sigs list 
      result_sorts := <filter({ name, sort :
                                  ?(name, sort);
                                  <elem> ((name, sort), arrow_sigs) }); concat;
                       map({ to_sort, name, sort: ?(name, sort);
                             (_, (_, _, _, to_sort, _)) := <hashtable-get(|(name, sort))> arrow_decl_map;
                             !to_sort });
                       nub> arrow_decl_keys;
      // Add an error constructor for [errname]
      <map({ sort_name, constructors_ : ?SimpleSort(sort_name);
             constructors_ := <hashtable-get(|sort_name)> sort_decl_map;
             <hashtable-put(|sort_name, [(errname, [])|constructors_])> sort_decl_map })> result_sorts
  
  // FIXME: Each sort needs a different constructor name
  mk-wrong-val(|sort_decls):
    sort -> Con(wrong_name', [])
    with
      sort_name := <get-sort-name> sort;
      suffix := <string-as-chars(\ [x|_] -> x' where [x'] := <upper-case-chars> [x] \)> sort_name;
      wrong_name := <conc-strings> ("Wrong", suffix);
      // Check if constructor name is already defined
      cnames := <get-all-constructor-names> sort_decls;
      if <elem> (wrong_name, cnames)
      then
        wrong_name' := <newname> wrong_name
      else
        wrong_name' := wrong_name
      end

  mk-timeout-val:
    sort -> Con(timeout_name, [])
    with
      sort_name := <get-sort-name> sort;
      suffix := <string-as-chars(\ [x|_] -> x' where x' := <upper-case-chars> [x] \)> sort_name;
      timeout_name := <conc-strings> ("Timeout", suffix)
    
  mk-timeout-val(|sort_decls):
    sort -> Con(timeout_name', [])
    with
      sort_name := <get-sort-name> sort;
      suffix := <string-as-chars(\ [x|_] -> x' where x' := <upper-case-chars> [x] \)> sort_name;
      timeout_name := <conc-strings> ("Timeout", suffix);
      // Check if constructor name is already defined
      cnames := <get-all-constructor-names> sort_decls;
      if <elem> (timeout_name, cnames)
      then
        timeout_name' := <newname> timeout_name
      else
        timeout_name' := timeout_name
      end
  
    
rules // Introduce rules for propagating exceptions

  add-propagation-rules(mkerr|):
    arrow_decl_map -> 1
    with
      arrow_decl_keys := <hashtable-keys> arrow_decl_map;
      rules_ := <map({ rs', sig, rs'', key, to_sort:
                       ?key;
                       (rs', sig@(_, _, _, to_sort, _)) := <hashtable-get(|key)> arrow_decl_map;
                       err := <mkerr> to_sort;
                       rs'' := <map(add-propagation-to-rule(|err)); concat> rs';
                       <hashtable-put(|key, (rs'', sig))> arrow_decl_map })> arrow_decl_keys
  
  add-propagation-rules(mkerr|arrow_sigs):
    arrow_decl_map -> 1
    with
      arrow_decl_keys := <hashtable-keys> arrow_decl_map;
      rules_ := <map({ rs, rs', sig, key, to_sort:
                       ?key;
                       (rs, sig@(_, _, _, to_sort, _)) := <hashtable-get(|key)> arrow_decl_map;
                       err := <mkerr> to_sort;
                       rs' := <map(add-propagation-to-rule(|err, arrow_sigs)); concat> rs;
                       <hashtable-put(|key, (rs', sig))> arrow_decl_map })> arrow_decl_keys
  
  add-propagation-to-rule(|err):
    Rule(prems, d, conc@Relation(_, _, _, Target(target, _))) ->
      rules'
    with
      rules' := <add-propagation-to-premises(|err, d, conc)> (prems, [], [])
  
  add-propagation-to-rule(|err, arrow_sigs):
    Rule(prems, d, conc@Relation(_, _, _, Target(target, _))) ->
      rules'
    with
      rules' := <add-propagation-to-premises(|err, arrow_sigs, d, conc)> (prems, [], [])

  add-propagation-to-premises(|err, d, conc):
    ([], seen_prems, rs) -> [Rule(seen_prems, d, conc)|rs]

  add-propagation-to-premises(|err, arrow_sigs, d, conc):
    ([], seen_prems, rs) -> [Rule(seen_prems, d, conc)|rs]
  
  // FIXME: Are rws always variables in premises? The following assumes they are
  add-propagation-to-premises(|err, d, conc):
    ([Formula(Relation(r, s, a, Target(target, rws)))|prems], seen_prems, rs) ->
      rs'
    where
      // If target is a variable, and this variable occurs in a
      // in tail position, wrong is automatically propagated.
      ( [] := prems;
        Var(x) := target;
        Relation(_, _, _, Target(VarRef(x), _)) := conc; // FIXME: rws should match
        rs' := rs )
      <+
      // Otherwise, add a rule for propagating error
      ( prems' := <concat> [seen_prems, [Formula(Relation(r, s, a, Target(err, rws)))]];
        seen_prems' := <concat> [seen_prems, [Formula(Relation(r, s, a , Target(target, rws)))]];
        // If target of formula is a variable, check that the variable is not an error (otherwise the error rule should match)
        if ((VarRef(y) := target) <+ (Var(y) := target))
        then seen_prems'' := <concat> [seen_prems', [Formula(NMatch(VarRef(y), err))]]
        else seen_prems'' := seen_prems'
        end;
        Relation(cr, cs, ca, Target(_, crws)) := conc;
        rs' := <add-propagation-to-premises(|err, d, conc)> (prems, seen_prems'', [Rule(prems', d, Relation(cr, cs, ca, Target(err, crws)))|rs]) )
  
  add-propagation-to-premises(|d, conc):
    ([p|prems], seen_prems, rs) ->
      rs'
    where
      not(!p; ?Formula(Relation(_, _, _, _)));
      seen_prems' := <concat> [seen_prems, [p]]; 
      rs' := <add-propagation-to-premises(|d, conc)> (prems, seen_prems', rs)

  // FIXME: Are rws always variables in premises? The following assumes they are
  add-propagation-to-premises(|err, arrow_sigs, d, conc):
    ([Formula(Relation(r, s, a@NamedDynamicEmitted(_, arrow_name, src_sort), Target(target, rws)))|prems], seen_prems, rs) ->
      rs'
    where
      // If target is a variable, and this variable occurs in a
      // in tail position, error is automatically propagated.
      ( [] := prems;
        Var(x) := target;
        Relation(_, _, _, Target(VarRef(x), _)) := conc; // FIXME: rws should match
        rs' := [Rule(seen_prems, d, conc)|rs] )
      <+
      // Otherwise, if the relation signature is in arrow_sigs, add a rule for propagating error
      ( !((arrow_name, src_sort), arrow_sigs);
        <elem> ((arrow_name, src_sort), arrow_sigs);
        prems' := <concat> [seen_prems, [Formula(Relation(r, s, a, Target(err, rws)))]];
        seen_prems' := <concat> [seen_prems, [Formula(Relation(r, s, a , Target(target, rws)))]];
        // If target of formula is a variable, check that the variable is not an error (otherwise the error rule should match)
        if ((VarRef(y) := target) <+ (Var(y) := target))
        then seen_prems'' := <concat> [seen_prems', [Formula(NMatch(VarRef(y), err))]]
        else seen_prems'' := seen_prems'
        end;
        Relation(cr, cs, ca, Target(_, crws)) := conc;
        rs' := <add-propagation-to-premises(|err, arrow_sigs, d, conc)> (prems, seen_prems'', [Rule(prems', d, Relation(cr, cs, ca, Target(err, crws)))|rs]) )
  
  add-propagation-to-premises(|err, arrow_sigs, d, conc):
    ([p|prems], seen_prems, rs) ->
      rs'
    where
      not(!p; ?Formula(Relation(r, s, a@NamedDynamicEmitted(_, arrow_name, src_sort), Target(target, rws))); <elem> ((arrow_name, src_sort), arrow_sigs));
      seen_prems' := <concat> [seen_prems, [p]]; 
      rs' := <add-propagation-to-premises(|err, arrow_sigs, d, conc)> (prems, seen_prems', rs)

rules // Utilities for sort declarations

  get-all-constructor-names:
    sort_decls -> cnames
    with
      cnames := <hashtable-keys;
                 map({ key : ?key; <hashtable-get(|key)> sort_decls; map(\ (cname, _) -> cname \) });
                 concat> sort_decls

rules // Analyze totality of premises

rules // Introduce "wrong" transitions for non-total premises
module coq-semantics/err-rules

imports
  coq-semantics/-
  signatures/-
  ds
  analysis/-
  ds2ds/explicate-arrow-types

rules // Introduce wrong value as a constructor for all sorts

  add-err-constructors(|errname):
    (sort_decl_map, arrow_decl_map) -> 1
    with
      arrow_decl_keys := <hashtable-keys> arrow_decl_map;
      // For each sort that is used in a result position,
      result_sorts := <map({ to_sort, key: ?key;
                             (_, (_, _, _, to_sort, _)) := <hashtable-get(|key)> arrow_decl_map;
                             !to_sort });
                       nub> arrow_decl_keys;
      // Add an error constructor for [errname]
      <map({ sort_name, constructors_ : ?SimpleSort(sort_name);
             constructors_ := <hashtable-get(|sort_name)> sort_decl_map;
             <hashtable-put(|sort_name, [(errname, [])|constructors_])> sort_decl_map })> result_sorts
   
  add-err-constructors(|errname, arrow_sigs):
    (sort_decl_map, arrow_decl_map) -> 1
    with
      arrow_decl_keys := <hashtable-keys> arrow_decl_map;
      // For each sort that is used in a result position of an arrow in the arrow_sigs list 
      result_sorts := <filter({ name, sort :
                                  ?(name, SimpleSort(sort));
                                  <elem> ((name, sort), arrow_sigs) }); concat;
                       map({ to_sort, name, sort: ?(name, sort);
                             (_, (_, _, _, to_sort, _)) := <hashtable-get(|(name, SimpleSort(sort)))> arrow_decl_map;
                             !to_sort });
                       nub> arrow_decl_keys;
      // Add an error constructor for [errname]
      <map({ sort_name, constructors_ : ?SimpleSort(sort_name);
             constructors_ := <hashtable-get(|sort_name)> sort_decl_map;
             <hashtable-put(|sort_name, [(errname, [])|constructors_])> sort_decl_map })> result_sorts
  
  // FIXME: Each sort needs a different constructor name
  mk-wrong-val:
    sort_name -> Con("Wrong", [])

  mk-timeout-val:
    sort_name -> Con("Timeout", [])
    
rules // Introduce rules for propagating exceptions

  add-propagation-rules(mkerr|):
    arrow_decl_map -> 1
    with
      arrow_decl_keys := <hashtable-keys> arrow_decl_map;
      rules_ := <map({ rs', sig, rs'', key:
                       ?key;
                       (rs', sig) := <hashtable-get(|key)> arrow_decl_map;
                       err := <mkerr> ""; // FIXME
                       rs'' := <map(add-propagation-to-rule(|err)); concat> rs';
                       <hashtable-put(|key, (rs'', sig))> arrow_decl_map })> arrow_decl_keys
  
  add-propagation-rules(mkerr|arrow_sigs):
    arrow_decl_map -> 1
    with
      arrow_decl_keys := <hashtable-keys> arrow_decl_map;
      rules_ := <map({ rs, rs', sig, key:
                       ?key;
                       (rs, sig) := <hashtable-get(|key)> arrow_decl_map;
                       err := <mkerr> ""; // FIXME
                       rs' := <map(add-propagation-to-rule(|err, arrow_sigs)); concat> rs;
                       <hashtable-put(|key, (rs', sig))> arrow_decl_map })> arrow_decl_keys
  
  add-propagation-to-rule(|err):
    Rule(prems, d, conc@Relation(_, _, _, Target(target, _))) ->
      rules'
    with
      rules' := <add-propagation-to-premises(|err, d, conc)> (prems, [], [])
  
  add-propagation-to-rule(|err, arrow_sigs):
    Rule(prems, d, conc@Relation(_, _, _, Target(target, _))) ->
      rules'
    with
      rules' := <add-propagation-to-premises(|err, arrow_sigs, d, conc)> (prems, [], [])

  add-propagation-to-premises(|err, d, conc):
    ([], seen_prems, rs) -> [Rule(seen_prems, d, conc)|rs]

  add-propagation-to-premises(|err, arrow_sigs, d, conc):
    ([], seen_prems, rs) -> [Rule(seen_prems, d, conc)|rs]
  
  // FIXME: Are rws always variables in premises? The following assumes they are
  add-propagation-to-premises(|err, d, conc):
    ([Formula(Relation(r, s, a, Target(target, rws)))|prems], seen_prems, rs) ->
      rs'
    where
      // If target is a variable, and this variable occurs in a
      // in tail position, wrong is automatically propagated.
      ( [] := prems;
        Var(x) := target;
        Relation(_, _, _, Target(VarRef(x), _)) := conc; // FIXME: rws should match
        rs' := rs )
      <+
      // Otherwise, add a rule for propagating error
      ( prems' := <concat> [seen_prems, [Formula(Relation(r, s, a, Target(err, rws)))]];
        seen_prems' := <concat> [seen_prems, [Formula(Relation(r, s, a , Target(target, rws)))]];
        // If target of formula is a variable, check that the variable is not an error (otherwise the error rule should match)
        if ((VarRef(y) := target) <+ (Var(y) := target))
        then seen_prems'' := <concat> [seen_prems', [Formula(NMatch(VarRef(y), err))]]
        else seen_prems'' := seen_prems'
        end;
        Relation(cr, cs, ca, Target(_, crws)) := conc;
        rs' := <add-propagation-to-premises(|err, d, conc)> (prems, seen_prems'', [Rule(prems', d, Relation(cr, cs, ca, Target(err, crws)))|rs]) )
  
  add-propagation-to-premises(|d, conc):
    ([p|prems], seen_prems, rs) ->
      rs'
    where
      not(!p; ?Formula(Relation(_, _, _, _)));
      seen_prems' := <concat> [seen_prems, [p]]; 
      rs' := <add-propagation-to-premises(|d, conc)> (prems, seen_prems', rs)

  // FIXME: Are rws always variables in premises? The following assumes they are
  add-propagation-to-premises(|err, arrow_sigs, d, conc):
    ([Formula(Relation(r, s, a@NamedDynamicEmitted(_, arrow_name, SimpleSort(src_sort)), Target(target, rws)))|prems], seen_prems, rs) ->
      rs'
    where
      // If target is a variable, and this variable occurs in a
      // in tail position, error is automatically propagated.
      ( [] := prems;
        Var(x) := target;
        Relation(_, _, _, Target(VarRef(x), _)) := conc; // FIXME: rws should match
        rs' := [Rule(seen_prems, d, conc)|rs] )
      <+
      // Otherwise, if the relation signature is in arrow_sigs, add a rule for propagating error
      ( !((arrow_name, src_sort), arrow_sigs);
        <elem> ((arrow_name, src_sort), arrow_sigs);
        prems' := <concat> [seen_prems, [Formula(Relation(r, s, a, Target(err, rws)))]];
        seen_prems' := <concat> [seen_prems, [Formula(Relation(r, s, a , Target(target, rws)))]];
        // If target of formula is a variable, check that the variable is not an error (otherwise the error rule should match)
        if ((VarRef(y) := target) <+ (Var(y) := target))
        then seen_prems'' := <concat> [seen_prems', [Formula(NMatch(VarRef(y), err))]]
        else seen_prems'' := seen_prems'
        end;
        Relation(cr, cs, ca, Target(_, crws)) := conc;
        rs' := <add-propagation-to-premises(|err, arrow_sigs, d, conc)> (prems, seen_prems'', [Rule(prems', d, Relation(cr, cs, ca, Target(err, crws)))|rs]) )
  
  add-propagation-to-premises(|err, arrow_sigs, d, conc):
    ([p|prems], seen_prems, rs) ->
      rs'
    where
      not(!p; ?Formula(Relation(r, s, a@NamedDynamicEmitted(_, arrow_name, SimpleSort(src_sort)), Target(target, rws))); <elem> ((arrow_name, src_sort), arrow_sigs));
      seen_prems' := <concat> [seen_prems, [p]]; 
      rs' := <add-propagation-to-premises(|err, arrow_sigs, d, conc)> (prems, seen_prems', rs)
      
rules // Analyze totality of premises

rules // Introduce "wrong" transitions for non-total premises
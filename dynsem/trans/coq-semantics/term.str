module coq-semantics/term

imports
  libstratego-gpp
  coq-semantics/-
  lib/runtime/index/-
  lib/runtime/nabl/-
  lib/runtime/properties/-
  lib/runtime/task/-
  names
  lib/editor-common.generated
  include/ds
  lib/Coq/signatures/-
  lib/Coq/Coq-parenthesize
  lib/Coq/pp/-
  src-gen/signatures/ds-sig
  
rules // Sources and targets
	
  src-dst-to-coq(|i) = ?Source(<id>); term-to-coq(|i)
	src-dst-to-coq(|i) = ?Source(x, lbl); !x; term-to-coq(|i)
  src-dst-to-coq(|i) = ?Target(<id>); term-to-coq(|i)
  src-dst-to-coq(|i) = ?Target(x, lbl); !x; term-to-coq(|i)
  
rules // Terms
	
	term-to-coq(|i):
		Con(ident, t*) -> (T|[Co ident_x term_t term_k]|, b*, i')
		where not("I" := ident)
		where not("C" := ident)
		where not("T" := ident)
		with
		  term_k               := $[k[i]]
		; sig*                 := <get-sig; reverse> ident
	  ;	(term_t, bt*, i', _) := <foldr(!(List([]), [], <inc> i, sig*), fold-con)> t*
	  ; b*                   := [Bind(term_k), bt*]
	  ; ident_x              := $[[ident]C]
	
	term-to-coq(|i):
	  Con("T", [e1, e2]) -> (T|[(term_e1, term_e2)]|, b*, i2)
    with
      (term_e1, b1*, i1) := <term-to-coq(|i)> e1
    ; (term_e2, b2*, i2) := <term-to-coq(|i1)> e2
    ; b*                 := [b1*, b2*]
	
	term-to-coq(|i):
	  Con("C", [e1, e2, env]) -> (T|[Clos term_e1 term_e2 term_env']|, b*, i')
	  where
	    (term_e1, b1*, i1)   := <term-to-coq(|i)> e1
    ; (term_e2, b2*, i2)   := <term-to-coq(|i1)> e2
    ; (term_env', be*, i') := <term-to-coq(|i2)> env
    ; b*                   := [b1*, b2*, be*]
	
  term-to-coq(|i):
    Var(x) -> (Ref(x), [Bind(x)], i)

  term-to-coq(|i):
    VarRef(x) -> (Ref(x), [Bind(x)], i)
    
	term-to-coq(|i): // TODO: Generalize the map below, but needs model support first
	  MapExtend(Map([Bind(Var(identx), e)]), Var(identenv)) -> (T|[env_extend identenv identx terme]|, binds*, i')
	  where
	    (terme, be*, i') := <term-to-coq(|i)> e
	  ; binds*           := [Bind(identenv), Bind(identx), be*]

rules // Static definitions, hardcoded for now
	term-to-coq(|i): Con("I", [Var(ident_x)])                                -> (T|[Natval ident_x]| , [Bind(ident_x)], i)
	term-to-coq(|i): Int(n)                                                  -> (n, [], i)
	term-to-coq(|i): Con("I", [Con("addInt", [Var(ident_x), Var(ident_y)])]) -> (T|[plus ident_x ident_y]| , [Bind(ident_x), Bind(ident_y)], i)
  term-to-coq(|i): Con("I", [Con("subInt", [Var(ident_x), Var(ident_y)])]) -> (T|[minus ident_x ident_y]|, [Bind(ident_x), Bind(ident_y)], i)
  term-to-coq(|i): Con("I", [Con("mulInt", [Var(ident_x), Var(ident_y)])]) -> (T|[mult ident_x ident_y]| , [Bind(ident_x), Bind(ident_y)], i)

rules // Checking for known literals
  // Two cases interest us: INTCs and Ids
  arg-to-coq(|i, const):
    Var(identx) -> (T|[Id identx identk]|, bind*, <inc> i)
    where "String" := const
    with
      identk := $[k[i]]
    ; bind*  := [Bind(identx), Bind(identk)]
    
  arg-to-coq(|i, const):
    Var(identx) -> (T|[Co (INTC identx) [] identk]|, bind*, <inc> i)
    where "Int" := const
    with
      identk := $[k[i]]
    ; bind*  := [Bind(identx), Bind(identk)]
    
  arg-to-coq(|i, const):
    x -> <term-to-coq(|i)> x
    where not ("String" := const)
    where not ("Int" := const)

rules // Fold rules
  fold-con:
  	(x, (List(tl*), b*, i, [s | ss])) -> (List([x' | tl*]), b'*, i', ss)
  	with
  	  (x', bx*, i') := <arg-to-coq(|i, s)> x
  	; b'*           := <union> (bx*, b*)
module coq-semantics/main

imports
  libstratego-gpp
  coq-semantics/-
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/index/-
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/nabl/-
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/properties/-
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/task/-
  names
  mark-references
  lib/editor-common.generated
  include/ds
  ds
  sugar
  lib/Coq/signatures/-
  lib/Coq/Coq-parenthesize
  lib/Coq/pp/-

rules
  
  generate-coq:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      task-setup(|project-path)
    ; filename := "src-gen/verification/semantics.v"
    ; coq-file := <desugar-top; make-vars; module-to-coq(|"semantics")> ast
    with
       result := <parenthesize-Coq; prettyprintCoq-CoqFile; box2text-string(|100)> coq-file
    <+ <bottomup(try(not(is-string) ; not(is-list) ; not(prettyprintCoq-example) ; debug(!"cannot pp ")))> coq-file
    ;  result := ""

rules
  
  module-to-coq(|language):
  	Module(name, rule*) -> <build-module(|language)> S|[Inductive semantics_cbn : Env -> term -> value -> Prop := decls.]|
		where
		  rule'* := <filter(?Rules(<id>)); concat> rule*
		; sig*   := <make-sig-mapping> rule*
		; rules(get-sig: x -> <lookup> (x,sig*))
		; decls  := <rules-to-coq; !ListDeclBar(<id>)> rule'*

rules

  make-sig-mapping = filter(?Signatures(<id>)); concat
                   ; filter(?Constructors(<id>)); concat
                   ; map(cons-to-tuple); remove-all(default-sigs)
                     
  default-sigs = ?"E" <+ ?"C" <+ ?"I" <+ ?"T"
  
  cons-to-tuple:
    ConsDecl(ident,argsort*,_) -> (ident,arg*)
    where arg* := <map(?SimpleSort(<id>) <+ id)> argsort*

rules
  
  rules-to-coq = rules-to-coq(|[])
  
  rules-to-coq(|n*):
    [] -> []
    
  rules-to-coq(|n*):
    [x | xs] -> [r | rs]
    where (r, m*) := <rule-to-coq(|n*)> x
        ; rs := <rules-to-coq(|m*)> xs
  
  rule-to-coq(|n*):
    Rule(prem*, _, conclusion) -> (D|[identname optBinders' optType']|, [(name, count), n*])
    where
      (concl, cb*, i) := <formula-to-coq(|0)> conclusion
    ; (termty, bind*) := <premisses-to-coq(|i, (concl, cb*))> prem*
    ; optType'        := OptType(T|[termty]|)
    ; optBinders'     := OptBinders(<nub> bind*)
    ; name            := <relation-to-name> conclusion
    ; count           := <lookup; inc <+ !0> (name, n*) // Increases the count for a particular constructor, in case there are several.
    ; identname       := $[[name][count]C_sem]
  
rules // Fold rules
  
  premisses-to-coq(|i,ret):
    [p | ps] -> (T|[termp -> termps]|, [b*, bs*])
    where
      (termp, b*, i') := <formula-to-coq(|i)> p
    ; (termps, bs*)   := <premisses-to-coq(|i', ret)> ps
    
  premisses-to-coq(|i,ret):
    [] -> ret
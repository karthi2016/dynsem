module coq-semantics/main

imports
  libstratego-gpp
  coq-semantics/-
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/index/-
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/nabl/-
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/properties/-
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/task/-
  names
  mark-references
  lib/editor-common.generated
  include/ds
  ds
  lib/Coq/signatures/-
  lib/Coq/Coq-parenthesize
  lib/Coq/pp/-

rules
  
  generate-coq:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      task-setup(|project-path)
    ; filename := "src-gen/verification/semantics.v"
    ; coq-file := <strip-annos; make-vars; module-to-coq(|"semantics")> ast
    with
       result := <parenthesize-Coq; prettyprintCoq-CoqFile; box2text-string(|100)> coq-file
    <+ <bottomup(try(not(is-string) ; not(is-list) ; not(prettyprintCoq-example) ; debug(!"cannot pp ")))> coq-file
    ;  result := ""

rules
  
  module-to-coq(|language):
  	Module(name, rule*) -> <build-module(|language)> S|[Inductive semantics_cbn : Env -> term -> value -> Prop := decls.]|
		where
		  rule'* := <filter(?Rules(<id>)); concat> rule*
		; decls  := <foldl(fold-rule); Fst; reverse; !ListDeclBar(<id>)> (rule'*, ([], []))

rules
  
  rule-to-coq(|n*):
    Rule(prem*, _, formula) -> (D|[ident_name optBinders' optType']|, [(name, count), n*])
    where
      (term_ret, f-bind*, i) := <formula-to-coq(|0); debug(!"Ret: ")> formula
    ; (term_ty, p-bind*, _)  := <foldl(fold-prem); debug(!"Type: ")> (<reverse> prem*, (term_ret, f-bind*, i))
    ; optType'               := OptType(T|[term_ty]|)
    ; name                   := <formula-to-name> formula
    ; count                  := <lookup; inc <+ !0> (name, n*)
    ; ident_name             := $[[name][count]C_sem]
    ; optBinders'            := OptBinders(p-bind*)
  
rules // Fold rules
  
  fold-rule:
    (r, (p*, n*)) -> (p'*, n'*)
    where
      (p'*, n'*) := <rule-to-coq(|n*) < !([<Fst> | p*], <Snd>) + !(p*, n*)> r
  
  fold-prem:
    (Formula(p), (term_ps, b*, i)) -> (T|[term_p -> term_ps]|, <union> (b*, b'*), i')
    where
      (term_p, b'*, i') := <debug(!"Formula: "); formula-to-coq(|i)> p
  
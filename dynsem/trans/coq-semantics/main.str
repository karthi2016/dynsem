module coq-semantics/main

imports
  libstratego-gpp
  coq-semantics/-
  stratego/metaborg
  ds
  signatures/-
  coq-signatures/-
  coq-signatures/extensions/-
  coq-signatures/tactic/-
  coq-pp/-

rules
  
  generate-coq:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"v")> path
      ; coq-file := <strip-annos; module-to-coq> ast
    with
       result := <parenthesize-Coq; prettyprint-Coq; box2text-string(|100)> coq-file
    <+ <bottomup(try(not(is-string) ; not(is-list) ; not(prettyprint-Coq) ; debug(!"cannot pp ")))> coq-file
    ;  result := ""

rules

  module-to-coq:
    Module(name, [sigs, Rules(rs)]) -> |[Inductive semantics_cbn : Env -> term -> value -> Prop := decls.]|
    where
      decls0 := <map(say(id); rs-to-coq)> rs;
      decls := ListDeclBar(decls0);
      say(id)
  
  rs-to-coq:
    Rule(prems, _, 
         Relation(Reads(_), 
                  Source(sterm, _),
                  _,
                  Target(tterm, _))) -> ConsDecl(ident_name, OptBinders(idents), None())
    where
      say(id);
      name := <extract-name-from-term> sterm;
      rname := <concat-strings> ["Eval_", name];
      ident_name := <newname> rname;
      svars := <extract-variables> sterm;
//      tvars := <extract-variables> tterm;
//      vars := <concat> [svars];
      idents := <map(coqbind-helper)> svars
  
  coqbind-helper:
    s -> Bind(s)
    where
      say(id)
    
  extract-name-from-term:
    Con(name, _) -> name
    
  extract-variables:
    Var(x) -> [x]
  
  extract-variables:
    Con(_, ts) -> vs
    where
      vs := <foldr(![], extract-variables-fold-helper)> ts

  extract-variables-fold-helper:
    (t, vs_so_far) -> vs0 
    where
      tvars := <extract-variables> t;
      vs0 := <concat> [tvars, vs_so_far]

//rules
//  
//  rule-to-coq(|n*):
//    RuleW(formula, prem*) -> (ConsDecl(name', <union> (p-bind*, f-bind*), type), [(name, count), n*])
//    where
//      (prem'*, p-bind*, i) := <foldl(fold-prem)> (prem*, ([], [], 0))
//    ; (t', f-bind*, _)     := <formula-to-coq(|i)> formula
//    ; type                 := <foldl(fold-type)> (prem'*, t')
//    ; name                 := <formula-to-name> formula
//    ; count                := <lookup; inc <+ !0> (name, n*)
//    ; name'                := $[[name][count]C_sem]
//  
//  rule-to-coq(|n*):
//  	Rule(prem*,_,formula) -> <rule-to-coq(|n*)> RuleW(formula, prem*)
//  	
//  rule-to-coq(|n*):
//    Axiom(formula) -> <rule-to-coq(|n*)> RuleW(formula, [])
//
//rules // Fold rules
//  
//  fold-rule:
//    (r, (p*, n*)) -> (p'*, n'*)
//    where
//      (p'*, n'*) := <rule-to-coq(|n*) < !([<Fst> | p*], <Snd>) + !(p*, n*)> r
//  
//  fold-prem:
//    (Formula(p), (p*, b*, i)) -> ([p' | p*], <union> (b*, b'*), i')
//    where
//      (p', b'*, i') := <formula-to-coq(|i)> p
//  
//  fold-type: // Composes parts of a type
//    (x, y) -> T|[x -> y]|

module coq-semantics/main

imports
  libstratego-gpp
  coq-semantics/-
  stratego/metaborg
  ds
  signatures/-
  coq-signatures/-
  coq-signatures/extensions/-
  coq-signatures/tactic/-
  coq-pp/-
  ds2ds/-
  analysis/-
  outline
  lib-ds
  backend/interpreter/utils
   
rules
  
  explicate-for-coq(|path, project-path) =
    in-project-path(
      ds-to-interp-init-options(|path, project-path);
      include-imports;
      desugar-top;
      fuse-sections;
      desugar-varschemes-module;
      add-extra-typeannos-module;
      desugar-aliases-module;
      factorize-module;
      expand-implicits-module;
      factorize-module;
      explicate-module;
      copy-propagation-module;
      constant-propagation-module;
      defactorize-module
    |project-path)
  
  generate-coq:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"v")> path
      ; coq-file := <explicate-for-coq(|path, project-path); m-in-analysis(debug(!0); module-to-coq; debug(!"done"))> ast
    with
       result := <parenthesize-Coq; prettyprint-Coq; box2text-string(|100)> coq-file
    <+ <bottomup(try(not(is-string) ; not(is-list) ; not(prettyprint-Coq) ; debug(!"cannot pp ")))> coq-file
    ;  result := ""

rules // Module generation

  module-to-coq:
    mod -> defs
    with
      (sort_decl_map, arrow_decl_map, sort_dep_map, arrow_dep_map) := <pre-process-module> mod;
      
      sort_decl_names := <hashtable-keys> sort_decl_map;
      coq_cs := <map(sortdecl-to-coq(|sort_decl_map, sort_dep_map))> sort_decl_names;
      
      arrow_decl_names := <hashtable-keys> arrow_decl_map;
      // generate rules for all relations
      coq_rs := <map(rules-to-coq(|arrow_decl_map))> arrow_decl_names;
      
      defs := <concat> [coq_cs, coq_rs]

rules // Sort-to-type generation

  sort-to-coq:
    SimpleSort(x) -> x

  sort-to-coq:
    MapSort(x, y) -> Apply(Apply(maptype, x'), y')
    with
      maptype := <coq-map-type>;
      x' := <sort-to-coq> x;
      y' := <sort-to-coq> y
 
rules // AST sort constructors to inductive types in Coq

  sortdecl-to-coq(|sort_decl_map, sort_dep_map):
    ident_key -> Inductive([Induc(ident_key, None(), Type(), decls)])//S|[Inductive ident_key : Type := decls.]|
    with
      constrctors := <hashtable-get(|ident_key)> sort_decl_map;
      deps := <hashtable-get(|ident_key)> sort_dep_map; debug(!"SORTDEPS:");
      coq_constrctors := <map(sort-constructor-to-coq(|ident_key))> constrctors;
      // Only make a `| ` if the sort is non-empty:
      (([] := coq_constrctors; decls := ListDecl(coq_constrctors))
       <+ decls := ListDeclBar(coq_constrctors))
  
  sort-constructor-to-coq(|sort_name):
    (constructor_name, args) ->
      ConsDecl(constructor_name,
               None(),
               OptType(c))
    with
      args' := <map(sort-to-coq)> args;
      c := <foldr(!sort_name, mk-arrow)> args'

rules // Rule generation

  rules-to-coq(|m):
    ident_key -> Inductive([Induc(ident_key, None(), ident_type, decls)])
    //    S|[Inductive ident_key : ident_type := decls.]|
    with
      (rs, (ro_ents, from_sort, from_rw_ents, to_sort, to_rw_ents)) := <hashtable-get(|ident_key)> m;
      ((ArrowROs(ros) := ro_ents)
        <+ ros := []); 
      ((ArrowRWs(from_rws) := from_rw_ents)
        <+ from_rws := []); 
      ((ArrowRWs(to_rws) := to_rw_ents)
        <+ to_rws := []);
      pre_type := <concat> [ros, [from_sort], from_rws, [to_sort], to_rws];
      ident_type := <map(sort-to-coq); foldr(!Prop(), mk-arrow)> pre_type;
      cs := <map(rule-to-coq(|ident_key))> rs;
      (([] := cs; decls := ListDecl(cs))
       <+ decls := ListDeclBar(cs))

  rule-to-coq(|rel_name):
    rule ->
      ConsDecl(ident_name,
               OptBinders(idents),
               OptType(rl))
    with
      (conc, prems) := <get-premises-and-conclusion> rule;
      // Rule name
      name := <extract-name-from-formula> conc;
      rname := <concat-strings> [rel_name, "_", name];
      ident_name := <newname> rname;
      // Variables
      pvars := <extract-variables> prems;
      svars := <extract-variables> conc;
      vars := <concat> [pvars, svars];
      idents := <map(mk-bind)> vars;
      // Conclusion
      c := <formula-to-coq> conc;
      // Premises
      ps := <map(formula-to-coq)> prems;
      rl := <foldr(!c, mk-arrowln)> ps // arrows nested to the right, with the conclusion as final element
  
  // Is there a way to just pass the constructor instead of creating these wrappers?
  // Can we create a lambda? 
  mk-arrowln:
    (x, y) -> ArrowLn(x, y)

  mk-arrow:
    (x, y) -> Arrow(x, y)
      
  mk-bind:
    s -> Bind(s)

rules // Formulae generation

  formula-to-coq:
    Formula(r) -> r'
    with
      r' := <formula-to-coq> r

  formula-to-coq:
    Relation(r,
             Source(sterm, _),
             arrow, 
             Target(tterm, _)) ->
      Apply(Apply(res0, st), tt)
    with
      rel_name := <get-arrow-name> arrow;
      res0 := <aux-ent-to-coq> (rel_name, r);
      st := <term-to-coq> sterm;
      tt := <term-to-coq> tterm

  // does not occur needed in desugared dynsem
  formula-to-coq:
    Relation(r,
             Source(sterm),
             arrow, 
             Target(tterm)) ->
      Apply(Apply(res0, st), tt)
    with
      rel_name := <get-arrow-name> arrow;
      res0 := <aux-ent-to-coq> (rel_name, r);
      st := <term-to-coq> sterm;
      tt := <term-to-coq> tterm

rules // Auxiliary entity generation

  aux-ent-to-coq:
    (trm, NoReads()) -> trm

  aux-ent-to-coq:
    (trm, Reads(reads)) -> res
    with
      res := <foldl(labelcomp-pair-to-coq; mk-app-rev)> (reads, trm)

  // Is there a way to just pass the constructor instead of creating these wrappers?
  // Can we create a lambda?
  labelcomp-pair-to-coq:
    (LabelComp(_, trm), rel_name) ->
      (res, rel_name)
    with
      res := <term-to-coq> trm

rules // Term generation

  term-to-coq:
    Con(c, ts) -> app
    with
      l := <length; int-to-string> ts;
      name := <concat-strings> [c, l];
      ts' := <map(term-to-coq)> ts;
      app := <foldl(mk-app-rev)> (ts', name) // application nested to the left

  term-to-coq:
    MapSelect(m, t) -> Apply(Apply(ml, m'), t')
    with
      ml := <coq-map-lookup>;
      m' := <term-to-coq> m;
      t' := <term-to-coq> t

  term-to-coq:
    MapExtend(m1, m2) ->
      Apply(Apply(Apply(mu, m2'), x'), y')
    with
      ((Map([Bind(x, y)]) := m1) 
        <+ debug(!"Please use map updates of the form {x |--> y, m}. Other kinds of updates are currently not supported."); fail);
      mu := <coq-map-update>;
      m2' := <term-to-coq> m2;
      x' := <term-to-coq> x;
      y' := <term-to-coq> y

  // Can this be turned into a lambda?
  mk-app-rev:
    (x, y) -> Apply(y, x)

  term-to-coq:
    VarRef(x) -> x

  term-to-coq:
    Var(x) -> x
  
  term-to-coq:
    MatchedVar(x) -> x

rules // Extracting the source constructor name

  extract-name-from-formula:
    Relation(_, Source(c, _), _, _) -> name
    with
      name := <extract-name-from-term> c

  extract-name-from-formula:
    Relation(_, Source(c), _, _) -> name
    with
      name := <extract-name-from-term> c

  extract-name-from-term:
    Con(name, _) -> name

rules // Extracting variables

  // Lists
  extract-variables:
    [] -> []
  
  extract-variables:
    [t|ts] -> zs
    with
      xs := <extract-variables> t;
      ys := <extract-variables> ts;
      zs := <concat> [xs, ys]
  
  // Formulas and relations
  extract-variables:
    Formula(r) -> xs
    with
      xs := <extract-variables> r
      
  extract-variables:
    Relation(reads, Source(s, writes), arrow, Target(t, writes')) -> xs
    with
      xs0 := <extract-variables> reads;
      xs1 := <extract-variables> s;
      xs2 := <extract-variables> writes;
      xs3 := <extract-variables> arrow;
      xs4 := <extract-variables> t;
      xs5 := <extract-variables> writes';
      xs := <concat> [xs0, xs1, xs2, xs3, xs4, xs5]
  
  extract-variables:
    Relation(reads, Source(s), arrow, Target(t)) -> xs
    with
      xs0 := <extract-variables> reads;
      xs1 := <extract-variables> s;
      xs3 := <extract-variables> arrow;
      xs4 := <extract-variables> t;
      xs := <concat> [xs0, xs1, xs3, xs4]
  
  // Reads
  extract-variables:
    Reads(rs) -> xs
    with
      xs := <extract-variables> rs
      
  extract-variables:
    NoReads() -> []

  // Arrows
  extract-variables:
    NamedDynamicEmitted(emitted, _) -> xs
    with
      xs := <extract-variables> emitted 
  
  extract-variables:
    NamedDynamic(_) -> []
  
  // Terms
  extract-variables:
    Var(x) -> [x]
  
  extract-variables:
    Con(_, ts) -> xs
    with
      xs := <extract-variables> ts

  extract-variables:
    VarRef(_) -> []
  
  // Labelled components
  extract-variables:
    LabelComp(_, c) -> xs
    with
      xs := <extract-variables> c
  
  // Maps
  extract-variables:
    Map(r) -> xs
    with
      xs := <extract-variables> r
  
  extract-variables:
    MapSelect(t1, t2) -> xs
    with
      xs1 := <extract-variables> t1;
      xs2 := <extract-variables> t2;
      xs := <concat> [xs1, xs2]
      
  extract-variables:
    MapExtend(m, t) -> xs
    with
      xs1 := <extract-variables> m;
      xs2 := <extract-variables> t;
      xs := <concat> [xs1, xs2]
      
  extract-variables:
    Bind(x, y) -> zs
    with
      xs := <extract-variables> x;
      ys := <extract-variables> y;
      zs := <concat> [xs, ys]

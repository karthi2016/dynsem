module coq-semantics/main

imports
  libstratego-gpp
  coq-semantics/-
  stratego/metaborg
  ds
  signatures/-
  coq-signatures/-
  coq-signatures/extensions/-
  coq-signatures/tactic/-
  coq-pp/-
  ds2ds/-
  analysis/-
  outline
  lib-ds

rules
  
  explicate-for-coq(|project-path) =
    in-project-path(
      include-imports;
      strip-annos;
      desugar-top;
      fuse-sections;
      desugar-varschemes-module;
      desugar-aliases-module;
      factorize-module;
      expand-implicits-module;
      factorize-module;
      explicate-module;
      copy-propagation-module;
      constant-propagation-module;
      defactorize-module;
      sugar-all
      |project-path)
  
  generate-coq:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"v")> path
      ; coq-file := <explicate-for-coq(|project-path); preprocess; debug(!0); module-to-coq; debug(!"done")> ast
    with
       result := <parenthesize-Coq; prettyprint-Coq; box2text-string(|100)> coq-file
    <+ <bottomup(try(not(is-string) ; not(is-list) ; not(prettyprint-Coq) ; debug(!"cannot pp ")))> coq-file
    ;  result := ""

rules // Module generation

  module-to-coq:
    Module(name, contents) -> coq_rs
    with
      sigs := <filter(?Signatures(<id>))> contents;
      sigs0 := <concat> sigs;
      ads0 := <filter(?ArrowDeclarations(<id>))> sigs0;
      ads := <concat> ads0;
      m := <new-hashtable>;
      <map(instantiate-sig(|m))> ads;
      rs0 := <filter(?Rules(<id>))> contents;
      rs := <concat> rs0;
      // create map from relation names to rules of relation
      <foldr(!m, push-named-rule)> rs;
      keys := <hashtable-keys> m;
      // generate rules for all relations
      coq_rs := <map(rules-to-coq(|m))> keys

  instantiate-sig(|m):
    ArrowDecl(from_sort, rel_name, to_sort) -> 1
    with
      <hashtable-put(|rel_name, ([], (from_sort, to_sort)))> m
  
  push-named-rule:
    (rule, m) -> m
    with
      (conc, prems) := <get-premises-and-conclusion> rule;
      name := <get-rel-name> conc;
      (rs, (from_sort, to_sort)) := <hashtable-get(|name)> m;
      <hashtable-put(|name, ([rule|rs], (from_sort, to_sort)))> m
  
  get-rel-name:
    Relation(_, _, arrow, _) -> name
    with
      name := <get-arrow-name> arrow
    
  get-arrow-name:
    NamedDynamicEmitted(_, name) -> name

  get-arrow-name:
    NamedDynamic(name) -> name

  get-premises-and-conclusion:
    Rule(prems, _, conc) -> (conc, prems)
    
  get-premises-and-conclusion:
    RuleW(conc, prems) -> (conc, prems)
    
  get-premises-and-conclusion:
    Axiom(conc) -> (conc, [])
  
rules // Sort-to-type generation

  sort-to-coq:
    SimpleSort(x) -> x

rules // Rule generation

  rules-to-coq(|m):
    ident_key -> S|[Inductive ident_key : ident_from -> ident_to -> Prop := decls.]|
    with
      <hashtable-get(|ident_key)> m; ?(rs, (from_sort, to_sort));
      ident_from := <sort-to-coq> from_sort;
      ident_to := <sort-to-coq> to_sort;
      cs := <map(rule-to-coq(|ident_key))> rs;
      decls := ListDeclBar(cs)

  rule-to-coq(|rel_name):
    rule ->
    ConsDecl(ident_name,
             OptBinders(idents),
             OptType(rl))
    with
      (conc, prems) := <get-premises-and-conclusion> rule;
      // Rule name
      name := <extract-name-from-formula> conc;
      rname := <concat-strings> [rel_name, "_", name];
      ident_name := <newname> rname;
      // Variables
      pvars := <extract-variables> prems;
      svars := <extract-variables> conc;
      vars := <concat> [pvars, svars];
      idents := <map(mk-bind)> vars;
      // Conclusion
      c := <formula-to-coq> conc;
      // Premises
      ps := <map(formula-to-coq)> prems;
      rl := <foldr(!c, mk-arrow)> ps // arrows nested to the right, with the conclusion as final element
  
  // Is there a way to just pass the constructor instead of creating these wrappers?
  // Can we create a lambda? 
  mk-arrow:
    (x, y) -> Arrow(x, y)
      
  mk-bind:
    s -> Bind(s)

rules // Formulae generation

  formula-to-coq:
    Formula(r) -> r'
    with
      r' := <formula-to-coq> r

  formula-to-coq:
    Relation(r,
             Source(sterm, _),
             arrow, 
             Target(tterm, _)) ->
      Apply(Apply(rel_name, st), tt)
    with
      rel_name := <get-arrow-name> arrow;
      st := <term-to-coq> sterm;
      tt := <term-to-coq> tterm

  formula-to-coq:
    Relation(r,
             Source(sterm),
             arrow, 
             Target(tterm)) ->
      Apply(Apply(rel_name, st), tt)
    with
      rel_name := <get-arrow-name> arrow;
      st := <term-to-coq> sterm;
      tt := <term-to-coq> tterm
      
rules // Term generation

  term-to-coq:
    Con(c, ts) -> app
    with
      ts' := <map(term-to-coq)> ts;
      app := <foldl(mk-app-rev)> (ts', c) // application nested to the left

  term-to-coq:
    MapSelect(m, t) -> Apply(Apply(ml, m'), t')
    with
      ml := <map-lookup>;
      m' := <term-to-coq> m;
      t' := <term-to-coq> t

  // Can this be turned into a lambda?
  mk-app-rev:
    (x, y) -> Apply(y, x)

  term-to-coq:
    VarRef(x) -> x

  term-to-coq:
    Var(x) -> x

rules // Extracting the source constructor name

  extract-name-from-formula:
    Relation(_, Source(c, _), _, _) -> name
    with
      name := <extract-name-from-term> c

  extract-name-from-formula:
    Relation(_, Source(c), _, _) -> name
    with
      name := <extract-name-from-term> c

  extract-name-from-term:
    Con(name, _) -> name

rules // Extracting variables

  // Lists
  extract-variables:
    [] -> []
  
  extract-variables:
    [t|ts] -> zs
    with
      xs := <extract-variables> t;
      ys := <extract-variables> ts;
      zs := <concat> [xs, ys]
  
  // Formulas and relations
  extract-variables:
    Formula(r) -> xs
    with
      xs := <extract-variables> r
      
  extract-variables:
    Relation(reads, Source(s, writes), arrow, Target(t, writes')) -> xs
    with
      xs0 := <extract-variables> reads;
      xs1 := <extract-variables> s;
      xs2 := <extract-variables> writes;
      xs3 := <extract-variables> arrow;
      xs4 := <extract-variables> t;
      xs5 := <extract-variables> writes';
      xs := <concat> [xs0, xs1, xs2, xs3, xs4, xs5]
  
  extract-variables:
    Relation(reads, Source(s), arrow, Target(t)) -> xs
    with
      xs0 := <extract-variables> reads;
      xs1 := <extract-variables> s;
      xs3 := <extract-variables> arrow;
      xs4 := <extract-variables> t;
      xs := <concat> [xs0, xs1, xs3, xs4]
  
  // Reads
  extract-variables:
    Reads(rs) -> xs
    with
      xs := <extract-variables> rs
      
  extract-variables:
    NoReads() -> []

  // Arrows
  extract-variables:
    NamedDynamicEmitted(emitted, _) -> xs
    with
      xs := <extract-variables> emitted 
  
  extract-variables:
    NamedDynamic(_) -> []
  
  // Terms
  extract-variables:
    Var(x) -> [x]
  
  extract-variables:
    Con(_, ts) -> xs
    with
      xs := <extract-variables> ts

  extract-variables:
    VarRef(_) -> []
  
  // Labelled components
  extract-variables:
    LabelComp(_, c) -> xs
    with
      xs := <extract-variables> c
  
  // Maps
  extract-variables:
    Map(r) -> xs
    with
      xs := <extract-variables> r
  
//  extract-variables:
//    MapSort(m) -> xs
//    with
//      xs := <extract-variables> m
  
  extract-variables:
    MapSelect(t1, t2) -> xs
    with
      xs1 := <extract-variables> t1;
      xs2 := <extract-variables> t2;
      xs := <concat> [xs1, xs2]
      
  extract-variables:
    MapExtend(m, t) -> xs
    with
      xs1 := <extract-variables> m;
      xs2 := <extract-variables> t;
      xs := <concat> [xs1, xs2]
      
  extract-variables:
    Bind(x, y) -> zs
    with
      xs := <extract-variables> x;
      ys := <extract-variables> y;
      zs := <concat> [xs, ys]

module coq-semantics/main

imports
  libstratego-gpp
  coq-semantics/-
  stratego/metaborg
  ds
  signatures/-
  coq-signatures/-
  coq-signatures/extensions/-
  coq-signatures/tactic/-
  coq-pp/-
  ds2ds/-
  analysis/-
  outline
  lib-ds

rules
  
  explicate-for-coq(|project-path) =
    in-project-path(
      include-imports;
      strip-annos;
      desugar-top;
      fuse-sections;
      desugar-varschemes-module;
      desugar-aliases-module;
      factorize-module;
      expand-implicits-module;
      factorize-module;
      explicate-module;
      copy-propagation-module;
      constant-propagation-module;
      defactorize-module;
      sugar-all
      |project-path)
  
  generate-coq:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"v")> path
      ; coq-file := <explicate-for-coq(|project-path); preprocess; debug(!0); module-to-coq; debug(!"done")> ast
    with
       result := <parenthesize-Coq; prettyprint-Coq; box2text-string(|100)> coq-file
    <+ <bottomup(try(not(is-string) ; not(is-list) ; not(prettyprint-Coq) ; debug(!"cannot pp ")))> coq-file
    ;  result := ""

rules // Module generation

  module-to-coq:
    Module(name, contents) -> defs
    with
      // Accumulate list of all signatures in module 
      sigs0 := <filter(?Signatures(<id>))> contents;
      sigs := <concat> sigs0;
      
      // Accumulate list of all sort declarations and constructors in module
      ss0 := <filter(?Sorts(<id>))> sigs;
      ss := <concat> ss0;
      sds := <filter(?SortDecl(<id>))> ss;
      scs0 := <filter(?Constructors(<id>))> sigs;
      scs := <concat> scs0;
      
      // Instantiate map for collecting information about declared simple sorts (constructor sort/type signatures)
      sc_map := <new-hashtable>;
      <map(instantiate-sortdecl(|sc_map))> sds;
      <map(push-sort-constructor(|sc_map))> scs;
      sc_keys := <hashtable-keys> sc_map;
      coq_cs := <map(sortdecls-to-coq(|sc_map))> sc_keys;
      
      // Accumulate list of all arrow declarations in module
      ads0 := <filter(?ArrowDeclarations(<id>))> sigs;
      ads := <concat> ads0;
      // Instantiate map collecting information about declared arrows (sort/type signature and a list of rules)
      ad_map := <new-hashtable>;
      <map(instantiate-arrow(|ad_map))> ads;
      rs0 := <filter(?Rules(<id>))> contents;
      rs := <concat> rs0;
      // create map from relation names to rules of relation
      <map(push-named-rule(|ad_map))> rs;
      
      ad_keys := <hashtable-keys> ad_map;
      // generate rules for all relations
      coq_rs := <map(rules-to-coq(|ad_map))> ad_keys;
      
      defs := <concat> [coq_cs, coq_rs]

  instantiate-sortdecl(|m):
    sort_name -> 1
    with
      <hashtable-put(|sort_name, [])> m

  instantiate-arrow(|m):
    ArrowDecl(from_sort, rel_name, to_sort) -> 1
    with
      <hashtable-put(|rel_name, ([], (from_sort, to_sort)))> m
  
  push-sort-constructor(|m):
    ConsDecl(name, from_sorts, SimpleSort(to_sort), annotations) -> 1
    with
      l := <length; int-to-string> from_sorts;
      name' := <concat-strings> [name, l];
      cs := <hashtable-get(|to_sort)> m;
      <hashtable-put(|to_sort, [(name', from_sorts)|cs])> m
  
  push-named-rule(|m):
    rule -> 1
    with
      (conc, prems) := <get-premises-and-conclusion> rule;
      name := <get-rel-name> conc;
      (rs, (from_sort, to_sort)) := <hashtable-get(|name)> m;
      <hashtable-put(|name, ([rule|rs], (from_sort, to_sort)))> m
  
  get-rel-name:
    Relation(_, _, arrow, _) -> name
    with
      name := <get-arrow-name> arrow
    
  get-arrow-name:
    NamedDynamicEmitted(_, name) -> name

  get-arrow-name:
    NamedDynamic(name) -> name

  get-premises-and-conclusion:
    Rule(prems, _, conc) -> (conc, prems)
    
  get-premises-and-conclusion:
    RuleW(conc, prems) -> (conc, prems)
    
  get-premises-and-conclusion:
    Axiom(conc) -> (conc, [])
  
rules // Sort-to-type generation

  sort-to-coq:
    SimpleSort(x) -> x

  sort-to-coq:
    MapSort(x, y) -> Apply(Apply(maptype, x'), y')
    with
      maptype := <map-type>;
      x' := <sort-to-coq> x;
      y' := <sort-to-coq> y
    
rules // AST/sort signature generation

  sortdecls-to-coq(|m):
    ident_key -> S|[Inductive ident_key : Type := decls.]|
    with
      cs := <hashtable-get(|ident_key)> m;
      ccs := <map(sortdecl-to-coq(|ident_key))> cs;
      decls := ListDeclBar(ccs)

  sortdecl-to-coq(|sort_name):
    (constructor_name, args) ->
      ConsDecl(constructor_name,
               None(),
               OptType(c))
    with
      args' := <map(sort-to-coq)> args;
      c := <foldr(!sort_name, mk-arrow)> args'

rules // Rule generation

  rules-to-coq(|m):
    ident_key -> S|[Inductive ident_key : ident_from -> ident_to -> Prop := decls.]|
    with
      (rs, (from_sort, to_sort)) := <hashtable-get(|ident_key)> m;
      ident_from := <sort-to-coq> from_sort;
      ident_to := <sort-to-coq> to_sort;
      cs := <map(rule-to-coq(|ident_key))> rs;
      decls := ListDeclBar(cs)

  rule-to-coq(|rel_name):
    rule ->
      ConsDecl(ident_name,
               OptBinders(idents),
               OptType(rl))
    with
      (conc, prems) := <get-premises-and-conclusion> rule;
      // Rule name
      name := <extract-name-from-formula> conc;
      rname := <concat-strings> [rel_name, "_", name];
      ident_name := <newname> rname;
      // Variables
      pvars := <extract-variables> prems;
      svars := <extract-variables> conc;
      vars := <concat> [pvars, svars];
      idents := <map(mk-bind)> vars;
      // Conclusion
      c := <formula-to-coq> conc;
      // Premises
      ps := <map(formula-to-coq)> prems;
      rl := <foldr(!c, mk-arrowln)> ps // arrows nested to the right, with the conclusion as final element
  
  // Is there a way to just pass the constructor instead of creating these wrappers?
  // Can we create a lambda? 
  mk-arrowln:
    (x, y) -> ArrowLn(x, y)

  mk-arrow:
    (x, y) -> Arrow(x, y)
      
  mk-bind:
    s -> Bind(s)

rules // Formulae generation

  formula-to-coq:
    Formula(r) -> r'
    with
      r' := <formula-to-coq> r

  formula-to-coq:
    Relation(r,
             Source(sterm, _),
             arrow, 
             Target(tterm, _)) ->
      Apply(Apply(rel_name, st), tt)
    with
      rel_name := <get-arrow-name> arrow;
      rc := <aux-ent-to-coq> r;
      st := <term-to-coq> sterm;
      tt := <term-to-coq> tterm

  formula-to-coq:
    Relation(r,
             Source(sterm),
             arrow, 
             Target(tterm)) ->
      Apply(Apply(res0, st), tt)
    with
      rel_name := <get-arrow-name> arrow;
      res0 := <aux-ent-to-coq> (rel_name, r);
      st := <term-to-coq> sterm;
      tt := <term-to-coq> tterm

rules // Auxiliary entity generation

  aux-ent-to-coq:
    (trm, NoReads()) -> trm

  aux-ent-to-coq:
    (trm, Reads(reads)) -> res
    with
      res := <foldl(labelcomp-pair-to-coq; mk-app-rev)> (reads, trm)

  // Is there a way to just pass the constructor instead of creating these wrappers?
  // Can we create a lambda?
  labelcomp-pair-to-coq:
    (LabelComp(_, trm), rel_name) ->
      (res, rel_name)
    with
      res := <term-to-coq> trm

rules // Term generation

  term-to-coq:
    Con(c, ts) -> app
    with
      ts' := <map(term-to-coq)> ts;
      app := <foldl(mk-app-rev)> (ts', c) // application nested to the left

  term-to-coq:
    MapSelect(m, t) -> Apply(Apply(ml, m'), t')
    with
      ml := <map-lookup>;
      m' := <term-to-coq> m;
      t' := <term-to-coq> t

  term-to-coq:
    MapExtend(m1, m2) ->
      Apply(Apply(Apply(mu, m2'), x'), y')
    with
      ((Map([Bind(x, y)]) := m1) 
        <+ debug(!"Please use map updates of the form {x |--> y, m}. Other kinds of updates are not supported currently."));
      mu := <map-update>;
      m2' := <term-to-coq> m2;
      x' := <term-to-coq> x;
      y' := <term-to-coq> y

  // Can this be turned into a lambda?
  mk-app-rev:
    (x, y) -> Apply(y, x)

  term-to-coq:
    VarRef(x) -> x

  term-to-coq:
    Var(x) -> x

rules // Extracting the source constructor name

  extract-name-from-formula:
    Relation(_, Source(c, _), _, _) -> name
    with
      name := <extract-name-from-term> c

  extract-name-from-formula:
    Relation(_, Source(c), _, _) -> name
    with
      name := <extract-name-from-term> c

  extract-name-from-term:
    Con(name, _) -> name

rules // Extracting variables

  // Lists
  extract-variables:
    [] -> []
  
  extract-variables:
    [t|ts] -> zs
    with
      xs := <extract-variables> t;
      ys := <extract-variables> ts;
      zs := <concat> [xs, ys]
  
  // Formulas and relations
  extract-variables:
    Formula(r) -> xs
    with
      xs := <extract-variables> r
      
  extract-variables:
    Relation(reads, Source(s, writes), arrow, Target(t, writes')) -> xs
    with
      xs0 := <extract-variables> reads;
      xs1 := <extract-variables> s;
      xs2 := <extract-variables> writes;
      xs3 := <extract-variables> arrow;
      xs4 := <extract-variables> t;
      xs5 := <extract-variables> writes';
      xs := <concat> [xs0, xs1, xs2, xs3, xs4, xs5]
  
  extract-variables:
    Relation(reads, Source(s), arrow, Target(t)) -> xs
    with
      xs0 := <extract-variables> reads;
      xs1 := <extract-variables> s;
      xs3 := <extract-variables> arrow;
      xs4 := <extract-variables> t;
      xs := <concat> [xs0, xs1, xs3, xs4]
  
  // Reads
  extract-variables:
    Reads(rs) -> xs
    with
      xs := <extract-variables> rs
      
  extract-variables:
    NoReads() -> []

  // Arrows
  extract-variables:
    NamedDynamicEmitted(emitted, _) -> xs
    with
      xs := <extract-variables> emitted 
  
  extract-variables:
    NamedDynamic(_) -> []
  
  // Terms
  extract-variables:
    Var(x) -> [x]
  
  extract-variables:
    Con(_, ts) -> xs
    with
      xs := <extract-variables> ts

  extract-variables:
    VarRef(_) -> []
  
  // Labelled components
  extract-variables:
    LabelComp(_, c) -> xs
    with
      xs := <extract-variables> c
  
  // Maps
  extract-variables:
    Map(r) -> xs
    with
      xs := <extract-variables> r
  
//  extract-variables:
//    MapSort(m) -> xs
//    with
//      xs := <extract-variables> m
  
  extract-variables:
    MapSelect(t1, t2) -> xs
    with
      xs1 := <extract-variables> t1;
      xs2 := <extract-variables> t2;
      xs := <concat> [xs1, xs2]
      
  extract-variables:
    MapExtend(m, t) -> xs
    with
      xs1 := <extract-variables> m;
      xs2 := <extract-variables> t;
      xs := <concat> [xs1, xs2]
      
  extract-variables:
    Bind(x, y) -> zs
    with
      xs := <extract-variables> x;
      ys := <extract-variables> y;
      zs := <concat> [xs, ys]

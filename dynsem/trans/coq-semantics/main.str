module coq-semantics/main

imports
  libstratego-gpp
  coq-semantics/-
  stratego/metaborg
  ds
  signatures/-
  coq-signatures/-
  coq-signatures/extensions/-
  coq-signatures/tactic/-
  coq-pp/-

rules
  
  generate-coq:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"v")> path
      ; coq-file := <strip-annos; module-to-coq> ast
    with
       result := <parenthesize-Coq; prettyprint-Coq; box2text-string(|100)> coq-file
    <+ <bottomup(try(not(is-string) ; not(is-list) ; not(prettyprint-Coq) ; debug(!"cannot pp ")))> coq-file
    ;  result := ""

rules // Module generation

  module-to-coq:
    Module(name, [Signatures(sigs), Rules(rs)]) -> coq_rs
    with
      m := <new-hashtable>;
      arrowdecs := <filter(?ArrowDeclarations(_))> sigs;
      <instantiate-sigs> (m, arrowdecs);
      // create map from relation names to rules of relation
      <foldr(!m, push-named-rule)> rs;
      keys := <hashtable-keys> m;
      // generate rules for all relations
      coq_rs := <map(generate-rules(|m))> keys
  
  // instantiate-sigs iterates through the declared arrow signatures
  // and instantiates the hashmap mapping a relation to its set of
  // rules and its type signature. 
  
  instantiate-sigs:
    (m, []) -> 1
  
  instantiate-sigs:
    (m, [ArrowDeclarations(arrdecs)]) -> o
    with
      o := <instantiate-sig> (m, arrdecs)
  
  instantiate-sig:
    (m, []) -> 1
  
  instantiate-sig:
    (m, [ArrowDecl(from_sort, rel_name, to_sort)|arrowdecs]) -> o
    with
      <hashtable-put(|rel_name, ([], (from_sort, to_sort)))> m;
      o := <instantiate-sig> (m, arrowdecs)
  
  push-named-rule:
    (rule, m) -> m
    with
      name := <get-rel-name> rule;
      (rs, (from_sort, to_sort)) := <hashtable-get(|name)> m;
      <hashtable-put(|name, ([rule|rs], (from_sort, to_sort)))> m
  
  get-rel-name:
    Rule(_, _, Relation(_, _, NamedDynamicEmitted(_, name), _)) -> name
  
  generate-rules(|m):
    ident_key -> S|[Inductive ident_key : ident_from -> ident_to -> Prop := decls.]|
    with
      <hashtable-get(|ident_key)> m; ?(rs, (from_sort, to_sort));
      ident_from := <sort-to-coq> from_sort;
      ident_to := <sort-to-coq> to_sort;
      cs := <map(rs-to-coq(|ident_key))> rs;
      decls := ListDeclBar(cs)

rules // Sort-to-type generation

  sort-to-coq:
    SimpleSort(x) -> x

rules // Rule generation

  rs-to-coq(|rel_name):
    Rule(prems, _, conc) ->
    ConsDecl(ident_name,
             OptBinders(idents),
             OptType(rl))
    with
      name := <extract-name-from-formula> conc;
      rname := <concat-strings> [rel_name, "_", name];
      ident_name := <newname> rname;
      pvars := <extract-variables> prems;
      svars := <extract-variables> conc;
      vars := <concat> [pvars, svars];
      idents := <map(mk-bind)> vars;
      c := <formula-to-coq> conc;
      ps := <map(formula-to-coq)> prems;
      rl := <foldr(!c, mk-arrow)> ps // arrows nested to the right, with the conclusion as final element
  
  // Is there a way to just pass the constructor instead of creating these wrappers?
  // Can we create a lambda? 
  mk-arrow:
    (x, y) -> Arrow(x, y)
      
  mk-bind:
    s -> Bind(s)
      
  formula-to-coq:
    Formula(r) -> r'
    with
      r' := <formula-to-coq> r
      
  formula-to-coq:
    Relation(r,
             Source(sterm, _),
             NamedDynamicEmitted(_, rel_name), 
             Target(tterm, _)) ->
      Apply(Apply(rel_name, st), tt)
    with
      st := <term-to-coq> sterm;
      tt := <term-to-coq> tterm
      
rules // Term generation

  term-to-coq:
    Con(c, ts) -> app
    with
      ts' := <map(term-to-coq)> ts;
      app := <foldl(mk-app-rev)> (ts', c) // application nested to the left

  // Can this be turned into a lambda?
  mk-app-rev:
    (x, y) -> Apply(y, x)

  term-to-coq:
    VarRef(x) -> x

  term-to-coq:
    Var(x) -> x

rules // extracting the root constructor name from a given formula 

  extract-name-from-formula:
    Relation(_, Source(c, _), _, _) -> name
    with
      name := <extract-name-from-term> c

  extract-name-from-term:
    Con(name, _) -> name

rules // extracting variables (for forall-quantification)

  extract-variables:
    [] -> []
  
  extract-variables:
    [t|ts] -> zs
    with
      xs := <extract-variables> t;
      ys := <extract-variables> ts;
      zs := <concat> [xs, ys]
  
  extract-variables:
    Formula(r) -> xs
    with
      xs := <extract-variables> r
      
  extract-variables:
    Relation(Reads(reads), Source(s, writes), NamedDynamicEmitted(emitted, _), Target(t, writes')) -> xs
    with
      xs0 := <extract-variables> reads;
      xs1 := <extract-variables> s;
      xs2 := <extract-variables> writes;
      xs3 := <extract-variables> emitted;
      xs4 := <extract-variables> t;
      xs5 := <extract-variables> writes';
      xs := <concat> [xs0, xs1, xs2, xs3, xs4, xs5]
  
  extract-variables:
    Var(x) -> [x]
  
  extract-variables:
    Con(_, ts) -> xs
    with
      xs := <extract-variables> ts

  extract-variables:
    VarRef(_) -> []

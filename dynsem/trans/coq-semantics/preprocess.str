module coq-semantics/preprocess

imports
  coq-semantics/main
  signatures/-
  ds
  
rules // Term pre-processing

  // Replace wildcards by named variables
  // FIXME: should name based on the type of the variable.
  P: Wld() -> Var(x) where x := <newname> "wld"

strategies

  pre-process = bottomup(try(P))

rules
  
  pre-process-module:
    mod -> (sort_decl_map, arrow_decl_map)
    with
      (sort_decl_map, arrow_decl_map) := <collect-data-from-module; debug; data-to-hashmap; analyze-mutual-dependencies> mod

rules // Accumulate information about declared arrows, rules, and AST constructors

  // FIXME: this is fairly inefficient
  collect-data-from-module:
    Module(name, contents) -> (sort_decls, sort_constrs, arrow_decls, ruls)
    with
      // Signatures 
      sigs* := <filter(?Signatures(<id>)); concat> contents;
      // Rules
      ruls := <filter(?Rules(<id>)); concat> contents;
      // Sort declarations
      sort_decls := <filter(?Sorts(<id>)); concat; filter(?SortDecl(<id>))> sigs*;
      // Sort constructors
      sort_constrs := <filter(?Constructors(<id>)); concat> sigs*;
      // Arrow declarations
      arrow_decls := <filter(?ArrowDeclarations(<id>)); concat> sigs*

rules // Store accumulated information in maps for easy dereferencing

  data-to-hashmap:
    (sort_decls, sort_constrs, arrow_decls, ruls) -> (sort_decl_map, arrow_decl_map)
    with
      // Sort declarations
      sort_decl_map := <new-hashtable>;
      <map(instantiate-sortdecl(|sort_decl_map))> sort_decls;
      <map(push-sort-constructor(|sort_decl_map))> sort_constrs;
      
      // Arrow declarations
      arrow_decl_map := <new-hashtable>;
      <map(instantiate-arrow(|arrow_decl_map))> arrow_decls;
      <map(push-named-rule(|arrow_decl_map))> ruls

  instantiate-sortdecl(|m):
    sort_name -> 1
    with
      <hashtable-put(|sort_name, [])> m

  instantiate-arrow(|m):
    ArrowDecl(ro_ents, from_sort, from_rw_ents, rel_name, to_sort, to_rw_ents) -> 1
    with
      <hashtable-put(|rel_name, ([], (ro_ents, from_sort, from_rw_ents, to_sort, to_rw_ents)))> m
  
  push-sort-constructor(|m):
    ConsDecl(name, from_sorts, SimpleSort(to_sort), annotations) -> 1
    with
      l := <length; int-to-string> from_sorts;
      name' := <concat-strings> [name, l];
      cs := <hashtable-get(|to_sort)> m;
      <hashtable-put(|to_sort, [(name', from_sorts)|cs])> m
  
  push-sort-constructor(|m):
    NullaryConsDecl(name, SimpleSort(to_sort), annotations) -> 1
    with
      l := <int-to-string> 0;
      name' := <concat-strings> [name, l];
      cs := <hashtable-get(|to_sort)> m;
      <hashtable-put(|to_sort, [(name', [])|cs])> m
  
  push-named-rule(|m):
    rule -> 1
    with
      (conc, prems) := <get-premises-and-conclusion> rule;
      name := <get-rel-name> conc;
      (rs, sig) := <hashtable-get(|name)> m;
      <hashtable-put(|name, ([rule|rs], sig))> m

rules // Analyze mutual dependencies

  // FIXME
  analyze-mutual-dependencies:
    a -> a

rules // Utilities for querying rules

  get-rel-name:
    Relation(_, _, arrow, _) -> name
    with
      name := <get-arrow-name> arrow
    
  get-arrow-name:
    NamedDynamicEmitted(_, name) -> name

  get-arrow-name:
    NamedDynamic(name) -> name

  get-premises-and-conclusion:
    Rule(prems, _, conc) -> (conc, prems)
    
  get-premises-and-conclusion:
    RuleW(conc, prems) -> (conc, prems)
    
  get-premises-and-conclusion:
    Axiom(conc) -> (conc, [])
  
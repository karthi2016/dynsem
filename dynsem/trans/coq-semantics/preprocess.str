module coq-semantics/preprocess

imports
  coq-semantics/main
  signatures/-
  ds
  analysis/rename
  coq-semantics/coqmappings
  
rules // Term pre-processing

  // FIXME: P should augment arrow signatures to record their sort information.
  P = id

strategies

  pre-process = bottomup(try(P))

rules
  
  pre-process-module:
    mod -> (sort_decl_map, arrow_decl_map, sort_dep_map, arrow_dep_map)
    with
      (sort_decl_map, arrow_decl_map, sort_dep_map, arrow_dep_map) := <pre-process; collect-data-from-module; data-to-hashmap; analyze-mutual-dependencies> mod
      
rules // Accumulate information about declared arrows, rules, and AST constructors

  // FIXME: this is fairly inefficient
  collect-data-from-module:
    Module(name, contents) -> (sort_decls, sort_constrs, arrow_decls, ruls)
    with
      // Signatures 
      sigs* := <filter(?Signatures(<id>)); concat> contents;
      // Rules
      ruls := <filter(?Rules(<id>)); concat> contents;
      // Sort declarations
      sort_decls := <filter(?Sorts(<id>)); concat; filter(?SortDecl(<id>))> sigs*;
      // Sort constructors
      sort_constrs := <filter(?Constructors(<id>)); concat> sigs*;
      // Arrow declarations
      arrow_decls := <filter(?ArrowDeclarations(<id>)); concat> sigs*

rules // Store accumulated information in maps for easy dereferencing

  // Type of sort_decl_map:
  //
  //   SortName -fin-> Constructors
  //   Constructors := (ConstructorName x List(Sort))
  //
  // Type of arrow_decl_map:
  //
  //   RelName -fin-> (Rules, RelSignature)
  //   RelSignature := (List(Sorts_RO) x Sort_From x List(Sorts_RW) x Sort_To x List(Sorts_RW))
  //   Rules := RuleName -fin-> (Formula_Conclusion x List(Formula_Premise))
  //
  // Type of sort_dep_map
  //
  //   SortName -fin-> SortName
  //
  // Type of arrow_dep_map
  //
  //   RelName -fin-> RelName

  data-to-hashmap:
    (sort_decls, sort_constrs, arrow_decls, ruls) -> (sort_decl_map, arrow_decl_map)
    with
      // Sort declarations
      sort_decl_map := <new-hashtable>;
      <map(instantiate-sortdecl(|sort_decl_map))> sort_decls;
      <map(push-sort-constructor(|sort_decl_map))> sort_constrs;
      
      // Arrow declarations
      arrow_decl_map := <new-hashtable>;
      <map(instantiate-arrow(|arrow_decl_map))> arrow_decls;
      <map(push-named-rule(|arrow_decl_map))> ruls

  instantiate-sortdecl(|m):
    sort_name -> 1
    with
      <hashtable-put(|sort_name, [])> m

  instantiate-arrow(|m):
    ArrowDecl(ro_ents, from_sort, from_rw_ents, rel_name, to_sort, to_rw_ents) -> 1
    with
      <hashtable-put(|rel_name, ([], (ro_ents, from_sort, from_rw_ents, to_sort, to_rw_ents)))> m
  
  push-sort-constructor(|m):
    ConsDecl(name, from_sorts, SimpleSort(to_sort), annotations) -> 1
    with
      l := <length; int-to-string> from_sorts;
      name' := <concat-strings> [name, l];
      cs := <hashtable-get(|to_sort)> m;
      <hashtable-put(|to_sort, [(name', from_sorts)|cs])> m
  
  push-sort-constructor(|m):
    NullaryConsDecl(name, SimpleSort(to_sort), annotations) -> 1
    with
      l := <int-to-string> 0;
      name' := <concat-strings> [name, l];
      cs := <hashtable-get(|to_sort)> m;
      <hashtable-put(|to_sort, [(name', [])|cs])> m
  
  push-named-rule(|m):
    rule -> 1
    with
      (conc, prems) := <get-premises-and-conclusion> rule;
      name := <get-rel-name> conc;
      (rs, sig) := <hashtable-get(|name)> m;
      <hashtable-put(|name, ([rule|rs], sig))> m

rules // Analyze mutual dependencies

  // FIXME
  analyze-mutual-dependencies:
    (sort_decl_map, arrow_decl_map) -> (sort_decl_map, arrow_decl_map, sort_dep_map, arrow_dep_map)
    with
      sort_dep_map := <new-hashtable>;
      arrow_dep_map := <new-hashtable>;
      <hashtable-keys; map(sort-analyze-dependency(|sort_decl_map, sort_dep_map))> sort_decl_map;
      <hashtable-keys; map(arrow-analyze-dependency(|arrow_decl_map, arrow_dep_map))> arrow_decl_map

// Should these dependencies compute isets instead?

rules // Sort dependency analysis

  sort-analyze-dependency(|sort_decl_map, sort_dep_map):
    sort_name -> 1
    with
      constrctors := <hashtable-get(|sort_name)> sort_decl_map;
      deps := <map({c_name, c_args: ?(c_name, c_args); (<foldr(![], sort-predefined-or-definee(|sort_name))> c_args) }); concat> constrctors;
      <hashtable-put(|sort_name, deps)> sort_dep_map

  sort-predefined-or-definee(|c_name1):
    (SimpleSort(c_name2), deps) -> deps'
    with
      predefineds := <coq-predefined>;
      ((!c_name2; ?c_name1; deps' := deps)
        <+ (<elem> (c_name2, predefineds); deps' := deps)
        <+ deps' := [c_name2|deps])
  
  sort-predefined-or-definee(|c_name1):
    (MapSort(from_sort, to_sort), deps) -> deps'
    with
      from_deps := <sort-predefined-or-definee(|c_name1)> (from_sort, deps);
      deps' := <sort-predefined-or-definee(|c_name1)> (to_sort, from_deps)

rules // Arrow dependency analysis

  arrow-analyze-dependency(|arrow_decl_map, arrow_dep_map):
    arrow_name -> 1
    with
      (ruls, rel_sig) := <hashtable-get(|arrow_name)> arrow_decl_map; 
      deps := <map({prems: Rule(prems, _, _) := <id>; (<foldr(![], arrow-definee(|arrow_name))> prems)}); concat> ruls;
      <hashtable-put(|arrow_name, deps)> arrow_dep_map

  arrow-definee(|arrow_name):
    (Formula(rel), deps) -> deps'
    with
      arrow_name' := <get-rel-name> rel;
      ((?arrow_name; deps' := deps)
        <+ deps' := [arrow_name'|deps])
  
rules // Utilities for querying rules

  get-rel-name:
    Relation(_, _, arrow, _) -> name
    with
      name := <get-arrow-name> arrow
    
  get-arrow-name:
    NamedDynamicEmitted(_, name) -> name

  get-premises-and-conclusion:
    Rule(prems, _, conc) -> (conc, prems)

  get-arrow-name:
    NamedDynamic(name) -> name


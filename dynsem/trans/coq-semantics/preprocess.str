module coq-semantics/preprocess

imports
  coq-semantics/-
  signatures/-
  ds
  analysis/-

signature // Augment relation constructor with more informative relation name recording the source sort (type)

  constructors
    NamedDynamicEmitted : List(LabelComp) * IDNOHYPH * Type -> Rel

rules
  
  pre-process-module:
    (mod, ds2v_aliases) -> (sort_decl_map, arrow_decl_map, sort_dep_map, arrow_dep_map, aliases)
    with
      (sort_decl_map, arrow_decl_map, sort_dep_map, arrow_dep_map) :=
        <collect-data-from-module; data-to-hashmap; analyze-mutual-dependencies(|ds2v_aliases)> (mod, ds2v_aliases);
      // Construct alias map
      aliases := <new-hashtable>;
      <collect-overloaded-arrow-aliases(|arrow_decl_map)> aliases;
      <collect-ds2v-aliases(|ds2v_aliases)> aliases

rules // Unfold case constructions

	unfold-rule-cases:
		(prems, Rule([], d, conc)) -> [Rule(prems, d, conc)]
		
  unfold-rule-cases:
  	(prems0, Rule([Formula(f)|prems1], d, conc)) ->
  		rs
  	with
  		rs :=
  			<unfold-rule-cases> (<concat> [prems0, [Formula(f)]],
  															Rule(prems1, d, conc)) 
	
	unfold-rule-cases:
		(prems0, Rule([CaseMatch(VarRef(x), cs)|prems1], d, conc)) ->
			rs
		with
  		case_patterns := <filter(\ CasePattern(x, _) -> x\)> cs;
			rs := <unfold-case> (VarRef(x), cs, case_patterns, prems0,
															 Rule(prems1, d, conc))
			
	unfold-case:
		(x, [CasePattern(patt, prems2)|cs], case_patterns, prems0,
		 Rule(prems1, d, conc)) ->
			rs
		with
  		neg_case_patterns :=
				<filter(?x);
				 map(\ t -> Formula(NMatch(x, t)) \)> case_patterns;
			prems0' := <concat> [prems0, [Formula(Match(x, patt))|neg_case_patterns]];
			prems1' := <concat> [prems2, prems1];
  		rs0 := <unfold-rule-cases> (prems0', Rule(prems1', d, conc));
  		rs1 :=
		  	<unfold-case> (x, cs, case_patterns, prems0,
		  										 Rule(prems1, d, conc));
			rs := <concat> [rs0, rs1]
			
	unfold-case:
		(x, [CaseOtherwise(prems2)|cs], case_patterns, prems0,
		 Rule(prems1, d, conc)) ->
			rs
		with
  		neg_case_patterns :=
				<map(\ t -> Formula(NMatch(x, t)) \)> case_patterns;
			prems0' := <concat> [prems0, neg_case_patterns];
			prems1' := <concat> [prems2, prems1];
  		rs0 := <unfold-rule-cases> (prems0', Rule(prems1', d, conc));
		  rs1 :=
		  	<unfold-case> (x, cs, case_patterns, prems0,
		  										 Rule(prems1, d, conc));
			rs := <concat> [rs0, rs1]
	
	unfold-case:
		(x, [], case_patterns, prems0,
		 Rule(prems1, d, conc)) ->
		 	[]

rules // Accumulate information about declared arrows, rules, and AST constructors

  // FIXME: this is fairly inefficient
  collect-data-from-module:
    (Module(name, contents), ds2v_aliases) -> (sort_decls, sort_constrs, arrow_decls, ruls, ds2v_aliases)
    with
      // Signatures 
      sigs* := <filter(?Signatures(<id>)); concat> contents;
      // Rules
      ruls := <filter(?Rules(<id>)); concat;
      				 map(\ rule -> <unfold-rule-cases> ([], rule) \);
      				 concat> contents;
      // Sort declarations
      sort_decls := <filter(?Sorts(<id>)); concat; filter(?SortDecl(<id>))> sigs*;
      // Sort constructors
      sort_constrs := <filter(?Constructors(<id>)); concat> sigs*;
      // Arrow declarations
      arrow_decls := <filter(?ArrowDeclarations(<id>)); concat> sigs*

rules // Store accumulated information in maps for easy dereferencing

  // Type of sort_decl_map:
  //
  //   SortName -fin-> Constructors
  //   Constructors := (ConstructorName x List(Sort))
  //
  // Type of arrow_decl_map:
  //
  //   (RelName, SortName) -fin-> (Rules, RelSignature)
  //   RelSignature := (List(Sorts_RO) x Sort_From x List(Sorts_RW) x Sort_To x List(Sorts_RW))
  //   Rules := RuleName -fin-> (Formula_Conclusion x List(Formula_Premise))
  //
  // Type of sort_dep_map
  //
  //   SortName -fin-> SortName
  //
  // Type of arrow_dep_map
  //
  //   RelName -fin-> RelName

  data-to-hashmap:
    (sort_decls, sort_constrs, arrow_decls, ruls, ds2v_aliases) -> (sort_decl_map, arrow_decl_map)
    with
      // Sort declarations
      sort_decl_map := <new-hashtable>;
      <map(instantiate-sortdecl(|sort_decl_map, ds2v_aliases))> sort_decls;
      <map(push-sort-constructor(|sort_decl_map, ds2v_aliases))> sort_constrs;
      
      // Arrow declarations
      arrow_decl_map := <new-hashtable>;
      <map(instantiate-arrow(|arrow_decl_map, ds2v_aliases))> arrow_decls;
      <map(push-named-rule(|arrow_decl_map, ds2v_aliases))> ruls

  instantiate-sortdecl(|m, ds2v_aliases):
    sort_name -> 1
    with
      if <not(is-builtin-sort(|ds2v_aliases))> sort_name // If sort is not a Coq built-in
      then <hashtable-put(|sort_name, [])> m
      end

  instantiate-arrow(|m, ds2v_aliases):
    ArrowDecl(ro_ents, from_sort, from_rw_ents, rel_name, to_sort, to_rw_ents) -> 1
    with
      if <not(is-builtin-arrow(|ds2v_aliases))> (rel_name, <get-sort-name> from_sort) // If arrow is not a Coq built-in
      then <hashtable-put(|(rel_name, from_sort), ([], (ro_ents, from_sort, from_rw_ents, to_sort, to_rw_ents)))> m
      end
  
  push-sort-constructor(|m, ds2v_aliases):
    ConsDecl(name, from_sorts, SimpleSort(to_sort), annotations) -> 1
    with
      if <not(is-builtin-sort(|ds2v_aliases))> to_sort // If sort is not a Coq built-in
      then 
        name' := <rename-constructor> (name, from_sorts);
        cs := <hashtable-get(|to_sort)> m;
        <hashtable-put(|to_sort, [(name', from_sorts)|cs])> m
      else
        debug(! (<concat-strings> ["WARNING: The sort ", to_sort, " maps to a Coq built-in type, but has constructor: ", name]))
      end 
  
  push-sort-constructor(|m, ds2v_aliases):
    NullaryConsDecl(name, SimpleSort(to_sort), annotations) -> 1
    with
      if <not(is-builtin-sort(|ds2v_aliases))> to_sort // If sort is not a Coq built-in
      then 
        name' := <rename-constructor> (name, []);
        cs := <hashtable-get(|to_sort)> m;
        <hashtable-put(|to_sort, [(name', [])|cs])> m
      else
        debug(! (<concat-strings> ["WARNING: The sort ", to_sort, " maps to a Coq built-in type, but has constructor: ", name]))
      end
  
  push-named-rule(|m, ds2v_aliases):
    rule -> 1
    with
      (conc, prems) := <get-premises-and-conclusion> rule;
      (name, sort) := <get-rel-name-and-sort> conc;
      if <not(is-builtin-arrow(|ds2v_aliases))> (name, <get-sort-name> sort) // If arrow is not a Coq built-in
      then 
        (rs, sig) := <hashtable-get(|(name, sort))> m;
        <hashtable-put(|(name, sort), ([rule|rs], sig))> m
      else
        debug(! (<concat-strings> ["WARNING: The arrow ", <rename-overloaded-arrow> (name, sort), " maps to a Coq built-in type, but has rule(s)."]))
      end

rules // Analyze mutual dependencies

  analyze-mutual-dependencies(|ds2v_aliases):
    (sort_decl_map, arrow_decl_map) -> (sort_decl_map, arrow_decl_map, sort_dep_map, arrow_dep_map)
    with
      sort_dep_map := <new-hashtable>;
      arrow_dep_map := <new-hashtable>;
      <hashtable-keys; map(sort-analyze-dependency(|sort_decl_map, sort_dep_map, ds2v_aliases))> sort_decl_map;
      <hashtable-keys; map(arrow-analyze-dependency(|arrow_decl_map, arrow_dep_map, ds2v_aliases))> arrow_decl_map

// Should these dependencies compute isets instead?

rules // Sort dependency analysis

  sort-analyze-dependency(|sort_decl_map, sort_dep_map, ds2v_aliases):
    sort_name -> 1
    with
      constrctors := <hashtable-get(|sort_name)> sort_decl_map;
      deps := <map(\ (c_name, c_args) -> (<foldr(![], sort-predefined-or-definee(|sort_name, ds2v_aliases))> c_args) \); concat> constrctors;
      <hashtable-put(|sort_name, deps)> sort_dep_map

  sort-predefined-or-definee(|c_name1, ds2v_aliases):
    (SimpleSort(c_name2), deps) -> deps'
    with
      predefineds := <coq-predefined>;
      ((!c_name2; ?c_name1; deps' := deps)
        <+ (<elem> (c_name2, predefineds); deps' := deps)
        <+ (<is-builtin-sort(|ds2v_aliases)> c_name2; deps' := deps)
        <+ deps' := [c_name2|deps])
  
  sort-predefined-or-definee(|c_name1, ds2v_aliases):
    (MapSort(from_sort, to_sort), deps) -> deps'
    with
      from_deps := <sort-predefined-or-definee(|c_name1, ds2v_aliases)> (from_sort, deps);
      deps' := <sort-predefined-or-definee(|c_name1, ds2v_aliases)> (to_sort, from_deps)

rules // Arrow dependency analysis

  arrow-analyze-dependency(|arrow_decl_map, arrow_dep_map, ds2v_aliases):
    (arrow_name, sort) -> 1
    with
      (ruls, rel_sig) := <hashtable-get(|(arrow_name, sort))> arrow_decl_map;
      deps := <map({prems: Rule(prems, _, _) := <id>; (<foldr(![], arrow-definee(|arrow_name, sort, ds2v_aliases))> prems)}); concat> ruls;
      <hashtable-put(|(arrow_name, sort), deps)> arrow_dep_map

  arrow-definee(|arrow_name, sort, ds2v_aliases):
    (Formula(rel@Relation(_, _, _, _)), deps) -> deps'
    with
      (arrow_name', sort') := <get-rel-name-and-sort> rel;
      ((?(arrow_name, sort); deps' := deps)
        <+ <is-builtin-arrow(|ds2v_aliases)> (arrow_name', <get-sort-name> sort'); deps' := deps 
        <+ deps' := [(arrow_name', sort')|deps])

  arrow-definee(|arrow_name, sort, ds2v_aliases):
    (Formula(Match(x, y)), deps) -> deps
  
  arrow-definee(|arrow_name, sort, ds2v_aliases):
    (Formula(NMatch(x, y)), deps) -> deps
  
rules // Alias collection and querying

	find-duplicate-arrow-names:
    arrow_decl_map -> dups
    with
      dups := <hashtable-keys; map(\ (name, _) -> name \); duplicates> arrow_decl_map

	collect-overloaded-arrow-aliases(|arrow_decl_map):
		alias_map -> 1
		with
      dup_arrow_names := <find-duplicate-arrow-names> arrow_decl_map;
      <hashtable-keys; map(try({ name, sort, sort_name, rename:
      												 ?(name, sort); 
      												 <elem> (name, dup_arrow_names);
      												 sort_name := <get-sort-name> sort;
      												 rename := <rename-overloaded-arrow> (name, sort_name);
      												 <hashtable-put(|(name, sort_name), (rename, sort))> alias_map }))> arrow_decl_map

	apply-alias(|alias_map):
		name -> rename
		with
			(rename := <hashtable-get(|name)> alias_map)
			<+ (rename := name)
	
	collect-ds2v-aliases(|ds2v_aliases):
		alias_map -> 1
		with
			<map(try({ name, sort, coq_name:
								 (?ArrowAlias(name, sort, coq_name);
								   <hashtable-put(|(name, sort), (coq_name, sort))> alias_map)
								 <+ (?SortAlias(name, coq_name);
								 		<hashtable-put(|name, coq_name)> alias_map) }))> ds2v_aliases

	// Succeeds if sort_name has a defined ds2v alias
	is-builtin-sort(|ds2v_aliases):
		sort_name -> 1
		where
			[_|_] := <filter(?SortAlias(sort_name, _))> ds2v_aliases

	// Succeeds if arrow_name has a defined ds2v alias
	is-builtin-arrow(|ds2v_aliases):
		(arrow_name, sort) -> 1
		where
			[_|_] := <filter(?ArrowAlias(arrow_name, sort, _))> ds2v_aliases

rules // Utilities for querying rules

  get-rel-name:
    Relation(_, _, arrow, _) -> name
    with
      name := <get-arrow-name> arrow
    
  get-rel-name-and-sort:
    Relation(_, _, arrow, _) -> (name, sort)
    with
      name := <get-arrow-name> arrow;
      sort := <get-arrow-sort> arrow
    
  get-arrow-name:
    NamedDynamicEmitted(_, name, _) -> name

  get-arrow-sort:
    NamedDynamicEmitted(_, _, sort) -> sort

  get-premises-and-conclusion:
    Rule(prems, _, conc) -> (conc, prems)

  get-arrow-name:
    NamedDynamic(name) -> name

rules // Utilities for lists

  duplicates:
    [] -> []
  
  duplicates:
    [x|xs] -> dups
    where
        (<elem> (x, xs); dups := [x|<filter(not(?x)); duplicates> xs])
      <+ dups := <duplicates> xs
  
rules // Naming conventions

  rename-overloaded-arrow:
    (arrow_name, sort_name) -> <concat-strings> [arrow_name, "_", sort_name]

  rename-constructor:
    (constructor_name, args) -> <concat-strings> [constructor_name, <length; int-to-string> args]
module ds
imports Common Module Signatures

exports
  context-free start-symbols
    Module

  context-free syntax
    "rules" Rule*                               -> ModuleSection {cons("Rules")}
    "strict" ID {INT ","}+ "/" INT              -> Rule          {cons("Strict")}
    "seqstrict" ID {INT ","}+ "/" INT           -> Rule          {cons("Seqstrict")}
    Formula                                     -> Rule          {cons("Axiom")}
    {Premise ","}+ INFER Relation               -> Rule          {cons("Rule")}
    Relation "where" {Premise ","}+             -> Rule          {cons("RuleW")}
    Formula                                     -> Premise       {cons("Formula")}
    "all-fail"                                  -> Premise       {cons("AllFail")}
    "{" {Premise ","}* "}"                      -> PremisesBlock {cons("PremiseBlock")}
    Premise "<" PremisesBlock "+" PremisesBlock -> Premise       {cons("MergePoint")}
    "try" PremisesBlock "or" PremisesBlock      -> Premise       {cons("TryOr")}
    "imports"                                   -> ID            {reject}
    "signature"                                 -> ID            {reject}
    "constructors"                              -> ID            {reject}
    "sorts"                                     -> ID            {reject}
    "arrows"                                    -> ID            {reject}
    "rules"                                     -> ID            {reject}
    "fresh"                                     -> ID            {reject}
    "where"                                     -> ID            {reject}
    "true"                                      -> ID            {reject}
    "false"                                     -> ID            {reject}
    "fresh"                                     -> ID            {reject}
    "fail"                                      -> ID            {reject}

  context-free syntax
    CONTENTCOMPLETE -> ModuleSection {cons("COMPLETION-ModuleSection")}
    CONTENTCOMPLETE -> Rule          {cons("COMPLETION-Rule")}
    CONTENTCOMPLETE -> PremisesBlock {cons("COMPLETION-PremisesBlock")}
    CONTENTCOMPLETE -> Premise       {cons("COMPLETION-Premise")}
    CONTENTCOMPLETE -> ID            {cons("COMPLETION-ID")}

  context-free syntax
    Term "=>" Term                              -> Formula   {cons("Match")}
    Term "=!=>" Term                            -> Formula   {cons("NMatch")}
    Term "==" Term                              -> Formula   {cons("TermEq")}
    Term "!=" Term                              -> Formula   {cons("TermNeq")}
    Var "<?" Type                               -> Formula   {cons("TypeCheck")}
    Var "<:" Type                               -> Formula   {cons("TypeCast")}
    Relation                                    -> Formula   
    Reads Source Rel Target                     -> Relation  {cons("Relation")}
    "value" "(" Term ")"                        -> Formula   {cons("IsValue")}
                                                -> Reads     {cons("NoReads")}
    LabelComp+ "|-"                             -> Reads     {cons("Reads")}
    Term                                        -> Source    {cons("Source")}
    Term "::" LabelComp+                        -> Source    {cons("Source")}
    Term                                        -> Target    {cons("Target")}
    Term "::" LabelComp+ "."                    -> Target    {cons("Target")}
    "-->"                                       -> Rel       {cons("Dynamic")}
    "-" ID "->"                                 -> Rel       {cons("NamedDynamic")}
    "-" ID "(" ID ")" "->"                      -> Rel       {cons("NamedDynamicParametric")}
    "-" {LabelComp ","}+ "->"                   -> Rel       {cons("DynamicEmitted")}
    "-" {LabelComp ","}+ "-" ID "->"            -> Rel       {cons("NamedDynamicEmitted")}
    "-" {LabelComp ","}+ "-" ID "(" ID ")" "->" -> Rel       {cons("NamedDynamicEmittedParametric")}
    Type Term                                   -> LabelComp {cons("LabelComp")}

  context-free syntax
    CONTENTCOMPLETE -> Relation  {cons("COMPLETION-Relation")}
    CONTENTCOMPLETE -> Formula   {cons("COMPLETION-Formula")}
    CONTENTCOMPLETE -> Reads     {cons("COMPLETION-Reads")}
    CONTENTCOMPLETE -> Source    {cons("COMPLETION-Source")}
    CONTENTCOMPLETE -> Target    {cons("COMPLETION-Target")}
    CONTENTCOMPLETE -> Rel       {cons("COMPLETION-Rel")}
    CONTENTCOMPLETE -> LabelComp {cons("COMPLETION-LabelComp")}

  context-free syntax
    ID                                  -> Var   {cons("VarRef")}
    Var                                 -> Term  
    Term ":" Type                       -> Cast  {cons("Cast")}
    Cast                                -> Term  
    Var "@" Term                        -> Term  {cons("As")}
    "_"                                 -> Term  {cons("Wld")}
    STRING                              -> Term  {cons("String")}
    INT                                 -> Term  {cons("Int")}
    REAL                                -> Term  {cons("Real")}
    ID "(" {Term ","}* ")"              -> Term  {cons("Con")}
    "[" {Term ","}* "]"                 -> List  {cons("List")}
    "[" {Term ","}* "|" Term "]"        -> List  {cons("ListTail")}
    List                                -> Term  
    "fresh"                             -> Term  {cons("Fresh")}
    "true"                              -> Term  {cons("True")}
    "false"                             -> Term  {cons("False")}
    "{" {Entry ","}* "}"                -> Term  {cons("Map")}
    Term "|-->" Term                    -> Entry {cons("Bind")}
    Term "|*->" Term                    -> Entry {cons("Binds")}
    Term                                -> Entry {cons("MapEntry")}
    Term "[" Term "]"                   -> Term  {cons("MapSelect")}
    Term "+" Term                       -> Term  {cons("MapExtend"), assoc}
    Term "\\" Term                      -> Term  {cons("MapUnbind"), assoc}
    ID "[" Term "]" "(" {Term ","}* ")" -> Term  {cons("SortFunCall")}

  context-free syntax
    CONTENTCOMPLETE -> Var   {cons("COMPLETION-Var")}
    CONTENTCOMPLETE -> Cast  {cons("COMPLETION-Cast")}
    CONTENTCOMPLETE -> List  {cons("COMPLETION-List")}
    CONTENTCOMPLETE -> Entry {cons("COMPLETION-Entry")}
    CONTENTCOMPLETE -> Term  {cons("COMPLETION-Term")}

  context-free priorities
    Term "[" Term "]" -> Term >
    Term "+" Term -> Term
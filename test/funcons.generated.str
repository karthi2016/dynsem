
module funcons.generated

signature
  constructors
    And: T * T -> T
    Cond: T * T * T -> T
    IsValue: T -> T
    True: T
    Seq: T * T -> T
    Print: T -> T
    Skip: T
    BoundValue: T -> T
    MapSelect: T * T -> T
    MapExtend: T * T -> T
    Map1: T * T -> T
    Env: T -> T
    Start: T
    Let: T * T * T -> T
    False: T
    Not: T -> T
    X: T
    MapExtend : T * T -> T
    MapSelect : T * T -> T
    MapEmpty : T
    Map1 : T * T -> T
    Bind : T * T -> T
    Fresh : T
    Exec : T -> T
    Exec1 : T -> T
    IsValue : T -> T       
    

rules // run-time library
  
  normalize :
    term -> term' 
    where term' := <innermost(norm)> term 
    
  exec :
    prog -> <eval> (<bottomup(n)>Exec(prog), [Env([])]) 
  
  norm:
    MapExtend(map1, map2) -> <conc> (map1, map2)
   

rules // built-ins
  
  n = try(norm)
	
  norm:
    MapEmpty() -> []
    
  norm:
    Map1(x,y) -> [Bind(x,y)]
        
  norm:
    MapSelect(key, map) -> value
    where <fetch(?Bind(key, value))> map  
    
  norm:
    Fresh() -> <new>
  
  /*
  The following rules should be somewhere:
  
  IsValue(x) = true
  -----------------
   Exec(x) --> x
	
  x --> y , Exec(x) --> y
  -----------------------
     Exec(x) --> y
  */
               
rules
  
  norm:       
    IsValue(True()) -> <n>True()
    where id
  
  norm:       
    IsValue(False()) -> <n>True()
    where id
  
  norm:       
    Not(True()) -> <n>False()
    where id
  
  norm:       
    Not(False()) -> <n>True()
    where id
  
  eval:       
    (And(x_1,x_2), [Env(env_1)]) -> (<n>And(x_1',x_2), [Print(print_2)])
    where debug(!"eval: "); 
          <eval>(x_1, [Env(env_1)]) => (x_1', [Print(print_2)]);
          id 
  
  eval:       
    (And(x_1,x_2), [Env(env_1)]) -> (<n>And(x_1,x_2'), [Print(print_2)])
    where debug(!"eval: "); 
          <eval>(x_2, [Env(env_1)]) => (x_2', [Print(print_2)]);
          id 
  
  norm:       
    And(True(),x) -> x
    where True() := <n>IsValue(<n>True()); 
          True() := <n>IsValue(x); 
          id
  
  norm:       
    And(False(),x) -> <n>False()
    where True() := <n>IsValue(<n>False()); 
          True() := <n>IsValue(x); 
          id
  
  eval:       
    (Cond(x_1,x_2,x_3), [Env(env_1)]) -> (<n>Cond(x_1',x_2,x_3), [Print(print_2)])
    where debug(!"eval: "); 
          <eval>(x_1, [Env(env_1)]) => (x_1', [Print(print_2)]);
          id 
  
  norm:       
    Cond(True(),x,y) -> x
    where True() := <n>IsValue(<n>True()); 
          id
  
  norm:       
    Cond(False(),x,y) -> y
    where True() := <n>IsValue(<n>False()); 
          id
  
  norm:       
    IsValue(Skip()) -> <n>True()
    where id
  
  eval:       
    (Seq(x_1,x_2), [Env(env_1)]) -> (<n>Seq(x_1',x_2), [Print(print_2)])
    where debug(!"eval: "); 
          <eval>(x_1, [Env(env_1)]) => (x_1', [Print(print_2)]);
          id 
  
  eval:       
    (Seq(x_1,x_2), [Env(env_1)]) -> (<n>Seq(x_1,x_2'), [Print(print_2)])
    where debug(!"eval: "); 
          True() := <n>IsValue(x_1); 
          <eval>(x_2, [Env(env_1)]) => (x_2', [Print(print_2)]);
          id 
  
  norm:       
    Seq(x,y) -> y
    where True() := <n>IsValue(x); 
          True() := <n>IsValue(y); 
          id
  
  eval:       
    (Print(x), [Env(env_1)]) -> (<n>Skip(), [Print(x)])
    where debug(!"eval: "); 
          id 
  
  eval:       
    (BoundValue(i), [Env(env_1)]) -> (<n>MapSelect(i,env), [Print([])])
    where debug(!"eval: "); 
          env := env_1;
           id 
  
  eval:       
    (Let(x_1,x_2,x_3), [Env(env_1)]) -> (<n>Let(x_1,x_2',x_3), [Print(print_2)])
    where debug(!"eval: "); 
          <eval>(x_2, [Env(env_1)]) => (x_2', [Print(print_2)]);
          id 
  
  eval:       
    (Let(i,val,body), [Env(env_1)]) -> (<n>Let(i,val,body'), [Print(print_2)])
    where debug(!"eval: "); 
          env := env_1;
           True() := <n>IsValue(val); 
           env1 := <n>MapExtend(env,<n>Map1(i,val)); 
           <eval>(body, [Env(env1)]) => (body', [Print(print_2)]);
           id 
  
  eval:       
    (Let(i,val,bodyval), [Env(env_1)]) -> (bodyval, [Print([])])
    where debug(!"eval: "); 
          True() := <n>IsValue(val); 
          True() := <n>IsValue(bodyval); 
          id 
  
  norm:       
    Start() -> <n>Let(<n>X(),<n>False(),<n>Not(<n>X()))
    where id
  


module funcons.generated

signature
  constructors
    Cond: T * T * T -> T
    cond: T * T * T -> T
    Seq: T * T -> T
    Print: T -> T
    Skip: T
    BoundValue: T -> T
    MapSelect: T * T -> T
    MapExtend: T * T -> T
    Map1: T * T -> T
    Env: T -> T
    IsValue: T -> T
    True: T
    Start: T
    Let: T * T * T -> T
    False: T
    Not: T -> T
    X: T
    MapExtend : T * T -> T
    MapSelect : T * T -> T
    MapEmpty : T
    Map1 : T * T -> T
    Bind : T * T -> T
    Fresh : T -> T
    Exec : T -> T
    Exec1 : T -> T
    IsValue : T -> T       
    

rules // run-time library
  
  normalize :
    term -> term' 
    where term' := <innermost(norm)> term 
    
  exec :
    prog -> <eval> (<bottomup(n)>Exec(prog), [Env([])]) 
  
  norm:
    MapExtend(map1, map2) -> <conc> (map1, map2)
   

rules // built-ins
  
  n = try(norm)
	
  norm:
    MapEmpty() -> []
    
  norm:
    Map1(x,y) -> [Bind(x,y)]
        
  norm:
    MapSelect(key, map) -> value
    where <fetch(?Bind(key, value))> map  
    
  norm:
    Fresh() -> <new>
  
  /*
  The following rules are generated from
  
  x = y , Exec1(y) --> z
  ----------------------
       Exec(x) --> z

  IsValue(y) = true
  -----------------
   Exec1(y) --> y
	
  y --> w , Exec(w) --> z
  -----------------------
     Exec1(y) --> z
  */
   /* 
  eval:       
    (Exec(x), []) -> (z, [])
    where <normalize>x => y; 
          <eval>(Exec1(y), []) => (z, []);
          id 

  eval:       
    (Exec1(y), []) -> (y, [])
    where <normalize>IsValue(y) => true; 
          id 

  eval:       
    (Exec1(y), []) -> (z, [])
    where <eval>(y, []) => (w, []);
          <eval>(Exec(w), []) => (z, []);
          id 
  */
               
rules
  
  norm:       
    IsValue(True()) -> <n>True()
    where id
  
  norm:       
    IsValue(False()) -> <n>True()
    where id
  
  norm:       
    Not(True()) -> <n>False()
    where id
  
  norm:       
    Not(False()) -> <n>True()
    where id
  
  eval:       
    (Cond(prop,x,y), [Env(env_1)]) -> (<n>Cond(prop',x,y), [Print(print_2)])
    where debug(!"eval: "); 
          <eval>(prop, [Env(env_1)]) => (prop', [Print(print_2)]);
          id 
  
  norm:       
    cond(True(),x,y) -> x
    where id
  
  norm:       
    cond(False(),x,y) -> y
    where id
  
  eval:       
    (Seq(comm,x), [Env(env_1)]) -> (<n>Seq(comm',x), [Print(print_2)])
    where debug(!"eval: "); 
          <eval>(comm, [Env(env_1)]) => (comm', [Print(print_2)]);
          id 
  
  norm:       
    IsValue(Skip()) -> <n>True()
    where id
  
  norm:       
    Seq(val,x) -> x
    where True() := <n>IsValue(val); 
          id
  
  eval:       
    (Print(x), [Env(env_1)]) -> (<n>Skip(), [Print(x)])
    where debug(!"eval: "); 
          id 
  
  eval:       
    (BoundValue(i), [Env(env_1)]) -> (<n>MapSelect(i,env), [Print([])])
    where debug(!"eval: "); 
          env := env_1;
           id 
  
  eval:       
    (Let(i,exp,body), [Env(env_1)]) -> (<n>Let(i,exp',body), [Print(print_2)])
    where debug(!"eval: "); 
          <eval>(exp, [Env(env_1)]) => (exp', [Print(print_2)]);
          id 
  
  eval:       
    (Let(i,val,body), [Env(env_1)]) -> (<n>Let(i,val,body'), [Print(print_2)])
    where debug(!"eval: "); 
          env := env_1;
           True() := <n>IsValue(val); 
           env1 := <n>MapExtend(env,<n>Map1(i,val)); 
           <eval>(body, [Env(env1)]) => (body', [Print(print_2)]);
           id 
  
  eval:       
    (Let(i,val,bodyval), [Env(env_1)]) -> (bodyval, [Print([])])
    where debug(!"eval: "); 
          True() := <n>IsValue(bodyval); 
          id 
  
  norm:       
    Start() -> <n>Let(<n>X(),<n>False(),<n>Not(<n>X()))
    where id
  

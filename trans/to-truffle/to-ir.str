module to-truffle/to-ir

imports
  libstratego-lib
  include/ds
  sugar
  strict
  lib-ds
  explicate
  factorize
  ds.pp.generated

signature
  constructors

    Function : ConsKind
    LangNode : ConsKind
    InterNode: ConsKind
    Implicit : ConsKind
    
    Element : ConsKind * String * Integer * List(Logic) -> Element
  
    // Rule : envname * statename * inputvar * prems * outvar * statename
    Rule  :   String * String * List(String) * List(Premise) * String * String -> Logic
    // Func : inputvar * prems * outvar
    Func  :   List(String) * List(Premise) * String                            -> Logic

    Assign:   String * PremisePart             -> Premise
    Match :   String * List(PremisePart)       -> Premise
    Call  :   String * Integer * List(PremisePart) -> PremisePart
    
    // Reduc: envname * statename * inputvar * outvar * outstate
    Reduc :   String * String * String * String * String -> Rule
    	    
    String:   String                           -> PremisePart
    Var   :   String                           -> PremisePart
    Fresh :                                       PremisePart
    
    List  :   List(String)                     -> PremisePart
    ListTail: List(String) * String            -> PremisePart
    
    MapEmpty:                                     PremisePart
    MapExtend: PremisePart * PremisePart       -> PremisePart
    MapSelect: PremisePart * PremisePart       -> PremisePart
    
    
rules
  
  to-ir:
    mod -> ir
    with
      <unstrict-rules; factorize-rules; unstrict-rules; desugar-all; explicate-rules; alltd(escape-variable)> mod;
      gather-constructors;
      rules-to-ir;
      ?ir

rules // gather constructors and their usage
    
  gather-constructors =
    collect(?Rules(<id>));
    collect-all(gather-constructor);
    implode-constructors;
    filter(not(element-is-builtin-function))

  gather-constructor:
    Con(name, args) -> Element(conskind, name, arity, [])
    with
      arity := <length> args
    where
      if <is-language-node> (name, arity) then
        conskind := LangNode()
      else
        conskind := Implicit()
      end
  
  gather-constructor:
    r@Rule(_, _, TermEq(Con(name, args), _)) -> Element(Function(), name, arity, [r])
    with
      arity := <length> args
  
  gather-constructor:
    r@Rule(_, _, Relation(_, Source(Con(name, args), _), _, _)) -> Element(LangNode(), name, arity, [r])
    with
      arity := <length> args
    where
      <is-language-node> (name, arity)
  
  gather-constructor:
    r@Rule(_, _, Relation(_, Source(Con(name, args), _), _, _)) -> Element(InterNode(), name, arity, [r])
    with
      arity := <length> args
    where
      <not(is-language-node)> (name, arity)

  implode-constructors = implode-constructors(|[])
  
  implode-constructors(|acc):
    [] -> acc
  
  implode-constructors(|acc):
    [Element(nodetype, name, arity, r*) | xs ] -> <implode-constructors(|[elem | acc'])> xs
    where
      <fetch-constructor(|name, arity)> acc => e@Element(nodetype', name, arity, r'*)
    with
      acc' := <filter(not(?e))> acc;
      nodetype'' := <nodetype-propagate> (nodetype, nodetype');
      elem := Element(nodetype'', name, arity, [r*, r'*])
  
  implode-constructors(|acc):
    [e@Element(_, name, arity, _) | xs ] -> <implode-constructors(|[e | acc])> xs
    where
      <not(fetch-constructor(|name, arity))> acc

  fetch-constructor(|name, arity) = fetch-elem(?Element(_, name, arity, t4))
  
  nodetype-propagate:
    (ty, ty) -> ty
  
  nodetype-propagate:
    (Implicit(), ty) -> ty
  

rules
  
  rules-to-ir = ?elements; map(Element(id, id, id, map(rule-to-ir(|elements))))

  in-tuple-conc:
    ((a*, b*), (a'*, b'*)) -> ([a'*, a*], [b'*, b*])

  // functions
  rule-to-ir(|elements):
    Rule(prem*, _, TermEq(Con(_, args), rhs)) -> Func(invar*, prem''*, outvar)
    with
      <foldr(!([],[]), in-tuple-conc , lift-pattern-to-var)> args => (p1*, invar*);
      <lift-pattern-to-var> rhs => (p2*, [outvar]);
      prem'* := <map(?Formula(<id>))> prem*;
      prem''* := <premises-to-ir(|elements)> [p1*, prem'*, p2*]

  // rules
  rule-to-ir(|elements):
    Rule(prem*, _, Relation(Reads(r*), Source(Con(_, args), sc*), _, Target(rhs, tc*))) ->
      Rule(env, sin, invar*, prem''*, outvar, sout)
      with
        <foldr(!([],[]), in-tuple-conc , lift-pattern-to-var)> args => (p1*, invar*);
        env := <get-read-mapvar> r*;
        <lift-pattern-to-var> rhs => (p2*, [outvar]);
        prem'* := <map(?Formula(<id>))> prem*;
        prem''* := <premises-to-ir(|elements)> [p1*, prem'*, p2*];
        sin := <get-read-mapvar> sc*;
        sout := <get-read-mapvar> tc*
  
  lift-pattern-to-var:
    Var(x) -> ([], [x])
  
  lift-pattern-to-var:
    con -> ([TermEq(Var(var-name), con)], [var-name])
    where
      <not(?Var(_))> con
    with
      var-name := <new>
      
  get-read-mapvar = ?[LabelComp(_, Var(<id>))]
    
rules

  premises-to-ir(|elements) = 
    map(innermost(premise-to-ir(|elements) + premisepart-to-ir(|elements)));
    try(flatten-list)
  
  premise-to-ir(|elements):
    TermEq(lhs, Var(v)) -> Assign(v, lhs)
  
  premise-to-ir(|elements):
    TermEq(Var(v), rhs) -> Match(v, rhs)
  
  // Reduc: envname * statename * inputvar * outvar * outstate
  premise-to-ir(|elements):
    Relation(Reads(r*), Source(lhs, sc*), _, Target(rhs, tc*)) -> [ p1*, Reduc(ein, sin, invar, outvar, sout), p2*]
    with
      ein := <get-read-mapvar> r*;
      sin := <get-read-mapvar> sc*;
      sout := <get-read-mapvar> tc*;
      <lift-pattern-to-var> lhs => (p1*, [invar]);
      <lift-pattern-to-var> rhs => (p2*, [outvar])
    
  premisepart-to-ir(|elements):
    Con(name, args) -> Call(name, arity, args)
    with
      arity := <length> args
    where  
      <element-get-w-kind(|name, <length> args, Function())> elements

rules
  
  escape-variable:
    Var(v) -> Var($[_[v']])
    with
      v' := <string-replace(|"'", "_$p$_")> v

rules // Element store querying
  
  element-get(|name, arity) = fetch-elem(?Element(_, name, arity, _))
  
  element-get-w-kind(|name, arity, kind) = element-get(|name, arity); ?Element(kind, _, _, _)


rules // built ins

  constructor-is-builtin-function = <elem> (<id>, <builtin-functions>)
  
  element-is-builtin-function:
    Element(_, name, arity, _) -> <elem> ((name, arity), <builtin-functions>)

  builtin-functions = ![("Fresh", 0), ("MapEmpty", 0), ("MapExtend", 2), ("MapSelect", 2)]
    
rules // FJ specifics

  is-language-node = <elem> (<id>, <language-nodes>)

  language-nodes = 
    ![("Cast", 2),
    ("New", 2),
    ("MethCall", 3),
    ("FieldRef", 2),
    ("Var", 1),
    ("Param", 2),
    ("Method", 4),
    ("FieldInit", 2),
    ("SuperCall", 1),
    ("Constructor", 4),
    ("Void", 0),
    ("ClassType", 1),
    ("Field", 2),
    ("Super", 1),
    ("Class", 5),
    ("Program", 2)]
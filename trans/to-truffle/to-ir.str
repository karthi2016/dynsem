module to-truffle/to-ir

imports
  libstratego-lib
  include/ds
  sugar
  strict
  lib-ds
  explicate
  factorize
  ds.pp.generated

signature
  constructors

    Function : ConsKind
    LangNode : ConsKind
    InterNode: ConsKind
    Implicit : ConsKind
    
    Element : ConsKind * String * Integer * List(Logic) -> Element
  
    // Rule : envname * statename * inputvar * prems * outvar * statename
    Rule  :   String * String * List(String) * List(Premise) * String * String -> Logic
    // Func : inputvar * prems * outvar
    Func  :   List(String) * List(Premise) * String                            -> Logic

    Assign:   String * PremisePart             -> Premise
    Match :   String * List(PremisePart)       -> Premise
    Call  :   String * Integer * List(PremisePart) -> PremisePart
    Reduc :   String * String * String * String * String -> Rule
    	    
    String:   String                           -> PremisePart
    Var   :   String                           -> PremisePart
    Fresh :                                       PremisePart
    
    List  :   List(String)                     -> PremisePart
    ListTail: List(String) * String            -> PremisePart
    
    MapEmpty:                                     PremisePart
    MapExtend: PremisePart * PremisePart       -> PremisePart
    MapSelect: PremisePart * PremisePart       -> PremisePart
    
    
rules
  
  to-ir:
    mod -> ir
    with
      <unstrict-rules; factorize-rules; unstrict-rules; desugar-all; explicate-rules; alltd(escape-variable)> mod;
      gather-constructors;
      rules-to-ir;
      ?ir

rules // gather constructors and their usage
    
  gather-constructors =
    collect(?Rules(<id>));
    collect-all(gather-constructor);
    implode-constructors

  gather-constructor:
    Con(name, args) -> Element(conskind, name, arity, [])
    with
      arity := <length> args
    where
      if <is-language-node> (name, arity) then
        conskind := LangNode()
      else
        conskind := Implicit()
      end
  
  gather-constructor:
    r@Rule(_, _, TermEq(Con(name, args), _)) -> Element(Function(), name, arity, [r])
    with
      arity := <length> args
  
  gather-constructor:
    r@Rule(_, _, Relation(_, Source(Con(name, args), _), _, _)) -> Element(LangNode(), name, arity, [r])
    with
      arity := <length> args
    where
      <is-language-node> (name, arity)
  
  gather-constructor:
    r@Rule(_, _, Relation(_, Source(Con(name, args), _), _, _)) -> Element(InterNode(), name, arity, [r])
    with
      arity := <length> args
    where
      <not(is-language-node)> (name, arity)

  implode-constructors = implode-constructors(|[])
  
  implode-constructors(|acc):
    [] -> acc
  
  implode-constructors(|acc):
    [Element(nodetype, name, arity, r*) | xs ] -> <implode-constructors(|[elem | acc'])> xs
    where
      <fetch-constructor(|name, arity)> acc => e@Element(nodetype', name, arity, r'*)
    with
      acc' := <filter(not(?e))> acc;
      nodetype'' := <nodetype-propagate> (nodetype, nodetype');
      elem := Element(nodetype'', name, arity, [r*, r'*])
  
  implode-constructors(|acc):
    [e@Element(_, name, arity, _) | xs ] -> <implode-constructors(|[e | acc])> xs
    where
      <not(fetch-constructor(|name, arity))> acc

  fetch-constructor(|name, arity) = fetch-elem(?Element(_, name, arity, t4))
  
  nodetype-propagate:
    (ty, ty) -> ty
  
  nodetype-propagate:
    (Implicit(), ty) -> ty
  

rules
  
  rules-to-ir = ?elements; map(elem-to-ir(|elements))

  elem-to-ir(|elements) = Element(id, id, id, map(rule-to-ir(|elements)))

  // functions
  rule-to-ir(|elements):
    Rule(prem*, _, TermEq(Con(_, args), rhs)) -> Func(invar*, prem'*, outvar)
    with
      invar* := <map(?Var(<id>))> args;
      <lift-pattern-to-var> rhs => (p2*, outvar);
      prem'* := <premises-to-ir(|elements)> [prem*, p2*]

  rule-to-ir(|elements):
    Rule(prem*, _, Relation(Reads(r*), Source(Con(_, args), sc*), _, Target(Var(outvar), tc*))) ->
      Rule(env, sin, invar*, prem'*, outvar, sout)
      with
        invar* := <map(?Var(<id>))> args;
        !r* => [LabelComp(_, Var(env))];
        prem'* := <premises-to-ir(|elements)> prem*;
        !sc* => [LabelComp(_, Var(sin))];
        !tc* => [LabelComp(_, Var(sout))]
        
  lift-pattern-to-var:
    Var(x) -> ([], x)
  
  lift-pattern-to-var:
    con -> ([Formula(TermEq(Var(var-name), con))], var-name)
    where
      <not(?Con(_, _))> con
    with
      var-name := <new>

rules

  premises-to-ir(|elements) = map(?Formula(<premise-to-ir(|elements)>))
  
  //   Assign:   String * PremisePart             -> Premise
  //   Match :   String * List(PremisePart)       -> Premise
  //   Call  :   String * Integer * List(PremisePart) -> PremisePart
  //   Reduc :   String * String * String * String * String -> Rule
  //         
  //   String:   String                           -> PremisePart
  //   Var   :   String                           -> PremisePart
  //   Fresh :                                       PremisePart
  //   
  //   List  :   List(String)                     -> PremisePart
  //   ListTail: List(String) * String            -> PremisePart
  //   
  //   MapEmpty:                                     PremisePart
  //   MapExtend: PremisePart * PremisePart       -> PremisePart
  //   MapSelect: PremisePart * PremisePart       -> PremisePart
  
  
  premise-to-ir(|elements):
    TermEq(lhs, Var(v)) -> Assign(v, <premise-part-to-ir(|elements)> lhs)
  
  premise-part-to-ir(|elements) = ?Var(_)
  
  premise-part-to-ir(|elements):
    Con(name, args) -> <fail>
  
  premise-to-ir(|elements) = id

rules
  
  escape-variable:
    Var(v) -> Var($[_[v']])
    with
      v' := <string-replace(|"'", "_$p$_")> v

rules // FJ specifics

  is-language-node = <elem> (<id>, <language-nodes>)

  language-nodes = 
    ![("Cast", 2),
    ("New", 2),
    ("MethCall", 3),
    ("FieldRef", 2),
    ("Var", 1),
    ("Param", 2),
    ("Method", 4),
    ("FieldInit", 2),
    ("SuperCall", 1),
    ("Constructor", 4),
    ("Void", 0),
    ("ClassType", 1),
    ("Field", 2),
    ("Super", 1),
    ("Class", 5),
    ("Program", 2)]
module explicate

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/ds
  lib/editor-common.generated
  sugar
  lib-ds
  ds
  
strategies
  
  explicate-module :
    mod@Module(name, section*) -> Module($[[name]_explicated], [section'*, section''*])
    where
      rule-name* := <collect-all(?ArrowDecl(_, <id>, _)); make-set> section*;
      rule-group* := <filter(?Rules(<id>)); concat; group-rules(|rule-name*)> section*;
    	rule-group'* := <map(in-extracted-components(map(try(explicate-rules))))> rule-group*;
    	section'* := <filter(not(?Rules(_)))> section*;
      section''* := <map(!Rules(<id>))> rule-group'*
      
  explicate-rules :
    rs -> <alltd(explicate-rule)> rs

rules // group rules by name
  
  group-rules(|rule-name*):
    [] -> <map(![])> rule-name*

  group-rules(|rule-name*):
    [r | rxs] -> grouped-r*
    with
      debug(!1);
      grouped-rxs* := <group-rules(|rule-name*)> rxs;
      debug(!2);
      r-name := <debug(!"2a "); get-rule-name> r;
      debug(!3);
      r-idx := <get-index; dec> (r-name, rule-name*);
      debug(!4);
      grouped-r* := <at-index(\ xs -> [r | xs] \)> (r-idx, grouped-rxs*)
      ; debug(!5)

  get-rule-name :
  	Rule(_, _, Relation(_, _, NamedDynamicEmitted(arrow, _), _))  -> arrow
  
rules
  
  explicate-rule :
    Rule(prem1*, infer, Relation(Reads(r1*), Source(lhs, sc1*), NamedDynamicEmitted(arrow, e1*), Target(rhs, tc1*))) ->   
    Rule(prem3*, infer, Relation(Reads(r2*), Source(lhs, sc2*), NamedDynamicEmitted(arrow, e2*), Target(rhs, tc2*)))
    where
      r2* := <ReadableComps; mk-label-comps(|1)>;
      sc2* := <ChangeableComps; mk-label-comps(|1)>;
      init* := <exp-label-comp-inits(|1)> [r1*, sc1*];
      (num, prem2*) := <explicate-premisses(|1)> prem1*;
      e2* := <WritableComps; map(copy-comp(|e1*) <+ concat-changeables(|num))>;  
      tc2* := <ChangeableComps; map(mk-label-comp(copy-comp(|tc1*)|num))>;  
      prem3* := [init* | prem2*]
  
rules // components from lhs

  exp-label-comp-inits(|num) = 
    map(exp-label-comp-init(|num))
  
  exp-label-comp-init(|num):
    LabelComp(name, t) -> Formula(Match(Var(<get-sort-name; comp-var(|num)> name), t))
 
rules // components in rhs
           
  copy-comp(|comps) :
    comp-name -> <fetch-elem(?LabelComp(comp-name,_))> comps
      
  concat-changeables(|num) :
    comp-name -> LabelComp(comp-name, Con("Concat", [List(<range; map(\i -> Var(<comp-var(|i)>comp-name) \)>(2, <inc>num))]))
    where <gt> (num, 2)

  concat-changeables(|num) :
    comp-name -> LabelComp(comp-name, Var(<comp-var(|2)>comp-name))
    where <eq> (num, 2)

  concat-changeables(|num) :
    comp-name -> LabelComp(comp-name, List([]))
    where <eq> (num, 1)
    
rules // premisses
                        
  explicate-premisses(|num) :
    [] -> (num, [])
        
  explicate-premisses(|num1):
    [prem1 | prem1*] -> (num3, [prem2*, prem3*])
    where
      (num2, prem2*) := <explicate-premisse(|num1)> prem1;
      (num3, prem3*) := <explicate-premisses(|num2)> prem1*
  
  explicate-premisse(|num):
    f@AllFail() -> (num, [f])
  
  explicate-premisse(|num):
    form@Formula(Match(lhs, rhs)) -> (num, [form])
  
  explicate-premisse(|num):
    form@Formula(TermEq(lhs, rhs)) -> (num, [form])
  
  explicate-premisse(|num):
    form@Formula(TermNeq(lhs, rhs)) -> (num, [form])
    
  explicate-premisse(|num-prev) :
    Formula(Relation(Reads(r1*), Source(lhs, sc1*), NamedDynamicEmitted(arrow, e1*), Target(rhs, tc1*))) -> 
    (num-next, 
      [Formula(Relation(Reads(r2*), Source(lhs, sc2*), NamedDynamicEmitted(arrow, e2*), Target(rhs, tc2*))) | init*])
    where
      num-next := <inc> num-prev;
    	if <?[]> r1* then
        r2*   := <ReadableComps;   map(mk-label-comp(\ comp -> <fetch-elem(?LabelComp(comp,_))> r1* \|1))>
      else
        r2*   := r1*
      end;  
      sc2*  := <ChangeableComps; map(mk-label-comp(\ comp -> <fetch-elem(?LabelComp(comp,_))> sc1* \|num-prev))>;
      e2*   := <WritableComps; mk-label-comps(|num-next)>;
      tc2*  := <ChangeableComps; mk-label-comps(|num-next)>;
      init* := <exp-label-comp-inits(|num-next)> [e1*, tc1*]
        

      
      
module explicate

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/ds
  lib/editor-common.generated
  sugar
  lib-ds
  ds
  
strategies
  
  explicate-module :
    mod@Module(name, section*) -> Module(name, section'*) 
    where
      <extract-writables> mod;
      <extract-readables> mod;
      <extract-changeables> mod;
      section'* := <map(try(explicate-rules))> section*
                
  // explicate-rules assumes rules to be desugared
  
  explicate-rules :
    rs -> <alltd(explicate-rule)> rs

rules
  
  explicate-rule :
    Rule(prem1*, infer, Relation(Reads(r1*), Source(lhs, sc1*), DynamicEmitted(e1*), Target(rhs, tc1*))) ->   
    Rule(prem3*, infer, Relation(Reads(r2*), Source(lhs, sc2*), DynamicEmitted(e2*), Target(rhs, tc2*)))
    where 
      r2* := <ReadableComps; mk-label-comps(|1)>;
      sc2* := <ChangeableComps; mk-label-comps(|1)>;
      init* := <exp-label-comp-inits(|1)> [r1*, sc1*]; 
      (num, prem2*) := <explicate-premisses(|1)> prem1*;
      e2* := <WritableComps; map(copy-comp(|e1*) <+ concat-changeables(|num))>;  
      tc2* := <ChangeableComps; map(mk-label-comp(copy-comp(|tc1*)|num))>;  
      prem3* := [init* | prem2*]

rules // components from lhs

  exp-label-comp-inits(|num) = 
    map(exp-label-comp-init(|num))
  
  exp-label-comp-init(|num):
    LabelComp(name, t) -> Formula(TermEq(Var(<comp-var(|num)> name), t))
 
rules // components in rhs
           
  copy-comp(|comps) :
    comp-name -> <fetch-elem(?LabelComp(comp-name,_))> comps
      
  concat-changeables(|num) :
    comp-name -> LabelComp(comp-name, Con("Concat", [List(<range; map(\i -> Var(<comp-var(|i)>comp-name) \)>(2, <inc>num))]))
    where <gt> (num, 2)

  concat-changeables(|num) :
    comp-name -> LabelComp(comp-name, Var(<comp-var(|2)>comp-name))
    where <eq> (num, 2)

  concat-changeables(|num) :
    comp-name -> LabelComp(comp-name, List([]))
    where <eq> (num, 1)
    
rules // premisses
                        
  explicate-premisses(|num) :
    [] -> (num, [])
        
  explicate-premisses(|num1):
    [prem1 | prem1*] -> (num3, [prem2*, prem3*])
    where (num2, prem2*) := <explicate-premisse(|num1)> prem1;
          (num3, prem3*) := <explicate-premisses(|num2)> prem1*
                   
  explicate-premisse(|num):
    form@Formula(TermEq(lhs, rhs)) -> (num, [form])
  
  explicate-premisse(|num):
    form@Formula(TermNeq(lhs, rhs)) -> (num, [form])
    
  explicate-premisse(|num-prev) :
    Formula(Relation(Reads(r1*), Source(lhs, sc1*), DynamicEmitted(e1*), Target(rhs, tc1*))) -> 
    (num-next, 
      [Formula(Relation(Reads(r2*), Source(lhs, sc2*), DynamicEmitted(e2*), Target(rhs, tc2*))) | init*])
    where
      num-next := <inc>num-prev;
      r2*   := <ReadableComps;   map(mk-label-comp(\ comp -> <fetch-elem(?LabelComp(comp,_))> r1* \|1))>;  
      sc2*  := <ChangeableComps; map(mk-label-comp(\ comp -> <fetch-elem(?LabelComp(comp,_))> sc1* \|num-prev))>;
      e2*   := <WritableComps; mk-label-comps(|num-next)>;
      tc2*  := <ChangeableComps; mk-label-comps(|num-next)>;
      init* := <exp-label-comp-inits(|num-next)> [e1*, tc1*]
        
 
                                                           

      
      
module explicate

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/ds
  lib/editor-common.generated
  sugar
  lib-ds
  
strategies
  
  // explicate-rules assumes rules to be desugared
  
  explicate-rules :
    rs -> <alltd(explicate-rule)> rs
    where <extract-components> rs

rules
  
  explicate-rule :
    Rule(prem1*, infer, Relation(Reads(r1*), Source(lhs, sc1*), DynamicEmitted(e1*), Target(rhs, tc1*))) ->   
    Rule(prem3*, infer, Relation(Reads(r2*), Source(lhs, sc2*), DynamicEmitted(e2*), Target(rhs, tc2*)))
    where 
      r2* := <ReadableComps; mk-label-comps(|1)>;
      sc2* := <ChangeableComps; mk-label-comps(|1)>;
      init* := <exp-label-comp-inits(|1)> [r1*, sc1*]; 
      (num, prem2*) := <explicate-premises(|1)> prem1*;
      e2* := <WritableComps; map(copy-comp(|e1*) <+ concat-changeables(|num))>;  
      tc2* := <ChangeableComps; map(mk-label-comp(copy-comp(|tc1*)|num))>;  
      prem3* := [init* | prem2*]

rules // components from lhs

  exp-label-comp-inits(|num) = 
    map(exp-label-comp-init(|num))
  
  exp-label-comp-init(|num) :
    LabelComp(name, t) -> TermEq(Var(<comp-var(|num)> name), t)
 
rules // components in rhs
           
  concat-changeables(|num) :
    comp-name -> LabelComp(comp-name, Con("Concat", [List(<range; map(\i -> Var(<comp-var(|i)>comp-name) \)>(2, <inc>num))]))
    where <gt> (num, 2)

  concat-changeables(|num) :
    comp-name -> LabelComp(comp-name, Var(<comp-var(|2)>comp-name))
    where <eq> (num, 2)

  concat-changeables(|num) :
    comp-name -> LabelComp(comp-name, List([]))
    where <eq> (num, 1)
    
rules // premises
                        
  explicate-premises(|num) :
    [] -> (num, [])
        
  explicate-premises(|num1) :
    [prem1 | prem1*] -> (num3, [prem2*, prem3*])
    where (num2, prem2*) := <explicate-premise(|num1)> prem1;
          (num3, prem3*) := <explicate-premises(|num2)> prem1*
                   
  explicate-premise(|num) :
    form@TermEq(lhs, rhs) -> (num, [form])
    
  explicate-premise(|num-prev) :
    Relation(Reads(r1*), Source(lhs, sc1*), DynamicEmitted(e1*), Target(rhs, tc1*)) -> 
    (num-next, 
      [Relation(Reads(r2*), Source(lhs, sc2*), DynamicEmitted(e2*), Target(rhs, tc2*)) | init*])
    where
      num-next := <inc>num-prev;
      r2*   := <ReadableComps;   map(mk-label-comp(copy-comp(|r1*)|1))>;  
      sc2*  := <ChangeableComps; map(mk-label-comp(copy-comp(|sc1*)|num-prev))>;
      e2*   := <WritableComps; mk-label-comps(|num-next)>;
      tc2*  := <ChangeableComps; mk-label-comps(|num-next)>;
      init* := <exp-label-comp-inits(|num-next)> [e1*, tc1*]

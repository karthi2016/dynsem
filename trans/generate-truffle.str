module generate-truffle

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/ds
  lib/editor-common.generated
  refocus
  sugar
  strict
  lib-ds
  explicate
  factorize
  ds.pp.generated
  
signature constructors
	
	Node : T
	Root : T
	Func : T

rules
	
  /*
  
  1. every term T/n from the interpreter language becomes a class T_n.java extends DynsemNode
  2. every term T/n that is not part of the language and is not a function becomes a T_n.java extends RootNode 
  3. every function (things that are only norm) becomes a function in truffle
  
  */

  to-truffle:
    rs -> <concat-strings> truffle
    where
      rs' := <unstrict-rules; factorize-rules; unstrict-rules; desugar-all; explicate-rules> rs;
      <extract-components> rs';
      rule-store := <new-hashtable>;
      // group the rules by matching constructor
      <fill-rule-store(|rule-store)> rs';
      truffle := <to-truffle-impl(|rule-store)>
  
  fill-rule-store(|store) =
    ?ast;
  	collect(?Rules(<id>));
  	concat;
  	filter(gather-constructor; store-constructor(|store));
  	!ast;
  	collect-all(gather-implicit-constructor; store-constructor(|store))
  	
  
  store-constructor(|store) =
  	?(name, arity, ty, r*);
		<hashtable-get(|(name, arity))> store => (ty, rs*);
		<hashtable-put(|(name, arity), (ty, [r*, rs*]))> store
  
  store-constructor(|store) = 
  	?(name, arity, ty, r*);
  	<not(hashtable-get(|(name, arity)))> store;
  	<hashtable-put(|(name, arity), (ty, r*))> store
  
  gather-implicit-constructor:
    Con(name, args) -> (name, <length> args, Node(), [])
  
  // functions
  gather-constructor:
  	r@Rule(_, _, TermEq(Con(name, args), _)) -> (name, arity, Func(), [r])
  	with
  		arity := <length> args
  
  // nodes & rootnodes
  gather-constructor:
  	r@Rule(_, _, Relation(_, Source(Con(name, args), _), _, _)) -> (name, arity, nodetype, [r])
  	with
  	  arity := <length> args;
  	  if <is-language-node> (name, arity) then
  	    nodetype := Node()
  	  else
  	    nodetype := Root()
  	  end
  
  is-language-node =
    ?("Cast", 2) +
    ?("New", 2) +
    ?("MethCall", 3) +
    ?("FieldRef", 2) +
    ?("Var", 1) +
    ?("Param", 2) +
    ?("Method", 4) +
    ?("FieldInit", 2) +
    ?("SuperCall", 1) +
    ?("Constructor", 4) +
    ?("Void", 0) +
    ?("ClassType", 1) +
    ?("Field", 2) +
    ?("Super", 1) +
    ?("Class", 5) +
    ?("Program", 2)

  is-builtin-function = 
    ?("MapExtend", 2) +
    ?("MapSelect", 2) +
    ?("Fresh", 0)
  
  is-builtin-node =
    ?("Skip", 0) +
    ?("Cons", 2) +
    ?("Nil", 0)
  
  is-con-function(|store) =
    ?(name, arity);
    <hashtable-get(|(name, arity))> store => (Func(), _)
  
  is-con-rootnode(|store) = 
    ?(name, arity);
    <hashtable-get(|(name, arity))> store => (Root(), _)
  
  is-con-node(|store) = 
    ?(name, arity);
    <hashtable-get(|(name, arity))> store => (Node(), _)
  
rules
  
  to-truffle-impl(|store) =
    <hashtable-keys> store;
    filter(not(is-builtin-node + is-builtin-function));
    map(to-truffle-dynsem-node(|store) <+ to-truffle-dynsem-function(|store))
  
  to-truffle-dynsem-function(|store):
    (name, arity) -> $[
					package org.metaborg.truffle.fj.dynsem.manual.functions;
					
					import org.metaborg.truffle.dynsem.shared.functions.*;
					import org.metaborg.truffle.dynsem.shared.nodes.*;
					import org.metaborg.truffle.dynsem.shared.runtime.*;
					
					public class [name]_[arity] {
					
					    public static Object apply([<separate-by(|","); concat-strings> apply-pars]) {
					        [alterns]
					    }
					    
					    [applydefs]
					}]
    where
      <hashtable-get(|(name, arity))> store => (Func(), rs)
    with
      index-seq   := <mk-sequence> (1, <inc> arity);
      apply-pars  := <map(\ idx -> $[Object _[idx]] \)> index-seq;
      invoke-args := <map(\ idx -> $[_[idx]] \); separate-by(|","); concat-strings> index-seq;
      invoc-seq   := <mk-sequence> (1, <length> rs);
      if <?[]> invoc-seq then
        alterns := $[throw new Error("Cannot execute function [name]_[arity]");]
      else
	      [inv|invxs] := <map(\ idx -> $[return apply_[idx]([invoke-args]);] \); reverse> invoc-seq;
	      if <?[]> invxs then
	        alterns := <to-catch-rethrow> inv
	      else
	        alterns := <foldl(to-catch-stm)> (invxs, <to-catch-rethrow> inv)
	      end
      end;
      applydefs := <map-with-index(function-to-truffle(|store, apply-pars))> rs

  to-truffle-dynsem-node(|store):
    (name, arity) -> $[
						package org.metaborg.truffle.fj.dynsem.manual.eval;
						
						import org.metaborg.truffle.dynsem.shared.nodes.*;
						import org.metaborg.truffle.dynsem.shared.runtime.*;
						
						import com.oracle.truffle.api.frame.*;
						
						public class [name]_[arity] extends [super-class] {
						
						    [<separate-by(|"\n"); concat-strings> fields]
						
						    public [name]_[arity]([<separate-by(|","); concat-strings> const-pars]) {
						        super();
						        [<separate-by(|"\n"); concat-strings> field-init]
						    }
						
						    [<separate-by(|"\n"); concat-strings> field-gets]
						
						    @Override
						    public Result execute(VirtualFrame frame) {
						        [alterns]
						    }
						
						}]
	  where
	    <hashtable-get(|(name, arity))> store => (nodety, rs);
	    <?Node() + ?Root()> nodety
		with
		  if <?Node()> nodety then
		    super-class := "DynsemNode"
		  else
		    super-class := "RootNode"
		  end;
		  index-seq  := <mk-sequence> (1, <inc> arity);
		  fields     := <map(\ idx -> $[@Child protected DynsemNode _[idx];] \)> index-seq;
		  const-pars := <map(\ idx -> $[DynsemNode _[idx]] \)> index-seq;
		  field-init := <map(\ idx -> $[this._[idx] = adoptChild(_[idx]);] \)> index-seq;
		  field-gets := <map(\ idx -> $[public DynsemNode _[idx](){ return _[idx]; } ] \)> index-seq;
		  invoc-seq   := <mk-sequence> (1, <length> rs);
      if <?[]> invoc-seq then
        alterns := $[throw new Error("Cannot execute node [name]_[arity]");]
      else
			  [inv|invxs] := <map(\ idx -> $[return apply_[idx](frame);] \); reverse> invoc-seq;
			  if <?[]> invxs then
	        alterns := <to-catch-rethrow> inv
	      else
	        alterns := <foldl(to-catch-stm)> (invxs, <to-catch-rethrow> inv)
	      end
	    end
      
  to-catch-stm:
    (stm1, stm2) -> $[
      try {
        [stm1]
      }catch(Exception [ex-var]) {
        [stm2]
      }]
    with
      ex-var := <newname> "e"
  
  to-catch-rethrow:
    stm -> $[
      try {
        [stm]
      }catch(Exception [ex-var]) {
        throw [ex-var];
      }]
    with
      ex-var := <newname> "e"

  function-to-truffle(|store, params):
    (idx, Rule(prem*, _, TermEq(Con(name, args), res)) ) -> $[
      public static Object apply_[idx](params) {
        // allocate correctly named variables
        [<separate-by(|"\n"); concat-strings> named-vars]
        // evaluate the premises
        // return the result
      }]
    where
      <debug(!"Genfunc: ")> (idx, name, args);
      named-vars := <map-with-index(\ (idx, Var(v)) -> $[Object v = _[idx];] \)> args

  // TermEq(
  //     Var("m_585915")
  //   , Con("Cons", [Var("o_585915"), Var("methods")])
  //   )
  // , TermEq(
  //     Var("o_585915")
  //   , Con(
  //       "Method"
  //     , [Var("t"), Var("name"), Var("params"), Var("e")]
  //     )
  //   )
  // , TermEq(Con("Methods2Env", [Var("methods")]), Var("p_585915"))
    


rules
  
  mk-sequence = 
    ?(from, to);
    if <gt> (from, to) then
      ![]
    else
      ![from | <mk-sequence> (<inc> from, to) ]
    end
          
//  
//        
// rules // translate rules
//    
//   translate-rules =
//     collect(?Rules(<id>)); 
//     concat; 
//     filter(translate-rule);
//     concat-strings
//     
//   translate-rule :
//     Rule(prem*, _, TermEq(lhs, rhs)) -> $[
//       norm:       
//         [<pp-term>lhs] -> [<pp-term-norm> rhs]
//         [<translate-premises> prem*]]
//      
//   translate-premises =
//     if ?[] then !"" 
//     else 
//       !$[where 
//            [<map(translate-premise); separate-by(|";\n"); concat-strings>]
//         ]
//     end
//     
//   translate-premise :
//     TermEq(lhs, rhs) -> $[[<pp-term>rhs] := [<pp-term-norm>lhs]]
//   
// rules // translate dynamic
// 
//   translate-rule :
//     Rule(prem*, _, Relation(Reads(r*), Source(lhs, sc*), DynamicEmitted(e*), Target(rhs, tc*))) -> $[
//       eval:       
//         ([<pp-term>lhs], [comps-lhs]) -> <debug(!"  to [<next-counter>"r"]: ")>([<pp-term-norm> rhs], [comps-rhs])
//         where debug(!"eval [<get-counter>"r"]: ")
//         [<translate-premises> prem*] 
//     ]
//     with 
//       nonwr* := <conc>(r*, sc*); 
//       comps-lhs := <NonWriteables; map(copy-comp(|nonwr*)); pp-comps>; 
//       nonr* := <conc>(e*, tc*);
//       comps-rhs := <NonReadables; map(copy-comp(|nonr*)); pp-comps-norm>
//                
//   translate-premise :
//     Relation(Reads(r*), Source(lhs, sc*), DynamicEmitted(e*), Target(rhs, tc*)) -> 
//     $[<eval>([<pp-term-norm>lhs], [comps-lhs]) => ([<pp-term> rhs], [comps-rhs])]
//     with      
//       nonwr* := <conc>(r*, sc*);
//       comps-lhs := <NonWriteables; map(copy-comp(|nonwr*)); pp-comps-norm> ;         
//       nonr* := <conc>(e*, tc*);
//       comps-rhs := <NonReadables; map(copy-comp(|nonr*)); pp-comps>

  
  


    
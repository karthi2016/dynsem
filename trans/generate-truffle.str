module generate-truffle

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/ds
  lib/editor-common.generated
  refocus
  sugar
  strict
  lib-ds
  explicate

signature constructors
	
	Node : T
	Root : T
	Func : T

rules
	
  /*
  
  1. every term T/n from the interpreter language becomes a class T_n.java extends DynsemNode
  2. every term T/n that is not part of the language and is not a function becomes a T_n.java extends RootNode 
  3. every function (things that are only norm) becomes a function in truffle
  
  */

  to-truffle:
    rs -> <concat-strings> truffle //<hashtable-keys> rule-store //<fail> // <concat-strings> [dnode-js, rnode-js]
    where
      rs' := <unstrict-rules; desugar-all; explicate-rules> rs;
      <extract-components> rs';
      rule-store := <new-hashtable>;
      // group the rules by matching constructor
      <fill-rule-store(|rule-store)> rs';
      truffle := <to-truffle-impl(|rule-store)>
  
  fill-rule-store(|store) =
  	collect(?Rules(<id>));
  	concat;
  	map(gather-constructor; store-constructor(|store))
  	
  store-constructor(|store) =
  	?(name, arity, ty, r);
		<hashtable-get(|(name, arity))> store => (ty, rs);
		<hashtable-put(|(name, arity), (ty, [r|rs]))> store
  
  store-constructor(|store) = 
  	?(name, arity, ty, r);
  	<not(hashtable-get(|(name, arity)))> store;
  	<hashtable-put(|(name, arity), (ty, [r]))> store
  
  // functions
  gather-constructor:
  	r@Rule(_, _, TermEq(Con(name, args), _)) -> (name, arity, Func(), r)
  	with
  		arity := <length> args
  
  // nodes & rootnodes
  gather-constructor:
  	r@Rule(_, _, Relation(_, Source(Con(name, args), _), _, _)) -> (name, arity, nodetype, r)
  	with
  	  arity := <length> args;
  	  if <is-language-node> (name, arity) then
  	    nodetype := Node()
  	  else
  	    nodetype := Root()
  	  end
  
  is-language-node =
    ?("Cast", 2) +
    ?("New", 2) +
    ?("MethCall", 3) +
    ?("FieldRef", 2) +
    ?("Var", 1) +
    ?("Param", 2) +
    ?("Method", 4) +
    ?("FieldInit", 2) +
    ?("SuperCall", 1) +
    ?("Constructor", 4) +
    ?("Void", 0) +
    ?("ClassType", 1) +
    ?("Field", 2) +
    ?("Super", 1) +
    ?("Class", 5) +
    ?("Program", 2)
  
rules
  
  // builtin-constructors = ![ ("MapExtend", 2), ("MapSelect", 2), ("Skip", 0), ("Cons", 2), ("Nil", 0), ("Fresh", 0) ]
  
  to-truffle-impl(|store) =
    <hashtable-keys> store;
    map(to-truffle-dynsem-node(|store) <+ to-truffle-dynsem-function(|store))
  
  to-truffle-dynsem-function(|store):
    (name, arity) -> $[
					package org.metaborg.truffle.fj.dynsem.manual.functions;
					
					import org.metaborg.truffle.dynsem.shared.functions.*;
					import org.metaborg.truffle.dynsem.shared.runtime.*;
					
					public class [name] {
					
					    public static DynsemMap apply([<separate-by(|","); concat-strings> apply-pars]) {
					        [alterns]
					    }
					}]
    where
      <hashtable-get(|(name, arity))> store => (Func(), rs)
    with
      index-seq   := <mk-sequence> (1, <inc> arity);
      apply-pars  := <map(\ idx -> $[Object _[idx]] \)> index-seq;
      invoke-args := <map(\ idx -> $[_[idx]] \); separate-by(|","); concat-strings> index-seq;
      invoc-seq   := <mk-sequence> (0, <length;dec> rs);
      [inv|invxs] := <map(\ idx -> $[return apply_[idx]([invoke-args]);] \); reverse> invoc-seq;
      if <?[]> invxs then
        alterns := <to-catch-rethrow> inv
      else
        alterns := <foldl(to-catch-stm)> (invxs, <to-catch-rethrow> inv)
      end
      
  to-truffle-dynsem-node(|store):
    (name, arity) -> $[
						package org.metaborg.truffle.fj.dynsem.manual.eval;
						
						import org.metaborg.truffle.dynsem.shared.nodes.*;
						import org.metaborg.truffle.dynsem.shared.runtime.*;
						
						import com.oracle.truffle.api.frame.*;
						
						public class [name]_[arity] extends [super-class] {
						
						    [<separate-by(|"\n"); concat-strings> fields]
						
						    public [name]_[arity]([<separate-by(|","); concat-strings> const-pars]) {
						        super();
						        [<separate-by(|"\n"); concat-strings> field-init]
						    }
						
						    [<separate-by(|"\n"); concat-strings> field-gets]
						
						    @Override
						    public Result execute(VirtualFrame frame) {
						        [alterns]
						    }
						
						}]
	  where
	    <hashtable-get(|(name, arity))> store => (nodety, rs);
	    <?Node() + ?Root()> nodety
		with
		  if <?Node()> nodety then
		    super-class := "DynsemNode"
		  else
		    super-class := "RootNode"
		  end;
		  index-seq  := <mk-sequence> (1, <inc> arity);
		  fields     := <map(\ idx -> $[@Child protected DynsemNode _[idx];] \)> index-seq;
		  const-pars := <map(\ idx -> $[DynsemNode _[idx]] \)> index-seq;
		  field-init := <map(\ idx -> $[this._[idx] = adoptChild(_[idx]);] \)> index-seq;
		  field-gets := <map(\ idx -> $[public DynsemNode _[idx](){ return _[idx]; } ] \)> index-seq;
		  invoc-seq   := <mk-sequence> (0, <length;dec> rs);
		  [inv|invxs] := <map(\ idx -> $[return apply_[idx](frame);] \); reverse> invoc-seq;
		  if <?[]> invxs then
        alterns := <to-catch-rethrow> inv
      else
        alterns := <foldl(to-catch-stm)> (invxs, <to-catch-rethrow> inv)
      end
      
  to-catch-stm:
    (stm1, stm2) -> $[
      try {
        [stm1]
      }catch(Exception [ex-var]) {
        [stm2]
      }]
    with
      ex-var := <newname> "e"
  
  to-catch-rethrow:
    stm -> $[
      try {
        [stm]
      }catch(Exception [ex-var]) {
        throw [ex-var];
      }]
    with
      ex-var := <newname> "e"

rules
  
  mk-sequence = 
    ?(from, to);
    if <gt + eq> (from, to) then
      ![from ]
    else
      ![from | <mk-sequence> (<inc> from, to) ]
    end
          
//  
//        
// rules // translate rules
//    
//   translate-rules =
//     collect(?Rules(<id>)); 
//     concat; 
//     filter(translate-rule);
//     concat-strings
//     
//   translate-rule :
//     Rule(prem*, _, TermEq(lhs, rhs)) -> $[
//       norm:       
//         [<pp-term>lhs] -> [<pp-term-norm> rhs]
//         [<translate-premises> prem*]]
//      
//   translate-premises =
//     if ?[] then !"" 
//     else 
//       !$[where 
//            [<map(translate-premise); separate-by(|";\n"); concat-strings>]
//         ]
//     end
//     
//   translate-premise :
//     TermEq(lhs, rhs) -> $[[<pp-term>rhs] := [<pp-term-norm>lhs]]
//   
// rules // translate dynamic
// 
//   translate-rule :
//     Rule(prem*, _, Relation(Reads(r*), Source(lhs, sc*), DynamicEmitted(e*), Target(rhs, tc*))) -> $[
//       eval:       
//         ([<pp-term>lhs], [comps-lhs]) -> <debug(!"  to [<next-counter>"r"]: ")>([<pp-term-norm> rhs], [comps-rhs])
//         where debug(!"eval [<get-counter>"r"]: ")
//         [<translate-premises> prem*] 
//     ]
//     with 
//       nonwr* := <conc>(r*, sc*); 
//       comps-lhs := <NonWriteables; map(copy-comp(|nonwr*)); pp-comps>; 
//       nonr* := <conc>(e*, tc*);
//       comps-rhs := <NonReadables; map(copy-comp(|nonr*)); pp-comps-norm>
//                
//   translate-premise :
//     Relation(Reads(r*), Source(lhs, sc*), DynamicEmitted(e*), Target(rhs, tc*)) -> 
//     $[<eval>([<pp-term-norm>lhs], [comps-lhs]) => ([<pp-term> rhs], [comps-rhs])]
//     with      
//       nonwr* := <conc>(r*, sc*);
//       comps-lhs := <NonWriteables; map(copy-comp(|nonwr*)); pp-comps-norm> ;         
//       nonr* := <conc>(e*, tc*);
//       comps-rhs := <NonReadables; map(copy-comp(|nonr*)); pp-comps>

  
  


    
module generate-str

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/ds
  lib/editor-common.generated
  refocus
  sugar
  strict
  lib-ds
  explicate

rules

  to-stratego(|filename) :
    rs -> $[
      module [<base-filename; remove-extension>filename]
      
      signature
        constructors
          [cs]
          MapExtend : T * T -> T
          MapSelect : T * T -> T
          MapEmpty : T
          Map1 : T * T -> T
          Bind : T * T -> T
          Fresh : T
          Exec : T -> T
          Exec1 : T -> T
          IsValue : T -> T   
          True : T   
          Concat : T -> T
          
      
      rules // run-time library
        
        normalize :
          term -> term' 
          where term' := <innermost(norm)> term 
          
        exec :
          prog -> <eval> (<bottomup(n)>Exec(prog), [init-comps]) 
        
        norm:
          MapExtend(map1, map2) -> <conc> (map1, map2)
         
      
      rules // built-ins
        
        n = try(norm)
        
        norm:
          Concat(t*) -> <concat> t*
      	
        norm:
          MapEmpty() -> ["[]"]
          
        norm:
          Map1(x,y) -> ["[Bind(x,y)]"]
              
        norm:
          MapSelect(key, map) -> value
          where <fetch(?Bind(key, value))> map  
          
        norm:
          Fresh() -> <new>
        
        /*
        The following rules should be somewhere:
        
        IsValue(x) = true
        -----------------
         Exec(x) --> x
		
        x --> y , Exec(x) --> y
        -----------------------
           Exec(x) --> y
        */
                     
      rules
        [rs'']
    ]
    where rs' := <unstrict-rules; desugar-all; explicate-rules> rs;
          <extract-components> rs';
          rs'' := <translate-rules> rs';
          cs  := <declare-constructors; separate-by(|"\n"); concat-strings> rs;
          init-comps := $<[<<CompList; filter(not(IsWritable)); tr-list(\name -> $<<name>([])>\|",")>>]>
          
rules // declare constructors
  
  declare-constructors =
    collect-all(declare-constructor, union)
    
  declare-constructor :
    Con(name, []) -> $[[name]: T]

  declare-constructor :
    Con(name, t*) -> $[[name]: [<tr-list(!"T"|" * ")>t*] -> T]
    where <not([])> t*

  declare-constructor :
    LabelComp(name, _) -> $[[name]: T -> T]
 
       
rules // translate rules
   
  translate-rules =
    collect(?Rules(<id>)); 
    concat; 
    filter(translate-rule);
    concat-strings
    
  translate-rule :
    Rule(prem*, _, TermEq(lhs, rhs)) -> $[
      norm:       
        [<pp-term>lhs] -> [<pp-term-norm> rhs]
        [<translate-premises> prem*]]
     
  translate-premises =
    if ?[] then !"" 
    else 
      !$[where 
           [<map(translate-premise); separate-by(|";\n"); concat-strings>]
        ]
    end
    
  translate-premise :
    TermEq(lhs, rhs) -> $[[<pp-term>rhs] := [<pp-term-norm>lhs]]
  
rules // translate dynamic

  translate-rule :
    Rule(prem*, _, Relation(Reads(r*), Source(lhs, sc*), DynamicEmitted(e*), Target(rhs, tc*))) -> $[
      eval:       
        ([<pp-term>lhs], [comps-lhs]) -> <debug(!"  to [<next-counter>"r"]: ")>([<pp-term-norm> rhs], [comps-rhs])
        where debug(!"eval [<get-counter>"r"]: ")
        [<translate-premises> prem*] 
    ]
    with 
      nonwr* := <conc>(r*, sc*); 
      comps-lhs := <NonWriteables; map(copy-comp(|nonwr*)); pp-comps>; 
      nonr* := <conc>(e*, tc*);
      comps-rhs := <NonReadables; map(copy-comp(|nonr*)); pp-comps-norm>
               
  translate-premise :
    Relation(Reads(r*), Source(lhs, sc*), DynamicEmitted(e*), Target(rhs, tc*)) -> 
    $[<eval>([<pp-term-norm>lhs], [comps-lhs]) => ([<pp-term> rhs], [comps-rhs])]
    with      
      nonwr* := <conc>(r*, sc*);
      comps-lhs := <NonWriteables; map(copy-comp(|nonwr*)); pp-comps-norm> ;         
      nonr* := <conc>(e*, tc*);
      comps-rhs := <NonReadables; map(copy-comp(|nonr*)); pp-comps>

  
  


    
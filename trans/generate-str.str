module generate-str

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/ds
  lib/editor-common.generated
  refocus
  sugar
  strict
  lib-ds
  explicate

rules
 
  to-stratego(|filename) :
    Module(name, section*) ->
    $[module [<base-filename; remove-extension>filename]
            
      [section''*]       
      
      rules
        
        exec :
          prog -> <eval> (<bottomup(n)>Exec(prog), [init-comps]) 
         
        n = try(norm)                               
    ]
    where section'* := <unstrict-rules; desugar-all; explicate-rules> section*;
       <extract-writables> section'* ;
       <extract-readables> section'* ;
       <extract-components> section'* ;
       section''*  := <translate-sections> section'* ;
       //cs  := <declare-constructors; separate-by(|"\n"); concat-strings> section*//;
       init-comps := $<[<<CompList; filter(not(IsWritable)); tr-list(\name -> $<<name>([])>\|",")>>]>

// rules // declare constructors
//   
//   declare-constructors =
//     collect-all(declare-constructor, union)
//     
//   declare-constructor :
//     Con(name, []) -> $[[name]: T]
// 
//   declare-constructor :
//     Con(name, t*) -> $[[name]: [<tr-list(!"T"|" * ")>t*] -> T]
//     where <not([])> t*
// 
//   declare-constructor :
//     LabelComp(name, _) -> $[[name]: T -> T]
 
       
rules // translate rules
  
  translate-sections =
    map(translate-section); separate-by(|"\n\n"); concat-strings

  translate-section :
    Imports(imp*) -> 
      $[imports [imps]]
    where
      imps := <map(?Import(<id>)); separate-by(|"\n  "); concat-strings>imp*
     
  translate-section :
    Rules(r*) ->
      $[rules         
          [rs]]
    where
      rs := <filter(translate-rule); concat-strings> r*
    
  translate-rule :
    Rule(prem*, _, TermEq(lhs, rhs)) -> $[
      norm:
        [<pp-term>lhs] -> [<pp-term-norm> rhs]
        [<translate-premisses> prem*]]
     
  translate-premisses =
    if ?[] then !"" 
    else 
      !$[where 
           [<map(translate-premisse); separate-by(|";\n"); concat-strings>]
        ]
    end
    
  translate-premisse :
    Formula(TermEq(lhs, rhs)) -> $[[<pp-term>rhs] := [<pp-term-norm>lhs]]
  
rules // translate dynamic

  translate-rule :
    Rule(prem*, _, Relation(Reads(r*), Source(lhs, sc*), DynamicEmitted(e*), Target(rhs, tc*))) -> $[
      eval:       
        ([<pp-term>lhs], [comps-lhs]) -> <debug(!"  to [<next-counter>"r"]: ")>([<pp-term-norm> rhs], [comps-rhs])
        where debug(!"eval [<get-counter>"r"]: ")
        [<translate-premisses> prem*] 
    ]
    with 
      nonwr* := <conc>(r*, sc*); 
      comps-lhs := <NonWriteables; map(\ comp -> <fetch-elem(?LabelComp(comp,_))>nonwr* \); pp-comps>; 
      nonr* := <conc>(e*, tc*);
      comps-rhs := <NonReadables; map(\ comp -> <fetch-elem(?LabelComp(comp,_))>nonr* \); pp-comps-norm>
               
  translate-premisse :
    Formula(Relation(Reads(r*), Source(lhs, sc*), DynamicEmitted(e*), Target(rhs, tc*))) -> 
    $[<eval>([<pp-term-norm>lhs], [comps-lhs]) => ([<pp-term> rhs], [comps-rhs])]
    with      
      nonwr* := <conc>(r*, sc*);
      comps-lhs := <NonWriteables; map(\ comp -> <fetch-elem(?LabelComp(comp,_))>nonwr* \); pp-comps-norm> ;         
      nonr* := <conc>(e*, tc*);
      comps-rhs := <NonReadables; map(\ comp -> <fetch-elem(?LabelComp(comp,_))>nonr* \); pp-comps>

  
  


    
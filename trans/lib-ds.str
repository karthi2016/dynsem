module lib-ds

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/ds
  lib/editor-common.generated
  refocus
  sugar
  strict
  ds

// utilities for DynSem analysis

rules // utils for deterministic variable name generation
  
  while-counting(s) =
    {| NextVarIdx:
      NextVarIdx < s + rules(NextVarIdx : _ -> 0); s
    |}
  
  next-variable(|prefix) =
    i := <NextVarIdx; inc>;
    rules(NextVarIdx :- _);
    rules(NextVarIdx : _ -> i);
    !$[[prefix]_[i]]

rules // projections for sorts
  
  get-sort-name = ?SortDecl(<id>) + ?InjDecl(<id>, _) + ?SemanticComponent(<id>, _) + ?InternalSortDecl(<id>)
  get-sort-name = ?SimpleSort(<id>)
  
  get-listsort-elementname = ?ListSort(<get-sort-name>)

rules
    
  // util for getting a set of arrows and their nonwritables and writables
  get-module-arrows-elements:
    mod -> <map(\ arrow-name -> <get-module-arrow-elements(|arrow-name)> mod \)> arrow-name*
    with
      arrow-name* := <get-module-arrow-declarations; map(get-arrow-name)> mod
  
  get-module-arrow-declaration(|arrow-name) = collect-one(?ArrowDecl(_, arrow-name, _))
  
  get-module-arrow-declarations = collect-all(?ArrowDecl(_, _, _))

  get-module-arrow-elements(|arrow-name):
    mod -> (arrow-name, nonwritable*, writable*)
    with
      nonwritable* := <get-module-arrow-nonwritables(|arrow-name)> mod;
      writable* := <get-module-arrow-writables(|arrow-name)> mod
  
  get-module-arrow-nonwritables(|arrow-name) =
    where(arrow-name' := <strip-annos> arrow-name);
    collect-one(where(get-rule-relation; get-relation-arrow-name; strip-annos; ?arrow-name'); get-rule-nonwritables)
    <+ ![]
  
  get-module-arrow-writables(|arrow-name) =
    where(arrow-name' := <strip-annos> arrow-name);
    collect-one(where(get-rule-relation; get-relation-arrow-name; strip-annos; ?arrow-name'); get-rule-writables)
    <+ ![]
  
  get-rule-nonwritables:
    Rule(_, _, Relation(Reads(nonwritable*), _, _, _)) -> nonwritable*
  
  get-rule-writables:
    Rule(_, _, Relation(_, Source(_, writable*), _, _)) -> writable*



rules

  get-rule-premises:
    Rule(prem*, _, _) -> prem*

  get-rule-relation:
    Rule(_, _, rel) -> rel

  get-formula-relation:
    Formula(rel) -> rel

  get-component-sort:
    LabelComp(s, _) -> s

  get-relation-writables:
    Relation(_, _, NamedDynamicEmitted(comps, _), _) -> comps

  get-relation-readables:
    Relation(Reads(read*), _, _, _) -> read*

  get-relation-changeables:
    Relation(_, Source(_, sc*), _, Target(_, tc*)) -> [sc*, tc*]
    
  get-relation-arrow-name:
    Relation(_, _, arrow, _) -> <get-arrow-name> arrow
  
  get-arrow-name:
    ArrowDecl(_, name, _) -> name
  
  get-arrow-name:
    NamedDynamicEmitted(_, name) -> name
  
  get-arrow-name:
    NamedDynamic(name) -> name

rules // new extracted components (working for inference of components on multiple arrow types)
  
  m-in-extracted-components(s) =
  	{ WritableComps, ReadableComps, ChangeableComps:
  		where(
        ?t;
        arrow* := <get-module-arrow-declarations; map(get-arrow-name)> t;
        <map({
          ?arrow;
          rules(
            WritableComps: arrow -> []
            ReadableComps: arrow -> []
            ChangeableComps: arrow -> []
          )
          })> arrow*;
        rule* := <collect-all(?Rule(_, _, _))> t;
        <maptwice(where(extract-writables); where(extract-readables); where(extract-changeables))> rule*
  		);
  		s
  	}

  maptwice(s) = where(map(s)); map(s)

rules // extract components        
  
  extract-writables :
    rule -> rule
    with
      relation    := <get-rule-relation> rule;
      arrow       := <get-relation-arrow-name; strip-annos> relation;
      this-comp*  := <get-relation-writables; map(get-component-sort)> relation;
      prev-comp*  := <WritableComps> arrow;
      used-arrow* := <get-rule-premises; filter(get-formula-relation; get-relation-arrow-name); strip-annos> rule;
      req-comp*   := <map(WritableComps); concat> used-arrow*;
      comp*       := <make-set> [this-comp*, prev-comp*, req-comp*];
      rules( WritableComps : arrow -> comp* )
  
  extract-readables :
  	rule -> rule
  	with
  		relation    := <get-rule-relation> rule;
  		arrow       := <get-relation-arrow-name; strip-annos> relation;
  		this-comp*  := <get-relation-readables; map(get-component-sort)> relation;
  		prev-comp*  := <ReadableComps> arrow;
  		used-arrow* := <get-rule-premises; filter(get-formula-relation; get-relation-arrow-name); strip-annos> rule;
      req-comp*   := <map(ReadableComps); concat> used-arrow*;
      comp*       := <make-set> [this-comp*, prev-comp*, req-comp*];
      rules( ReadableComps : arrow -> comp* )

  extract-changeables :
  	rule -> rule
  	with
  		relation    := <get-rule-relation> rule;
  		arrow       := <get-relation-arrow-name; strip-annos> relation;
  		this-comp*  := <get-relation-changeables; map(get-component-sort)> relation;
  		prev-comp*  := <ChangeableComps> arrow;
  		used-arrow* := <get-rule-premises; filter(get-formula-relation; get-relation-arrow-name); strip-annos> rule;
      req-comp*   := <map(ChangeableComps); concat> used-arrow*;
      comp*       := <make-set> [this-comp*, prev-comp*, req-comp*];
      rules( ChangeableComps : arrow -> comp* )

rules // component operations
  
  comp-var(|num) :
    name -> $[[<lower-case>name]_[num]]
    
  mk-label-comps(|num) = 
    map(mk-label-comp(|num))
   
  mk-label-comp(|num) :
    name -> LabelComp(name, Var(<get-sort-name; comp-var(|num)> name))

  mk-label-comp-str(|num) :
    name -> $[[name]([<get-sort-name; comp-var(|num)> name])]

  mk-label-comp(default|num) :
    name -> <default <+ mk-label-comp(|num)> name
    
signature
  constructors
    N : T -> T
        
rules // pretty-printing terms 
  
 pp-comps =
    !$<[<<map(pp-comp); separate-by(|", ")>>]>
    
 pp-comps-norm =
    !$<[<<map(pp-comp-norm); separate-by(|", ")>>]>
  
  pp-comp :
    LabelComp(name, t) -> $[[name]([<pp-term>t])]

  pp-comp-norm :
    LabelComp(name, t) -> $[[name]([<pp-term-norm>t])]
 
  pp-term-norm =
    norm-all-cons; pp-term
  
  norm-all-cons = 
    bottomup(try(norm-term))
  
  norm-term :
    Con(c, t*) -> N(Con(c, t*))
  
  tr-list(s|sep) = 
    map(s); separate-by(|sep); concat-strings
  
  pp-terms = 
    map(pp-term); separate-by(|","); concat-strings
    
  pp-term :
    N(t) -> $[<n>[<pp-term>t]]
  
  pp-term :
    Con(c, t*) -> $[[c]([<pp-terms>t*])]
    
  pp-term :
    Var(x) -> x

  pp-term :
    String(s) -> $["[<un-double-quote> s]"]
    
  pp-term :
    Fresh() -> $[<new>]
    
  pp-term :
    Map(l) -> $[Map([<pp-bindings> l])]
    
  pp-bindings :
    [] -> $<[]>
    
  pp-bindings :
    [b@Bind(x, y)] -> $<[<<pp-term>b>]>

  // pp-bindings :
  //   [b@Bind(x, y) | ts@[_|_]] -> $<[<<pp-term>b> | <<pp-bindings> ts>]>
    
  pp-bindings :
    [MapEntry(t)] -> <pp-term>t
    
  // pp-bindings :
  //   [MapEntry(t) | ts@[_|_]] -> $[<conc>([<pp-term>t], [<pp-bindings>ts])]

  pp-bindings :
    [t@Binds(_,_)] -> <pp-term>t

  // pp-bindings :
  //   [t@Binds(_,_) | ts@[_|_]] -> $[<conc>([<pp-term>t], [<pp-bindings>ts])]
        
  pp-term :
    MapEntry(t) -> <pp-term>t

  pp-term :
    Bind(x, y) -> $[Bind([<pp-term>x], [<pp-term>y])]
    
  pp-term :
    MapSelect(m, k) ->
      $[<ds-mapselect>([<pp-term>k], [<pp-term>m])]
      
  pp-term :
    MapExtend(t1, t2) -> 
      $[<ds-mapextend>([<pp-term>t1], [<pp-term>t2])]
      
  pp-term :
    Binds(t1, t2) -> $[<ds-binds>([<pp-term>t1], [<pp-term>t2])]

  pp-term :
    List(l) -> <pp-list> l
        
  pp-list :
    [t*] -> $<[<<pp-terms>t*>]>
    
  pp-term :
    ListTail(t*, t) -> $<[<<pp-terms>t*> | <<pp-term>t>]>
    
  // pp-term :
  //   y -> <pp-aterm>
    
rules
  
  pp-aterm :
    c#(t*) -> $[[c]([<tr-list(pp-aterm|",")>t*])]
    
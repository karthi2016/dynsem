module lib-ds

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/ds
  lib/editor-common.generated
  refocus
  sugar
  strict
  ds

// utilities for DynSem analysis

rules // utils for deterministic variable name generation
  
  while-counting(s) =
    {| NextVarIdx:
      NextVarIdx < s + rules(NextVarIdx : _ -> 0); s
    |}
  
  next-variable(|prefix) =
    i := <NextVarIdx; inc>;
    rules(NextVarIdx :- _);
    rules(NextVarIdx : _ -> i);
    !$[[prefix]_[i]]

rules // projections for sorts
  
  get-sort-name = ?SortDecl(<id>) + ?InjDecl(<id>, _) + ?SemanticComponent(<id>) + ?InternalSortDecl(<id>)
  get-sort-name = ?SimpleSort(<id>)
  
  get-listsort-elementname = ?ListSort(<get-sort-name>)

rules
    
  // util for getting a set of arrows and their nonwritables and writables
  get-module-arrows-elements:
    mod -> <map(\ arrow-name -> <get-module-arrow-elements(|arrow-name)> mod \)> arrow-name*
    with
      arrow-name* := <get-module-arrow-declarations; map(get-arrow-name)> mod
  
  get-module-arrow-declaration(|arrow-name) = collect-one(?ArrowDecl(_, arrow-name, _))
  
  get-module-arrow-declarations = collect-all(?ArrowDecl(_, _, _))

  get-module-arrow-elements(|arrow-name):
    mod -> (arrow-name, nonwritable*, writable*)
    with
      nonwritable* := <get-module-arrow-nonwritables(|arrow-name)> mod;
      writable* := <get-module-arrow-writables(|arrow-name)> mod
  
  get-module-arrow-nonwritables(|arrow-name) =
    where(arrow-name' := <strip-annos> arrow-name);
    collect-one(where(get-rule-arrow-name; strip-annos; ?arrow-name'); get-rule-nonwritables)
    <+ ![]
  
  get-module-arrow-writables(|arrow-name) =
    where(arrow-name' := <strip-annos> arrow-name);
    collect-one(where(get-rule-arrow-name; strip-annos; ?arrow-name'); get-rule-writables)
    <+ ![]
  
  get-rule-nonwritables:
    Rule(_, _, Relation(Reads(nonwritable*), _, _, _)) -> nonwritable*
  
  get-rule-writables:
    Rule(_, _, Relation(_, Source(_, writable*), _, _)) -> writable*

  get-rule-arrow-name:
    Rule(_, _, Relation(_, _, arrow, _)) -> <get-arrow-name> arrow
  
  get-arrow-name:
    ArrowDecl(_, name, _) -> name
  
  get-arrow-name:
    NamedDynamicEmitted(name, _) -> name
  
  get-arrow-name:
    NamedDynamic(name) -> name

rules // extract components        
  
  in-extracted-components(s) =
    { CompList, NonWriteables, NonReadables, CompPatLhs, CompPatRhs, CompsLhs, CompsRhs:
      where(
        ?t;
        <extract-writables> t;
        <extract-readables> t;
        <extract-changeables> t
      );
      s
    }
  
  extract-components =
    collect-all(?LabelComp(<id>, _), union) => comps; 
    <filter(not(IsWritable))> comps => non-writeables; 
    <filter(not(IsReadable))> comps => non-readables; 
    rules(
      CompList : _ -> comps
      NonWriteables : _ -> non-writeables
      NonReadables : _ -> non-readables
      
      CompPatLhs : num -> $<[<<separate-by(|",")>lst>]>
        where <map(mk-label-comp-str(|num))> non-writeables => lst     
        
      CompPatRhs : num -> $<[<<separate-by(|",")>lst>]>
        where <map(mk-label-comp-str(|num))> non-readables => lst     
        
      CompsLhs : num -> <mk-label-comps(|num)> non-writeables
      
      CompsRhs : num -> <mk-label-comps(|num)> non-readables       
    )

  extract-writables  :
    rs -> comps
    where
      collect-all(?NamedDynamicEmitted(_, <map(?LabelComp(<id>,_))>), union); concat; make-set => comps;
      rules( WritableComps : _ -> comps );
      map({?comp; rules( IsWritable : comp -> comp )})

  extract-readables :
    rs -> comps
    where
      collect-all(?Reads(<map(?LabelComp(<id>,_))>), union); concat; make-set => comps;
      rules( ReadableComps : _ -> comps );
      map({?comp; rules( IsReadable : comp -> comp )})

  extract-changeables :
    rs -> comps
    where
      collect-all((?Source(_, <id>) <+ ?Target(_, <id>)); map(?LabelComp(<id>,_)), union); concat; make-set => comps;
      rules( ChangeableComps : _ -> comps );
      map({?comp; rules( IsChangeable : comp -> comp )})
      
rules // component operations
  
  comp-var(|num) :
    name -> $[[<lower-case>name]_[num]]
    
  mk-label-comps(|num) = 
    map(mk-label-comp(|num))
   
  mk-label-comp(|num) :
    name -> LabelComp(name, Var(<get-sort-name; comp-var(|num)> name))

  mk-label-comp-str(|num) :
    name -> $[[name]([<get-sort-name; comp-var(|num)> name])]

  mk-label-comp(default|num) :
    name -> <get-sort-name; default <+ mk-label-comp(|num)> name
    
signature
  constructors
    N : T -> T
        
rules // pretty-printing terms 
  
 pp-comps =
    !$<[<<map(pp-comp); separate-by(|", ")>>]>
    
 pp-comps-norm =
    !$<[<<map(pp-comp-norm); separate-by(|", ")>>]>
  
  pp-comp :
    LabelComp(name, t) -> $[[name]([<pp-term>t])]

  pp-comp-norm :
    LabelComp(name, t) -> $[[name]([<pp-term-norm>t])]
 
  pp-term-norm =
    norm-all-cons; pp-term
  
  norm-all-cons = 
    bottomup(try(norm-term))
  
  norm-term :
    Con(c, t*) -> N(Con(c, t*))
  
  tr-list(s|sep) = 
    map(s); separate-by(|sep); concat-strings
  
  pp-terms = 
    map(pp-term); separate-by(|","); concat-strings
    
  pp-term :
    N(t) -> $[<n>[<pp-term>t]]
  
  pp-term :
    Con(c, t*) -> $[[c]([<pp-terms>t*])]
    
  pp-term :
    Var(x) -> x

  pp-term :
    String(s) -> $["[<un-double-quote> s]"]
    
  pp-term :
    Fresh() -> $[<new>]
    
  pp-term :
    Map(l) -> $[Map([<pp-bindings> l])]
    
  pp-bindings :
    [] -> $<[]>
    
  pp-bindings :
    [b@Bind(x, y)] -> $<[<<pp-term>b>]>

  // pp-bindings :
  //   [b@Bind(x, y) | ts@[_|_]] -> $<[<<pp-term>b> | <<pp-bindings> ts>]>
    
  pp-bindings :
    [MapEntry(t)] -> <pp-term>t
    
  // pp-bindings :
  //   [MapEntry(t) | ts@[_|_]] -> $[<conc>([<pp-term>t], [<pp-bindings>ts])]

  pp-bindings :
    [t@Binds(_,_)] -> <pp-term>t

  // pp-bindings :
  //   [t@Binds(_,_) | ts@[_|_]] -> $[<conc>([<pp-term>t], [<pp-bindings>ts])]
        
  pp-term :
    MapEntry(t) -> <pp-term>t

  pp-term :
    Bind(x, y) -> $[Bind([<pp-term>x], [<pp-term>y])]
    
  pp-term :
    MapSelect(m, k) ->
      $[<ds-mapselect>([<pp-term>k], [<pp-term>m])]
      
  pp-term :
    MapExtend(t1, t2) -> 
      $[<ds-mapextend>([<pp-term>t1], [<pp-term>t2])]
      
  pp-term :
    Binds(t1, t2) -> $[<ds-binds>([<pp-term>t1], [<pp-term>t2])]

  pp-term :
    List(l) -> <pp-list> l
        
  pp-list :
    [t*] -> $<[<<pp-terms>t*>]>
    
  pp-term :
    ListTail(t*, t) -> $<[<<pp-terms>t*> | <<pp-term>t>]>
    
  // pp-term :
  //   y -> <pp-aterm>
    
rules
  
  pp-aterm :
    c#(t*) -> $[[c]([<tr-list(pp-aterm|",")>t*])]
    
module lib-ds

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/ds
  include/DynSem
  lib/editor-common.generated
  refocus
  sugar
  strict

// utilities for DynSem analysis

rules // extract components        
  
  extract-components =
    collect-all(?LabelComp(<id>, _), union) => comps; 
    <filter(not(IsWritable))> comps => non-writeables;
    <filter(not(IsReadable))> comps => non-readables;    
    rules(
      CompList : _ -> comps
      NonWriteables : _ -> non-writeables
      NonReadables : _ -> non-readables
      
      CompPatLhs : num -> $<[<<separate-by(|",")>lst>]>
        where <map(mk-label-comp-str(|num))> non-writeables => lst     
        
      CompPatRhs : num -> $<[<<separate-by(|",")>lst>]>
        where <map(mk-label-comp-str(|num))> non-readables => lst     
        
      CompsLhs : num -> <mk-label-comps(|num)> non-writeables
      
      CompsRhs : num -> <mk-label-comps(|num)> non-readables       
    )
        
  extract-writables  :
    rs -> comps
    where
      collect-all(?DynamicEmitted(<map(?LabelComp(<id>,_))>), union); concat => comps;
      rules( WritableComps : _ -> comps );
      map({?comp; rules( IsWritable : comp -> comp )})

  extract-readables :
    rs -> comps
    where
      collect-all(?Reads(<map(?LabelComp(<id>,_))>), union); concat => comps;
      rules( ReadableComps : _ -> comps );
      map({?comp; rules( IsReadable : comp -> comp )})

  extract-changeables :
    rs -> comps
    where
      collect-all((?Source(_, <id>) <+ ?Target(_, <id>)); map(?LabelComp(<id>,_)), union); concat => comps;
      rules( ChangeableComps : _ -> comps );
      map({?comp; rules( IsChangeable : comp -> comp )})
      
rules // component operations
  
  comp-var(|num) :
    name -> $[[<lower-case>name]_[num]]
    
  mk-label-comps(|num) = 
    map(mk-label-comp(|num))
   
  mk-label-comp(|num) :
    name -> LabelComp(name, Var(<comp-var(|num)> name))

  mk-label-comp-str(|num) :
    name -> $[[name]([<comp-var(|num)> name])]

  mk-label-comp(default|num) :
    name -> <default <+ mk-label-comp(|num)> name
    
signature
  constructors
    N : T -> T
        
rules // pretty-printing terms 
  
 pp-comps =
    !$<[<<map(pp-comp); separate-by(|", ")>>]>
    
 pp-comps-norm =
    !$<[<<map(pp-comp-norm); separate-by(|", ")>>]>
  
  pp-comp :
    LabelComp(name, t) -> $[[name]([<pp-term>t])]

  pp-comp-norm :
    LabelComp(name, t) -> $[[name]([<pp-term-norm>t])]
 
  pp-term-norm =
    norm-all-cons; pp-term
  
  norm-all-cons = 
    bottomup(try(norm-term))
  
  norm-term :
    Con(c, t*) -> N(Con(c, t*))
  
  tr-list(s|sep) = 
    map(s); separate-by(|sep); concat-strings
  
  pp-terms = 
    map(pp-term); separate-by(|","); concat-strings
    
  pp-term :
    N(t) -> $[<n>[<pp-term>t]]
  
  pp-term :
    Con(c, t*) -> $[[c]([<pp-terms>t*])]
    
  pp-term :
    Var(x) -> x

  pp-term :
    String(s) -> $["[<un-double-quote> s]"]
    
  pp-term :
    Fresh() -> $[<new>]
    
  pp-term :
    Map(l) -> $[Map([<pp-bindings> l])]
    
  pp-bindings :
    [] -> $<[]>
    
  pp-bindings :
    [b@Bind(x, y)] -> $<[<<pp-term>b>]>

  // pp-bindings :
  //   [b@Bind(x, y) | ts@[_|_]] -> $<[<<pp-term>b> | <<pp-bindings> ts>]>
    
  pp-bindings :
    [MapEntry(t)] -> <pp-term>t
    
  // pp-bindings :
  //   [MapEntry(t) | ts@[_|_]] -> $[<conc>([<pp-term>t], [<pp-bindings>ts])]

  pp-bindings :
    [t@Binds(_,_)] -> <pp-term>t

  // pp-bindings :
  //   [t@Binds(_,_) | ts@[_|_]] -> $[<conc>([<pp-term>t], [<pp-bindings>ts])]
        
  pp-term :
    MapEntry(t) -> <pp-term>t

  pp-term :
    Bind(x, y) -> $[Bind([<pp-term>x], [<pp-term>y])]
    
  pp-term :
    MapSelect(m, k) ->
      $[<ds-mapselect>([<pp-term>k], [<pp-term>m])]
      
  pp-term :
    MapExtend(t1, t2) -> 
      $[<ds-mapextend>([<pp-term>t1], [<pp-term>t2])]
      
  pp-term :
    Binds(t1, t2) -> $[<ds-binds>([<pp-term>t1], [<pp-term>t2])]

  pp-term :
    List(l) -> <pp-list> l
        
  pp-list :
    [t*] -> $<[<<pp-terms>t*>]>
    
  pp-term :
    ListTail(t*, t) -> $<[<<pp-terms>t*> | <<pp-term>t>]>
    
  // pp-term :
  //   y -> <pp-aterm>
    
rules
  
  pp-aterm :
    c#(t*) -> $[[c]([<tr-list(pp-aterm|",")>t*])]
    
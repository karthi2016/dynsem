module generate

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/ds
  lib/editor-common.generated
  refocus
  sugar

rules

  to-stratego(|filename) :
    rs -> $[
      module [<base-filename; remove-extension>filename]
      
      signature
        constructors
          [cs]
          MapExtend : T * T -> T
          MapSelect : T * T -> T
          MapEmpty : T
          Map1 : T * T -> T
          Bind : T * T -> T
          Fresh : T
          Exec : T -> T
          Exec1 : T -> T
          IsValue : T -> T       
          
      
      rules // run-time library
        
        normalize :
          term -> term' 
          where term' := <innermost(norm)> term 
          
        exec :
          prog -> <eval> (<bottomup(n)>Exec(prog), [init-comps]) 
        
        norm:
          MapExtend(map1, map2) -> <conc> (map1, map2)
         
      
      rules // built-ins
        
        n = try(norm)
      	
        norm:
          MapEmpty() -> ["[]"]
          
        norm:
          Map1(x,y) -> ["[Bind(x,y)]"]
              
        norm:
          MapSelect(key, map) -> value
          where <fetch(?Bind(key, value))> map  
          
        norm:
          Fresh() -> <new>
        
        /*
        The following rules should be somewhere:
        
        IsValue(x) = true
        -----------------
         Exec(x) --> x
		
        x --> y , Exec(x) --> y
        -----------------------
           Exec(x) --> y
        */
                     
      rules
        [rs'']
    ]
    where rs' := <desugar-all> rs;
          <extract-writables> rs';
          <extract-readables> rs';
          <extract-components> rs';
          rs'' := <translate-rules> rs';
          cs  := <declare-constructors; separate-by(|"\n"); concat-strings> rs;
          init-comps := $<[<<CompList; filter(not(IsWritable)); tr-list(\name -> $<<name>([])>\|",")>>]>
          
rules // declare constructors
  
  declare-constructors =
    collect-all(declare-constructor, union)
    
  declare-constructor :
    Con(name, []) -> $[[name]: T]

  declare-constructor :
    Con(name, t*) -> $[[name]: [<tr-list(!"T"|" * ")>t*] -> T]
    where <not([])> t*

  declare-constructor :
    LabelComp(name, _) -> $[[name]: T -> T]
 
rules // component operations
  
  comp-var(|num) :
    name -> $[[<lower-case>name]_[num]]
    
  mk-label-comps(|num) = 
    map(mk-label-comp(|num))
   
  mk-label-comp(|num) :
    name -> LabelComp(name, Var(<comp-var(|num)> name))

  mk-label-comp-str(|num) :
    name -> $[[name]([<comp-var(|num)> name])]

  mk-label-comp(default|num) :
    name -> <default <+ mk-label-comp(|num)> name

rules // extract components        
  
  extract-components =
    collect-all(?LabelComp(<id>, _), union) => comps; 
    <filter(not(IsWritable))> comps => non-writeables;
    <filter(not(IsReadable))> comps => non-readables;    
    rules(
      CompList : _ -> comps
      NonWriteables : _ -> non-writeables
      NonReadables : _ -> non-readables
      
      CompPatLhs : num -> $<[<<separate-by(|",")>lst>]>
        where <map(mk-label-comp-str(|num))> non-writeables => lst     
        
      CompPatRhs : num -> $<[<<separate-by(|",")>lst>]>
        where <map(mk-label-comp-str(|num))> non-readables => lst     
        
      CompsLhs : num -> <mk-label-comps(|num)> non-writeables
      
      CompsRhs : num -> <mk-label-comps(|num)> non-readables       
    )
        
  extract-writables  :
    rs -> comps
    where
      collect-all(?DynamicEmitted(<map(?LabelComp(<id>,_))>), union); concat => comps;
      rules( WritableComps : _ -> comps );
      map({?comp; rules( IsWritable : comp -> comp )})

  extract-readables :
    rs -> comps
    where
      collect-all(?Reads(<map(?LabelComp(<id>,_))>), union); concat => comps;
      rules( ReadableComps : _ -> comps );
      map({?comp; rules( IsReadable : comp -> comp )})

  extract-changeables :
    rs -> comps
    where
      collect-all((?Source(_, <id>) <+ ?Target(_, <id>)); map(?LabelComp(<id>,_)), union); concat => comps;
      rules( ChangeableComps : _ -> comps );
      map({?comp; rules( IsChangeable : comp -> comp )})
        
rules // translate rules
   
  translate-rules =
    collect(?Rules(<id>)); 
    concat; 
    filter(/* try(refocus); desugar-all; */ translate-rule);
    concat-strings
 
  // handled through desugaring
  // translate-rule :
  //   Axiom(TermEq(lhs, rhs)) -> $[
  //     norm:
  //       [<pp-term>lhs] -> [<pp-term-norm> rhs]
  //   ]
    
  translate-rule :
    Rule(prem*, _, TermEq(lhs, rhs)) -> $[
      norm:       
        [<pp-term>lhs] -> [<pp-term-norm> rhs]
        where [prems]
    ]
    where (_, prems) := <translate-premisses> (1, prem*)
     
  translate-premisses :
    (num, []) -> (num, $[id])
    
  translate-premisses :
    (num, [Formula(TermEq(lhs, rhs)) | prem*]) -> (num', prems')
    where (num', prems) := <translate-premisses>(num, prem*);
          prems' := $[[<pp-term>rhs] := [<pp-term-norm>lhs]; 
                      [prems]]
          
             
  // todo: lift non-variable arguments from lhs patterns (recursively)
  // as normalization on MSOS rules
  // (optimization)
  
rules // translate dynamic

  translate-rule :
    Rule(prem*, _, Relation(Reads(r*), Source(lhs, sc*), DynamicEmitted(e*), Target(rhs, tc*))) -> $[
      eval:       
        ([<pp-term>lhs], [comps-lhs]) -> ([<pp-term-norm> rhs], [comps-rhs])
        where debug(!"eval: "); 
              [initsprems] 
    ]
    where comps-lhs := <CompPatLhs> 1;
          inits := <conc; label-comp-inits(|1)> (r*, sc*);
          (num, prems) := <translate-premisses> (2, prem*);
          initsprems := <if (?"") then !$[[prems]] else !$[[inits]
                                                            [prems]] end> inits;
          comps-rhs := <conc; label-comp-conclusion(|num)> (e*, tc*)
            
  label-comp-inits(|num) = 
    if ?[] then !$[] else map(label-comp-init(|num)); concat-strings end
  
  label-comp-init(|num) :
    LabelComp(name, t) -> $[[<pp-term>t] := [<lower-case>name]_[num];]
    
  label-comp-premisse(|num) :
    comps -> $<[<<separate-by(|",")> t*>]>
    where
      CompList; 
      filter(not(IsWritable); (
        {t: \ comp-name -> $[[comp-name]([<pp-term-norm>t])]
              where <fetch(?LabelComp(comp-name, t))> comps \ }        
        <+ ( not(IsReadable) ; \ comp-name -> $[[comp-name]([<lower-case>comp-name]_[<subt>(num,1)])] \ )
        <+ ( IsReadable ; \ comp-name -> $[[comp-name]([<lower-case>comp-name]_1)] \ )        
        )
      ) => t*

  label-comp-conclusion(|num) :
    comps -> $<[<<separate-by(|",")> t*>]>
    where
      CompList;
      filter(not(IsReadable)); 
      map(
        {t: \ comp-name -> $[[comp-name]([<pp-term-norm>t])]
              where <fetch(?LabelComp(comp-name, t))> comps \ }       
        <+ if not(IsWritable) <+ <eq> (num, 3) then       
              \ comp-name -> $[[comp-name]([<lower-case>comp-name]_[<subt>(num,1)])] \ 
           else if <gt> (num, 3) then
               \ comp-name -> $[[comp-name](<concat>["["][<range; map(\i -> $[[<lower-case>comp-name]_[i]] \); separate-by(|","); concat-strings> (2, num)]["]"])] \
           else 
               \ comp-name -> $<<comp-name>([])> \
           end end
      ) => t*
               
  translate-premisses :
    (num, [Formula(Relation(Reads(r*), Source(lhs, sc*), DynamicEmitted(e*), Target(rhs, tc*))) | prem*]) -> 
    (num', $[<eval>([<pp-term-norm>lhs], [comps-lhs]) => ([<pp-term> rhs], [comps-rhs]);
             [initsprems]])
    where comps-lhs := <conc; label-comp-premisse(|num)> (r*, sc*);
          comps-rhs := <CompPatRhs> num;
          inits     := <conc; label-comp-inits(|num)> (e*, tc*);
          (num', prems) := <translate-premisses> (<add>(num, 1), prem*);
          initsprems := <if (?"") then !$[[prems]] else !$[[inits]
                                                           [prems]] end> inits         
          

signature
  constructors
    N : T -> T
        
rules 
  
  pp-term-norm =
    norm-all-cons; pp-term
  
  norm-all-cons = 
    bottomup(try(norm-term))
  
  norm-term :
    Con(c, t*) -> N(Con(c, t*))
  
  tr-list(s|sep) = 
    map(s); separate-by(|sep); concat-strings
  
  pp-terms = 
    map(pp-term); separate-by(|","); concat-strings
    
  pp-term :
    N(t) -> $[<n>[<pp-term>t]]
  
  pp-term :
    Con(c, t*) -> $[[c]([<pp-terms>t*])]
    
  pp-term :
    Var(x) -> x

  pp-term :
    String(s) -> $["[<un-double-quote> s]"]
    
  pp-term :
    Map(l) -> <pp-list> l

  pp-term :
    Bind(x, y) -> $[Bind([<pp-term>x],[<pp-term>y])]

  pp-term :
    List(l) -> <pp-list> l
        
  pp-list :
    [t*] -> $<[<<pp-terms>t*>]>
    
  pp-term :
    y -> <pp-aterm>
    
rules
  
  pp-aterm :
    c#(t*) -> $[[c]([<tr-list(pp-aterm|",")>t*])]
    
/*
todo:
	seperate "explicate" and "generate stratego" phases
*/

    
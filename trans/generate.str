// NB: This file is now obsolete (I think)
// since it's functionality is provided by generate-str + explicate

module generate

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/ds
  lib/editor-common.generated
  refocus
  sugar
  strict
  lib-ds

rules

  to-stratego(|filename) :
    rs -> $[
      module [<base-filename; remove-extension>filename]
      
      signature
        constructors
          [cs]
          MapExtend : T * T -> T
          MapSelect : T * T -> T
          MapEmpty : T
          Map1 : T * T -> T
          Bind : T * T -> T
          Fresh : T
          Exec : T -> T
          Exec1 : T -> T
          IsValue : T -> T       
          
      
      rules // run-time library
        
        normalize :
          term -> term' 
          where term' := <innermost(norm)> term 
          
        exec :
          prog -> <eval> (<bottomup(n)>Exec(prog), [init-comps]) 
        
        norm:
          MapExtend(map1, map2) -> <conc> (map1, map2)
         
      
      rules // built-ins
        
        n = try(norm)
      	
        norm:
          MapEmpty() -> ["[]"]
          
        norm:
          Map1(x,y) -> ["[Bind(x,y)]"]
              
        norm:
          MapSelect(key, map) -> value
          where <fetch(?Bind(key, value))> map  
          
        norm:
          Fresh() -> <new>
        
        /*
        The following rules should be somewhere:
        
        IsValue(x) = true
        -----------------
         Exec(x) --> x
		
        x --> y , Exec(x) --> y
        -----------------------
           Exec(x) --> y
        */
                     
      rules
        [rs'']
    ]
    where rs' := <unstrict-rules; desugar-all> rs;
          <extract-components> rs';
          rs'' := <translate-rules> rs';
          cs  := <declare-constructors; separate-by(|"\n"); concat-strings> rs;
          init-comps := $<[<<CompList; filter(not(IsWritable)); tr-list(\name -> $<<name>([])>\|",")>>]>
          
rules // declare constructors
  
  declare-constructors =
    collect-all(declare-constructor, union)
    
  declare-constructor :
    Con(name, []) -> $[[name]: T]

  declare-constructor :
    Con(name, t*) -> $[[name]: [<tr-list(!"T"|" * ")>t*] -> T]
    where <not([])> t*

  declare-constructor :
    LabelComp(name, _) -> $[[name]: T -> T]
 
       
rules // translate rules
   
  translate-rules =
    collect(?Rules(<id>)); 
    concat; 
    filter(/* try(refocus); desugar-all; */ translate-rule);
    concat-strings
    
  translate-rule :
    Rule(prem*, _, TermEq(lhs, rhs)) -> $[
      norm:       
        [<pp-term>lhs] -> [<pp-term-norm> rhs]
        where [prems]
    ]
    where (_, prems) := <translate-premises> (1, prem*)
     
  translate-premises :
    (num, []) -> (num, $[id])
    
  translate-premises :
    (num, [TermEq(lhs, rhs) | prem*]) -> (num', prems')
    where (num', prems) := <translate-premises>(num, prem*);
          prems' := $[[<pp-term>rhs] := [<pp-term-norm>lhs]; 
                      [prems]]
  
rules // translate dynamic

  translate-rule :
    Rule(prem*, _, Relation(Reads(r*), Source(lhs, sc*), DynamicEmitted(e*), Target(rhs, tc*))) -> $[
      eval:       
        ([<pp-term>lhs], [comps-lhs]) -> ([<pp-term-norm> rhs], [comps-rhs])
        where debug(!"eval: "); 
              [initsprems] 
    ]
    where comps-lhs := <CompPatLhs> 1;
          inits := <conc; label-comp-inits(|1)> (r*, sc*);
          (num, prems) := <translate-premises> (2, prem*);
          initsprems := <if (?"") then !$[[prems]] else !$[[inits]
                                                            [prems]] end> inits;
          comps-rhs := <conc; label-comp-conclusion(|num)> (e*, tc*)
            
  label-comp-inits(|num) = 
    if ?[] then !$[] else map(label-comp-init(|num)); concat-strings end
  
  label-comp-init(|num) :
    LabelComp(name, t) -> $[[<pp-term>t] := [<lower-case>name]_[num];]
    
  label-comp-premise(|num) :
    comps -> $<[<<separate-by(|",")> t*>]>
    where
      CompList; 
      filter(not(IsWritable); (
        {t: \ comp-name -> $[[comp-name]([<pp-term-norm>t])]
              where <fetch(?LabelComp(comp-name, t))> comps \ }        
        <+ ( not(IsReadable) ; \ comp-name -> $[[comp-name]([<lower-case>comp-name]_[<subt>(num,1)])] \ )
        <+ ( IsReadable ; \ comp-name -> $[[comp-name]([<lower-case>comp-name]_1)] \ )        
        )
      ) => t*

  label-comp-conclusion(|num) :
    comps -> $<[<<separate-by(|",")> t*>]>
    where
      CompList;
      filter(not(IsReadable)); 
      map(
        {t: \ comp-name -> $[[comp-name]([<pp-term-norm>t])]
              where <fetch(?LabelComp(comp-name, t))> comps \ }       
        <+ if not(IsWritable) <+ <eq> (num, 3) then       
              \ comp-name -> $[[comp-name]([<lower-case>comp-name]_[<subt>(num,1)])] \ 
           else if <gt> (num, 3) then
               \ comp-name -> $[[comp-name](<concat>["["][<range; map(\i -> $[[<lower-case>comp-name]_[i]] \); separate-by(|","); concat-strings> (2, num)]["]"])] \
           else 
               \ comp-name -> $<<comp-name>([])> \
           end end
      ) => t*
               
  translate-premises :
    (num, [Relation(Reads(r*), Source(lhs, sc*), DynamicEmitted(e*), Target(rhs, tc*)) | prem*]) -> 
    (num', $[<eval>([<pp-term-norm>lhs], [comps-lhs]) => ([<pp-term> rhs], [comps-rhs]);
             [initsprems]])
    where comps-lhs := <conc; label-comp-premise(|num)> (r*, sc*);
          comps-rhs := <CompPatRhs> num;
          inits     := <conc; label-comp-inits(|num)> (e*, tc*);
          (num', prems) := <translate-premises> (<add>(num, 1), prem*);
          initsprems := <if (?"") then !$[[prems]] else !$[[inits]
                                                           [prems]] end> inits         
          


    
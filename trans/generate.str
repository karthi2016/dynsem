module generate

/* NOTE: OBSOLETE; see generate-str.str */

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/ds
  lib/editor-common.generated
  refocus
  sugar
  strict
  lib-ds

rules

  to-stratego(|filename) :
    Module(name, section*) -> $[
      module [<base-filename; remove-extension>filename]
      
      signature
        constructors
          MapExtend : T * T -> T
          MapSelect : T * T -> T
          MapEmpty : T
          Map1 : T * T -> T
          Bind : T * T -> T
          Fresh : T
          Exec : T -> T
          Exec1 : T -> T
          IsValue : T -> T       
          
      
      rules // run-time library
        
        normalize :
          term -> term' 
          where term' := <innermost(norm)> term 
          
        exec :
          prog -> <eval> (<bottomup(n)>Exec(prog), [init-comps]) 
        
        norm:
          MapExtend(map1, map2) -> <conc> (map1, map2)
         
      
      rules // built-ins
        
        n = try(norm)
      	
        norm:
          MapEmpty() -> ["[]"]
          
        norm:
          Map1(x,y) -> ["[Bind(x,y)]"]
              
        norm:
          MapSelect(key, map) -> value
          where <fetch(?Bind(key, value))> map  
          
        norm:
          Fresh() -> <new>
        
        /*
        The following rules should be somewhere:
        
        IsValue(x) = true
        -----------------
         Exec(x) --> x
		
        x --> y , Exec(x) --> y
        -----------------------
           Exec(x) --> y
        */
                     
      [section''*]
    ]
    where section'* := <unstrict-rules; desugar-all> section*;
          <extract-writables> section'* ;
          <extract-readables> section'* ;
          <extract-components> section'* ;
          section''*  := <translate-sections> section'* ;
          //cs  := <declare-constructors; separate-by(|"\n"); concat-strings> section*;
          init-comps := $<[<<CompList; filter(not(IsWritable)); tr-list(\name -> $<<name>([])>\|",")>>]>
          
rules // declare constructors
  
  declare-constructors =
    collect-all(declare-constructor, union)
    
  declare-constructor :
    Con(name, []) -> $[[name]: T]

  declare-constructor :
    Con(name, t*) -> $[[name]: [<tr-list(!"T"|" * ")>t*] -> T]
    where <not([])> t*

  declare-constructor :
    LabelComp(name, _) -> $[[name]: T -> T]
 
       
rules // translate rules
  
  translate-sections =
    map(translate-section); concat-strings

  translate-section :
    Imports(imp*) -> 
      $[imports [<map(?Import(<id>)); separate-by(|"\n  ")>imp*]]
     
  translate-section :
    Rules(r*) -> 
      $[rules
      	  
      	  [rs]]
    where
      rs := <filter(translate-rule); concat-strings> r*
    
  translate-rule :
    Rule(prem*, _, TermEq(lhs, rhs)) -> $[
      norm:       
        [<pp-term>lhs] -> [<pp-term-norm> rhs]
        where [prems]
    ]
    where (_, prems) := <translate-premisses> (1, prem*)
     
  translate-premisses :
    (num, []) -> (num, $[id])
    
  translate-premisses :
    (num, [Formula(TermEq(lhs, rhs)) | prem*]) -> (num', prems')
    where (num', prems) := <translate-premisses>(num, prem*);
          prems' := $[[<pp-term>rhs] := [<pp-term-norm>lhs]; 
                      [prems]]
  
rules // translate dynamic

  translate-rule :
    Rule(prem*, _, Relation(Reads(r*), Source(lhs, sc*), DynamicEmitted(e*), Target(rhs, tc*))) -> $[
      eval:       
        ([<pp-term>lhs], [comps-lhs]) -> ([<pp-term-norm> rhs], [comps-rhs])
        where debug(!"eval: "); 
              [initsprems] 
    ]
    where comps-lhs := <CompPatLhs> 1;
          inits := <conc; label-comp-inits(|1)> (r*, sc*);
          (num, prems) := <translate-premisses> (2, prem*);
          initsprems := <if (?"") then !$[[prems]] else !$[[inits]
                                                            [prems]] end> inits;
          comps-rhs := <conc; label-comp-conclusion(|num)> (e*, tc*)
            
  label-comp-inits(|num) = 
    if ?[] then !$[] else map(label-comp-init(|num)); concat-strings end
  
  label-comp-init(|num) :
    LabelComp(name, t) -> $[[<pp-term>t] := [<lower-case>name]_[num];]
    
  label-comp-premisse(|num) :
    comps -> $<[<<separate-by(|",")> t*>]>
    where
      CompList; 
      filter(not(IsWritable); (
        {t: \ comp-name -> $[[comp-name]([<pp-term-norm>t])]
              where <fetch(?LabelComp(comp-name, t))> comps \ }        
        <+ ( not(IsReadable) ; \ comp-name -> $[[comp-name]([<lower-case>comp-name]_[<subt>(num,1)])] \ )
        <+ ( IsReadable ; \ comp-name -> $[[comp-name]([<lower-case>comp-name]_1)] \ )        
        )
      ) => t*

  label-comp-conclusion(|num) :
    comps -> $<[<<separate-by(|",")> t*>]>
    where
      CompList;
      filter(not(IsReadable)); 
      map(
        {t: \ comp-name -> $[[comp-name]([<pp-term-norm>t])]
              where <fetch(?LabelComp(comp-name, t))> comps \ }       
        <+ if not(IsWritable) <+ <eq> (num, 3) then       
              \ comp-name -> $[[comp-name]([<lower-case>comp-name]_[<subt>(num,1)])] \ 
           else if <gt> (num, 3) then
               \ comp-name -> $[[comp-name](<concat>["["][<range; map(\i -> $[[<lower-case>comp-name]_[i]] \); separate-by(|","); concat-strings> (2, num)]["]"])] \
           else 
               \ comp-name -> $<<comp-name>([])> \
           end end
      ) => t*
               
  translate-premisses :
    (num, [Formula(Relation(Reads(r*), Source(lhs, sc*), DynamicEmitted(e*), Target(rhs, tc*))) | prem*]) -> 
    (num', $[<eval>([<pp-term-norm>lhs], [comps-lhs]) => ([<pp-term> rhs], [comps-rhs]);
             [initsprems]])
    where comps-lhs := <conc; label-comp-premisse(|num)> (r*, sc*);
          comps-rhs := <CompPatRhs> num;
          inits     := <conc; label-comp-inits(|num)> (e*, tc*);
          (num', prems) := <translate-premisses> (<add>(num, 1), prem*);
          initsprems := <if (?"") then !$[[prems]] else !$[[inits]
                                                           [prems]] end> inits         
          


    
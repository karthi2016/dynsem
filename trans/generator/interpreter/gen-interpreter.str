module generator/interpreter/gen-interpreter

imports
	include/ds
	lib/editor-common.generated
	ds
	sugar
	explicate
	factorize
	lib/runtime-libraries/org.spoofax.meta.runtime.libraries/nabl/-
	lib/runtime-libraries/org.spoofax.meta.runtime.libraries/relations/-
	lib/runtime-libraries/org.spoofax.meta.runtime.libraries/index/-
	lib/runtime-libraries/org.spoofax.meta.runtime.libraries/task/-
	generator/interpreter/java-templates
  names
  libjava-front
  
rules
  
  gen-package-name = !$[[<language>].generated.interpreter]
  
  generate-interpreter:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
    	task-setup(|project-path);
    	index-setup(|<language>, project-path)
    with
      filename := <guarantee-extension(|"interpreter.aterm")> path;
      result   := <to-java-interpreter> ast

rules
  
  to-java-interpreter =
    explicate-module;
    factorize-module;
    alltd(escape-variable-names);
    fuse-sections;
    merge-overlapping-rules;
    optimize-environments;
    ?mod@Module(_, _);
    where(!""; debug(!9));
    sort-iface* := <sorts-to-java-interpreter> mod

rules /* rename variables */

  escape-variable-names:
    t -> <alltd(Var(escape-identifier) <+ VarRef(escape-identifier))> t
  
  escape-identifier = string-replace(|"'", "_")

rules
	
	fuse-sections:
		Module(mod, body*) -> Module(mod, [Signatures([sort-decl*, cons-decl*]), rule-decl*])
		with
			sort-decl* := <collect-all(?Sorts(<id>)); concat> body*;
      cons-decl* := <collect-all(?Constructors(<id>)); concat> body*;
      rule-decl* := <collect-all(?Rules(<id>)); concat> body*

signature
  constructors
    MergePoint: List(MergeAlternative)-> Premise
    MergeAlternative: Premise * List(Premise) -> MergeAlternative

rules /* merge ovelapping rules */

  merge-overlapping-rules:
    Module(mod, body*) -> Module(mod, [sig*, merged-rule*])
    with
      sig* := <collect-all(?Signatures(_))> body*
    with
      cons-arity* := <collect-all(\ ConsDecl(cons, args, _, _) -> (cons, <length> args) \); make-set> body*;
      rule* := <collect-all(?Rule(_, _, _))> body*;
      merged-rule* := <map(group-rules(|rule*)); unzip; Snd; map(merge-rules); concat> cons-arity*
  
  group-rules(|rule*):
    (cons, arity) -> (cons, cons-rule*)
    with
      cons-rule* := <filter(where(is-rule-matching-cons(|cons, arity)))> rule*
  
  is-rule-matching-cons(|cons-goal, arity) =
    ?Rule(_, _, Relation(_, Source(Con(cons-actual, conargs), _), _, _));
    <strip-annos; eq> (cons-actual, cons-goal);
    <eq> (arity, <length> conargs)
  
  merge-rules:
    [] -> []

  merge-rules:
    rule*@[x | xs] -> rule'*
    with
      rule'* := <foldl(merge-rules)> (xs, [x])

  merge-rules:
    (r1@Rule(_, _, rel1), rule*) -> [rule'*, merged-rule]
    where
      r2 := <fetch-elem(where(?Rule(_, _, <strip-annos> rel1)))> rule*
    with
      merged-rule := <merge-rule> (r1, r2)
      ; rule'* := <filter(not(?r2))> rule*
  
  merge-rules:
    (r1@Rule(_, _, rel1), rule*) -> [rule*, r1]
    where
      <not(fetch-elem(?Rule(_, _, <strip-annos> rel1)))> rule*
  
  merge-rule:
    (Rule(prem1*, bar1, rel1), Rule(prem2*, bar2, rel2)) -> Rule(prem-merged*, bar1, rel1)
    where
    	<strip-annos; eq> (rel1, rel2)
    with
      prem-merged* := <merge-premises> (prem1*, prem2*)
  
  // there are no premises
  merge-premises:
    ([], []) -> []
  
  // the first premises are not the same
  merge-premises:
    ([p1 | p1xs], [p2 | p2xs]) -> [ MergePoint([MergeAlternative(p1, p1xs), MergeAlternative(p2, p2xs)])]
    where
      <strip-annos; not(eq)> (p1, p2)
  
  // the first premises are the same
  merge-premises:
    ([p1 | p1xs], [p2 | p2xs]) -> [p1 | <merge-premises> (p1xs, p2xs)]
    where
      <strip-annos; eq> (p1, p2)

signature
  constructors
    OptMap: List(Term) -> Term

rules /* optimize environments */

  optimize-environments = alltd(optimize-environment)

  optimize-environment:
    mex@MapExtend(_, _) -> OptMap(<implode-env-extend; eliminate-env-blanks> mex)

  implode-env-extend:
    MapExtend(map1, map2) -> [ bind1*, bind2* ]
    with
      bind1* := <implode-env-extend> map1
      ; bind2* := <implode-env-extend> map2

  implode-env-extend:
    Map([]) -> [ Map([]) ]
  
  implode-env-extend:
    Map([bind@Bind(_, _)]) -> [ bind ]
  
  implode-env-extend:
    v@VarRef(_) -> [ v ]
  
  eliminate-env-blanks:
    [ Map([]), bind | xsbind ] -> <eliminate-env-blanks> [bind | xsbind]
  
  eliminate-env-blanks:
    [ bind | xsbind ] -> [bind | <eliminate-env-blanks> xsbind ]
    where
      <not(?Map([]))> bind
  
  eliminate-env-blanks:
    [] -> []

rules /* generate interfaces for declared sorts */

  sorts-to-java-interpreter:
    Module(mod, body*) -> <map(sort-to-java-interpreter)> sort-pair*
    with
      debug(!1);
      decl* := <collect-all(?SortDecl(_, _) + ?InjDecl(_, _, _))> body*;
      debug(!2);
      decl-pair* := <map(match-with-injected-sort(|decl*))> decl*;
      debug(!3);
      sort-pair* := <map((get-sort-name, map(get-sort-name)); add-term-sort)> decl-pair*
      ;debug(!4)
  
  match-with-injected-sort(|decl*):
    sdec -> (sdec, ssdec*)
    where
      srt := <get-sort-name> sdec
    with
      sdef := <get-annos; fetch-elem(?Def(_))> srt;
      ssdec* := <filter(where(?InjDecl(_, <id>, _); nabl-collect-one-resolved-def; ?sdef))> decl*
  
  add-term-sort:
    (srt, srt*) -> (srt, ["Term", srt*])
  
  get-sort-name = ?SortDecl(<id>, _) + ?InjDecl(<id>, _, _)

  // backend for Sort -> Java
  sort-to-java-interpreter:
    (srt, srt*) ->
			JAVA_INTERFACE_MULTIPLE(
			  |[ package x_pkgname; ]|
			  ,  [ |[ import org.metaborg.meta.interpreter.framework.*; ]| ]
			  , $[I_[srt]]
			  , <map(get-sort-java-name; string-to-java-iface-name)> srt*
			)
	 with
	 	x_pkgname := <gen-package-name>
  
  string-to-java-iface-name:
  	s -> InterfaceType(TypeName(Id(s)), None())
  	where
  		is-string
  
  get-sort-java-name = get-native-sort-java-name <+ get-user-sort-java-name
  
  get-native-sort-java-name:
  	"Term" -> "INode"
  
  get-native-sort-java-name:
  	"Value" -> "Value"
  
  get-native-sort-java-name:
  	"Map" -> "I_InterpreterFrame"
  
  get-user-sort-java-name:
  	term -> $[I_[term]]
  	where
  		is-string
  

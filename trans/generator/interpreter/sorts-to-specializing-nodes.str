module generator/interpreter/sorts-to-specializing-nodes

imports
  ds
  include/ds
  lib/editor-common.generated
  generator/interpreter/sorts-to-java
  generator/interpreter/gen-interpreter
  generator/interpreter/constructors-to-java
  lib-ds
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/nabl/-
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/types/-
  libjava-front
  names
  
rules
  
  sorts-to-specializing-nodes:
    Module(mod, body*) -> generic-node-class*
    with
      strip-annos; debug(!"A ");
      example-read* := <collect-one(get-rule-conclusion-environments)> body*;
      strip-annos; debug(!"B ");
      example-heap* := <collect-one(get-rule-conclusion-inheaps)> body*;
      strip-annos; debug(!"C ");
      sort-decl* := <collect-all(?SortDecl(_) + ?InjDecl(_, _))> body*;
      strip-annos; debug(!"D ");
      sort-specialization-decl* := <map(match-with-cons(|body*))> sort-decl*;
      strip-annos; debug(!"E ");
      generic-node-class* := <map(sort-cons-to-generic-node(|[example-read*, example-heap*]))> sort-specialization-decl*;
      strip-annos; debug(!"F ")
  
  match-with-cons(|body*):
    sort-decl -> (sort-decl, <map(?ConsDecl(<id>, _, _) + ?InternalConsDecl(<id>, _, _) + ?InjDecl(<id>, _))> cons*)
    where
      s := <get-sort-name> sort-decl
    with
      sdef := <get-annos; fetch-elem(?Def(_))> s;
      cons* := <collect-all(where((?ConsDecl(_, _, <id>) + ?InternalConsDecl(_, _, <id>) + ?InjDecl(_, <id>)); nabl-collect-one-resolved-def; ?sdef))> body*
  
  sort-cons-to-generic-node(|read*):
    (sort-decl, specialization-decl*) ->
      compilation-unit |[ 
      	package x_pkgname;
        
        import org.metaborg.meta.interpreter.framework.*;
        import org.spoofax.interpreter.terms.*;
        
        public class x_gennodename extends AbstractNode implements x_sortname {
          
          private IStrategoTerm term;
          
          public x_gennodename(INodeSource source, IStrategoTerm term) {
            this.setSourceInfo(source);
            this.term = term;
          }
          
          @Override
          public x_resultname execute(param*) {
            if (subterm instanceof IStrategoAppl) {
              final IStrategoAppl term = (IStrategoAppl) subterm;
              final String name = term.getName();
              bstm1*
            }
            
            bstm2*
            
            throw new RewritingException();
          }
          
        }
      ]|
    with
      debug(!1);
      x_pkgname := <gen-package-name>;
      debug(!2);
      sort-name := <get-sort-name> sort-decl;
      debug(!3);
      x_gennodename := $[Generic_[sort-name]];
      debug(!4);
      x_sortname := <get-sort-java-name> sort-name;
      debug(!5);
      x_resultname := $[[<language>]_Result];
      debug(!6);
      param* := <map-with-index(read-to-inode-evaluate-params)> read*;
      debug(!7);
      (cons-decl*, inj-decl*) := <partition(not(?InjDecl(_, _)))> specialization-decl*;
      debug(!8);
      bstm1* := <specializations-to-java(|read*)> cons-decl*;
      debug(!9);
      bstm2* := <specializations-to-java(|read*)> inj-decl*;  
      debug(!10)

  specializations-to-java(|read*):
    [] -> []

  specializations-to-java(|read*):
  	[InjDecl(_, sort) | xs] ->
  	  bstm* |[
  	 	 try {
  	 		 return replace(new x_gennodename(getSourceInfo(), term)).execute(e*);
  	 	 } catch(RewritingException x_exname) {
  	 		 bstm*
  	 	 }
  	 ]|
    with
      debug(!16);
    	x_exname := <newname>;
      debug(!17);
    	sort-name := <get-sort-name> sort;
      debug(!18);
    	x_gennodename := $[Generic_[sort-name]];
      debug(!19);
    	e* := <map-with-index(read-to-varref)> read*;
      debug(!20);
    	bstm* := <specializations-to-java(|read*)> xs
      ;debug(!21)
  
  specializations-to-java(|read*):
    [cons-name | xs] ->
      bstm* |[
        if(name.equals(e) && term.getSubtermCount() == i_arity) {
          // bstm1*   
        } else {
          bstm2*
        }
        throw new RewritingException();
      ]|
    with
      debug(!11);
      e := Lit(String([Chars(<escape> cons-name)]));
      debug(!12);
      (ty*, ty) := <get-type> cons-name;
      debug(!13);
      i_arity := $[[<length> ty*]];
      debug(!14);
      bstm2* := <specializations-to-java(|read*)> xs
      ;debug(!15)

  read-to-varref:
    (idx, _) -> e |[ x_idx ]|
    with
      x_idx := $[_[idx]]
      

      

module generator/interpreter/pre-generation

imports
  include/ds
  ds
  pp
  lib-ds
  sugar
  explicate
  factorize
  
rules
  
  pre-generation-transform-editor:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"pregen.ds")> path;
      result   := <desugar-all; pre-generation-transform; sugar-all; pp-debug> selected
      
  pre-generation-transform =
    // explicate-module;
    // factorize-module;
    alltd(escape-variable-names);
    fuse-sections;
    merge-overlapping-rules;
    optimize-environments

rules /* rename variables */

  escape-variable-names:
    t -> <alltd(Var(escape-identifier) <+ VarRef(escape-identifier) <+ MatchedVar(escape-identifier))> t
  
  escape-identifier = string-replace(|"'", "_")

rules
  
  fuse-sections:
    Module(mod, body*) -> Module(mod, [import, Signatures(signatures), Rules(rule-decl*)]) 
    with
      import       := <collect-all(?Imports(<id>)); concat; !Imports(<id>)> body*;
      sort-decl    := <collect-all(?Sorts(<id>)); concat; !Sorts(<id>)> body*;
      semcomp-decl := <collect-all(?SemanticComponents(<id>)); concat; !SemanticComponents(<id>)> body*;
      intsort-decl := <collect-all(?InternalSorts(<id>)); concat; !InternalSorts(<id>)> body*;
      natty-decl   := <collect-all(?NativeDataTypes(<id>)); concat; !NativeDataTypes(<id>)> body*;
      cons-decl    := <collect-all(?Constructors(<id>)); concat; !Constructors(<id>)> body*;
      intcons-decl := <collect-all(?InternalConstructors(<id>)); concat; !InternalConstructors(<id>)> body*;
      natops-decl  := <collect-all(?NativeOperators(<id>)); concat; !NativeOperators(<id>)> body*;
      values-decl  := <collect-all(?Values(<id>)); concat; !Values(<id>)> body*;
      arrow-decl   := <collect-all(?ArrowDeclarations(<id>)); concat; !ArrowDeclarations(<id>)> body*;
      signatures    := [ sort-decl, natty-decl, cons-decl, semcomp-decl, intsort-decl, intcons-decl, values-decl, arrow-decl ];
      rule-decl*    := <collect-all(?Rules(<id>)); concat> body*

rules /* merge ovelapping rules */

  merge-overlapping-rules:
    Module(mod, [imports, signatures, Rules(rule*)]) -> Module(mod, [imports, signatures, Rules(merged-rule*)])
    with
      cons-arity* := <collect-all(cons-decl-pair-arity); make-set> signatures;
      arrow-name* := <get-module-arrow-declarations; map(get-arrow-name)> signatures;
      cons-grouped-rule* := <map(group-rules-by-cons(|rule*))> cons-arity*;
      // a list of lists of rules: [ [ [z...], [y...], [x...] ] ]
      cons-arrow-grouped-rule* := <map(group-rules-by-arrow(|arrow-name*))> cons-grouped-rule*;
      merged-rule* := <map(map({ ?allfail; merge-rules })); flatten-list> cons-arrow-grouped-rule*
  
  cons-decl-pair-arity:
    ConsDecl(cons, args, _) -> (cons, <length> args)
  
  cons-decl-pair-arity:
    InternalConsDecl(cons, args, _) -> (cons, <length> args)
  
  group-rules-by-cons(|rule*):
    (cons, arity) -> <filter(where(is-rule-matching-cons(|cons, arity)))> rule*
  
  group-rules-by-arrow(|arrow-name*):
  	rule* -> <strip-annos; map(\ arrow-name -> <filter(where(get-rule-relation; get-relation-arrow-name; strip-annos; ?arrow-name))> rule* \)> arrow-name*
  
  is-rule-matching-cons(|cons-goal, arity) =
    ?Rule(_, _, Relation(_, Source(Con(cons-actual, conargs), _), _, _));
    <strip-annos; eq> (cons-actual, cons-goal);
    <eq> (arity, <length> conargs)
  
  merge-rules:
    [] -> []

  merge-rules:
    [x | xs] -> r*
    with
      r* := <foldl(merge-rules)> (xs, x)

  // normal merge
  merge-rules:
  	(Rule(l-prem*, l-bar, l-rel), Rule(r-prem*, r-bar, r-rel)) -> Rule(merged-prem*, l-bar, l-rel)
  	where
  	  <not(collect-one(?AllFail()))> l-prem*
  	where
  		<strip-annos; eq> (l-rel, r-rel)
    with
      merged-prem* := <merge-premises> (r-prem*, l-prem*)

  // merge with an all-fail rule
  merge-rules:
  	(Rule(l-prem*, l-bar, l-rel), Rule(r-prem*, r-bar, r-rel)) -> Rule([TryOr(r-prem*, l-prem'*)], l-bar, l-rel)
  	where
  	  <collect-one(?AllFail())> l-prem*
  	where
  		<strip-annos; eq> (l-rel, r-rel)
  	with
  	  l-prem'* := <filter(not(?AllFail()))> l-prem*

  // there are no premises
  merge-premises:
    ([], []) -> []
  
  /*
  * IF the first premise on LHS is a TryOr(t*, o*)
  *
  * THEN we merge between t* and RHS
  *
  * NB: this can only happen if the TryOr is the only premise on the LHS  
  */
  merge-premises:
    ([ TryOr(try*, or*) ], [r | rxs]) -> [ TryOr(try-merged*, or*) ]
    with
      try-merged* := <merge-premises> (try*, [r | rxs])
  
  /*
  * IF the first premise on LHS is a merge point and the merge condition is the same as the right premise.
  *
  * THEN we eliminate the duplicate condition and merge the then branch of the merge with the remainder of the RHS
  *
  * NB: this can only happen if the merge point is the last premise on LHS
  */
  merge-premises:
    ([ MergePoint(cond, then*, else*) ], [r | rxs]) -> [ MergePoint(cond, then'*, else*) ]
    where
      <strip-annos; eq> (cond, r)
    with
      then'* := <merge-premises> (then*, rxs)
  
  /*
  * IF the first premise on the LHS is a merge point and the merge condition is NOT the same as the right premise.
  *
  * THEN we merge the else branch of the merge with the entire RHS block.
  *
  * NB: this can only happen if the merge point is the last premise on LHS
  */
  merge-premises:
    ([ MergePoint(cond, then*, else*) ], [r | rxs]) -> [ MergePoint(cond, then*, else'*) ]
    where
      <strip-annos; not(eq)> (cond, r)
    with
      else'* := <merge-premises> (else*, [r | rxs])
  
  /*
  * IF the first premise on LHS is not a merge point, and it is equal to the first premise on the RHS.
  *
  * THEN share the first premise and continue merging the rest
  */
  merge-premises:
    ([l | lxs], [r | rxs]) -> [l | <merge-premises> (lxs, rxs)]
    where
      <not(?MergePoint(_, _, _))> l;
      <strip-annos; eq> (l, r)
  /*
  * IF the first premise on LHS is not a merge point, and it is not equal to the first premise on the RHS.
  *
  * THEN create a merge point
  */
  merge-premises:
    ([l | lxs], [r | rxs]) -> [ MergePoint(l, lxs, [r | rxs]) ]
    where
      <not(?MergePoint(_, _, _))> l;
      <strip-annos; not(eq)> (l, r)

signature
  constructors
    OptMap: List(Term) -> Term

rules /* optimize environments */

  optimize-environments = alltd(optimize-environment)

  optimize-environment:
    mex@MapExtend(_, _) -> OptMap(<implode-env-extend; eliminate-env-blanks> mex)

  optimize-environment:
    map@Map(_) -> OptMap(<implode-env-extend; eliminate-env-blanks> map)

  implode-env-extend:
    MapExtend(map1, map2) -> [ bind1*, bind2* ]
    with
      bind1* := <implode-env-extend> map1;
      bind2* := <implode-env-extend> map2

  implode-env-extend:
    Map([]) -> [ Map([]) ]
  
  implode-env-extend:
    Map([bind@Bind(_, _)]) -> [ bind ]
  
  implode-env-extend:
    v@VarRef(_) -> [ v ]
  
  eliminate-env-blanks:
    [ Map([]), bind | xsbind ] -> <eliminate-env-blanks> [bind | xsbind]
  
  eliminate-env-blanks:
    [ bind | xsbind ] -> [bind | <eliminate-env-blanks> xsbind ]
    where
      <not(?Map([]))> bind
  
  eliminate-env-blanks:
    [] -> []

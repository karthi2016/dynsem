module generator/interpreter/pre-generation

imports
  include/ds
  ds
  lib-ds
  sugar
  explicate
  factorize
  
rules
  
  pre-generation-transform =
    // explicate-module;
    // factorize-module;
    alltd(escape-variable-names);
    fuse-sections;
    merge-overlapping-rules;
    optimize-environments

rules /* rename variables */

  escape-variable-names:
    t -> <alltd(Var(escape-identifier) <+ VarRef(escape-identifier))> t
  
  escape-identifier = string-replace(|"'", "_")

rules
  
  fuse-sections:
    Module(mod, body*) -> Module(mod, [Signatures(signatures), Rules(rule-decl*)])
    with
      sort-decl*    := <collect-all(?Sorts(<id>)); concat> body*;
      semcomp-decl* := <collect-all(?SemanticComponents(<id>)); concat> body*;
      intsort-decl* := <collect-all(?InternalSorts(<id>)); concat> body*;
      natty-decl*   := <collect-all(?NativeDataTypes(<id>)); concat> body*;
      cons-decl*    := <collect-all(?Constructors(<id>)); concat> body*;
      intcons-decl* := <collect-all(?InternalConstructors(<id>)); concat> body*;
      natops-decl*  := <collect-all(?NativeOperators(<id>)); concat> body*;
      values-decl*  := <collect-all(?Values(<id>)); concat> body*;
      arrow-decl*   := <collect-all(?ArrowDeclarations(<id>)); concat> body*;
      signatures    := [ sort-decl*, natty-decl*, cons-decl*, semcomp-decl*, intsort-decl*, cons-decl*, intcons-decl*, values-decl*, arrow-decl* ];
      rule-decl*    := <collect-all(?Rules(<id>)); concat> body*

signature
  constructors
    
    MergePoint: Formula * List(Formula) * List(Formula) -> Premise

rules /* merge ovelapping rules */

  merge-overlapping-rules:
    Module(mod, body*) -> Module(mod, [sig*, Rules(merged-rule*)])
    with
      sig* := <collect-all(?Signatures(_))> body*
    with
      cons-arity* := <collect-all(\ ConsDecl(cons, args, _) -> (cons, <length> args) \); make-set> body*;
      rule* := <collect-all(?Rule(_, _, _))> body*;
      debug(!"A1 ");
      arrow-name* := <get-module-arrow-declarations; map(get-arrow-name)> body*;
      debug(!"A2 ");
      cons-grouped-rule* := <map(group-rules-by-cons(|rule*))> cons-arity*;
      debug(!"A3 ");
      cons-arrow-grouped-rule* := <map(group-rules-by-arrow(|arrow-name*))> cons-grouped-rule*;
      debug(!"A4 ");
      merged-rule* := []
      // merged-rule* := <map(map(merge-rules)); debug(!"A5 "); flatten-list; filter(not(?[]))> cons-arrow-grouped-rule*
      // ; debug(!"A6 ")
      // merged-rule* := <
      // 	map(
      // 	 debug(!"A1 ");
      // 	 group-rules(|rule*);
      // 	 debug(!"A2 "));
      // 	 unzip; Snd;
      // 	 map(debug(!"A3 "); merge-rules; debug(!"A4 ")); debug(!"A5 "); concat; debug(!"A6 ")> cons-arity*
  
  group-rules-by-cons(|rule*):
    (cons, arity) -> <filter(where(is-rule-matching-cons(|cons, arity)))> rule*
  
  group-rules-by-arrow(|arrow-name*):
  	rule* -> <strip-annos; map(\ arrow-name -> <filter(where(get-rule-arrow-name; strip-annos; ?arrow-name))> rule* \)> arrow-name*
  
  is-rule-matching-cons(|cons-goal, arity) =
    ?Rule(_, _, Relation(_, Source(Con(cons-actual, conargs), _), _, _));
    <strip-annos; eq> (cons-actual, cons-goal);
    <eq> (arity, <length> conargs)
  
  merge-rules:
    [] -> []

//   merge-rules:
//     rule*@[x | xs] -> rule'*
//     with
//       debug(!"M0 ");
//       rule'* := <foldl(merge-rules)> (xs, [x])
//       ; debug(!"M! ")
// 
//   merge-rules:
//     (r1@Rule(_, _, rel1), rule*) -> [rule'*, merged-rule]
//     where
//       debug(!"M2 ");
//       r2 := <fetch-elem(where(?Rule(_, _, <strip-annos> rel1)))> rule*
//     with
//       debug(!"M3 ");
//       merged-rule := <merge-rule> (r1, r2);
//       debug(!"M4 ");
//       rule'* := <filter(not(?r2))> rule*
//       ; debug(!"M5 ")
//   
//   merge-rules:
//     (r1@Rule(_, _, rel1), rule*) -> [rule*, r1]
//     where
//       debug(!"M6 ");
//       <not(fetch-elem(?Rule(_, _, <strip-annos> rel1)))> rule*
//       ; debug(!"M7 ")
//   
//   merge-rule:
//     (Rule(prem1*, bar1, rel1), Rule(prem2*, bar2, rel2)) -> Rule(prem-merged*, bar1, rel1)
//     where
//       debug(!"M8 ");
//       <strip-annos; eq> (rel1, rel2)
//     with
//       debug(!"M9 ");
//       prem-merged* := <merge-premises> (prem1*, prem2*)
//       ; debug(!"M10 ")
//   
//   // there are no premises
//   merge-premises:
//     ([], []) -> []
//   
//   // the first premises are not the same
//   merge-premises:
//     ([p1 | p1xs], [p2 | p2xs]) -> [ MergePoint(p1, p1xs, [p2 | p2xs]) ]
//     where
//       <strip-annos; not(eq)> (p1, p2)
//   
//   // the first premises are the same
//   merge-premises:
//     ([p1 | p1xs], [p2 | p2xs]) -> [p1 | <merge-premises> (p1xs, p2xs)]
//     where
//       <strip-annos; eq> (p1, p2)

signature
  constructors
    OptMap: List(Term) -> Term

rules /* optimize environments */

  optimize-environments = alltd(optimize-environment)

  optimize-environment:
    mex@MapExtend(_, _) -> OptMap(<implode-env-extend; eliminate-env-blanks> mex)

  optimize-environment:
    map@Map(_) -> OptMap(<implode-env-extend; eliminate-env-blanks> map)

  implode-env-extend:
    MapExtend(map1, map2) -> [ bind1*, bind2* ]
    with
      bind1* := <implode-env-extend> map1
      ; bind2* := <implode-env-extend> map2

  implode-env-extend:
    Map([]) -> [ Map([]) ]
  
  implode-env-extend:
    Map([bind@Bind(_, _)]) -> [ bind ]
  
  implode-env-extend:
    v@VarRef(_) -> [ v ]
  
  eliminate-env-blanks:
    [ Map([]), bind | xsbind ] -> <eliminate-env-blanks> [bind | xsbind]
  
  eliminate-env-blanks:
    [ bind | xsbind ] -> [bind | <eliminate-env-blanks> xsbind ]
    where
      <not(?Map([]))> bind
  
  eliminate-env-blanks:
    [] -> []

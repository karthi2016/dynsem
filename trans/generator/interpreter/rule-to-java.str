module generator/interpreter/rule-to-java

imports
  include/ds
  ds
  lib/editor-common.generated
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/nabl/-
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/types/-
  generator/interpreter/gen-interpreter
  generator/interpreter/constructors-to-java
  generator/interpreter/sorts-to-java
  generator/interpreter/pre-generation
  names
  names.manual

rules // generate a dummy-bodied evaluate method
	
	rule-to-java-dummy-evalmethod:
		rule* ->
		  class-body-dec |[
		  	public x_returnclass execute(param*) {
		  		throw new InterpreterException("Non executable node");
		  	}
		  ]|
		with
      x_returnclass := $[[<language>]_Result];
      env* := <collect-one(get-rule-conclusion-environments)> rule*;
      heap* := <collect-one(get-rule-conclusion-inheaps)> rule*;
      param* := <map(rule-reads-to-evaluate-params)> [env*, heap*]

signature
  constructors
    OpSeq: Op * Op -> Op
        
rules // generate a full-bodied evaluate method
  
  rule-to-java-evalmethod:
    r@Rule(prem*, _, Relation(reads, source, _, target)) ->
      class-body-dec |[
        public x_returnclass execute(param*) {
          bstm*
        }
      ]|
    with
      debug(!"A ");
      x_returnclass := $[[<language>]_Result];
      debug(!"B ");
      env* := <get-rule-conclusion-environments> r;
      debug(!"C ");
      heap* := <get-rule-conclusion-inheaps> r;
      debug(!"D ");
      param* := <map(rule-reads-to-evaluate-params)> [env*, heap*];
      debug(!"E ");
      opweave := <foldr(!target, \ (op, weave) -> OpSeq(op, weave) \)> [source, prem*];
      strip-annos; debug(!"F ");
      bstm* := <ops-to-java> (opweave, []);
      debug(!"G ")
      
  rule-reads-to-evaluate-params:
  	LabelComp(ty, Var(x_name)) -> param |[ ~type:jiface x_name ]|
  	with
  		x_sort := <get-sort-java-name> ty;
      jiface := type |[ x_sort ]|

rules // bottomup right to left compilation of operations
  
  ops-to-java:
    (OpSeq(op1, op2), stm-pre*) -> stm*
    with
      stm-down* := <ops-to-java> (op2, stm-pre*);
      stm* := <op-to-java> (op1, stm-down*)

  // ops-to-java:
  //   OpSeq(op1, op2) -> bstm*
  //   with
  //     debug(!1);
  //     stm-down* := <ops-to-java> op2;
  //     <debug(!2)> (op1, stm-down*);
  //     bstm* := <op-to-java> (op1, stm-down*)
  //     ;debug(!3)

  ops-to-java:
    (op, stm-pre*) -> <debug(!4); op-to-java; debug(!5)> (op, stm-pre*)
    where
      <not(?OpSeq(_, _))> op
  
rules // compilation of individual operations
  
  // source part. we ignore data-part because it is bound in the execute header
  op-to-java:
    (Source(Con(_, arg*), _), stm*) -> [var-bind*, stm*]
    with
      debug(!6);
      var-bind* := <map-with-index(debug(!"IN "); field-to-varbind; debug(!"OUT "))> arg*
      ; debug(!7)

  field-to-varbind:
    (idx, var@Var(x_v)) -> bstm* |[ final x_type x_v = x_idx; ]|
    with
      debug(!8);
      x_idx := $[_[<int-to-string> idx]];
      debug(!9);
      var-ty := <get-type> var;
      debug(!10);
      x_type := <get-sort-java-name> var-ty
      ;debug(!11)

  op-to-java:
    (Target(VarRef(x_v), data-out*), []) ->
      bstm* |[
        final x_langresult x_resname = new x_langresult(x_v, e*);
        return x_resname;
      ]|
    with
      x_langresult := $[[<language>]_Result];
      x_resname := <newname>;
      e* := <map(?LabelComp(_, <id>); exp-to-java)> data-out*
  
  numbered-assign-to-java(|e_parent):
    (idx, LabelComp(_, ref)) -> bstm |[ e_parent.x_idx = e; ]|
    with
      x_idx := $[_[idx]];
      e := <exp-to-java> ref 

  op-to-java:
    (Formula(Match(lhs, rvar@Var(x_rvar))), bstm2*) ->
      bstm* |[
        bstm1*
        final x_type x_rvar = e_lvar;
        bstm2*
      ]|
    with
      (bstm1*, e_lvar) := <build-to-var> lhs;
      x_type := <get-type; get-sort-java-name> rvar
  
  op-to-java:
    (Formula(Match(lhs, rhs@Con(cons, bound-var*))), bstm3*) ->
      bstm* |[
      	bstm1*
      	if(e_lvar instanceof x_consname) {
      		final x_consname x_tempvar = (x_consname) e_lvar;
      		bstm2* // pattern-bound variables
      		bstm3* // rest of statements
      	} else {
      		throw new InterpreterException("Premise match failure");
      	}
      ]|
    with
    	(bstm1*, e_lvar) := <build-to-var> lhs;
    	x_consname := <get-cons-java-name> cons;
    	x_tempvar := <newname> "tmpbuild";
    	bstm2* := <map-with-index(read-out-to-vardec(|x_tempvar))> bound-var*
  
  build-to-var:
    Int(i) -> ([], e |[ i ]|)
  
  build-to-var:
    VarRef(x_vref) -> ([], e |[ x_vref ]|)
  
  build-to-var:
    Con(cons, args) -> 
      (
      	bstm* |[
      		bstm*
      		final x_consname x_builtvar = new x_consname(e*);
        ]|, e |[ x_builtvar ]|
      )
    where
      cons-kind := <get-cons-kind> cons;
      <not(?NativeOperator())> cons-kind
    with
    	x_builtvar := <newname> "tmpbuild";
    	x_consname := <get-cons-java-name> cons;
    	(bstms*, e*) := <map(build-to-var); unzip> args;
    	bstm* := <concat> bstms*

  build-to-var:
    Con(cons, args) ->
      (
        bstm* |[
          bstm*
          final x_type x_builtvar = x_pkg.Natives.x_consname(e*);
        ]|, e |[ x_builtvar ]|)
    where
      cons-kind := <get-cons-kind> cons;
      <?NativeOperator()> cons-kind
    with
      (_, ty) := <get-type> cons;
      x_type := <get-sort-java-name> ty;
      x_builtvar := <newname> "tmpbuild";
      x_consname := <get-cons-java-name> cons;
      x_pkg := <man-package-name>;
      (bstms*, e*) := <map(build-to-var); unzip> args;
      bstm* := <concat> bstms*
  
  op-to-java:
    (Formula(Relation(Reads(read*), Source(ref@VarRef(_), heap-in*), _, Target(Var(v-out), heap-out*))), bstm2*) ->
      bstm* |[
        final x_resultclass x_result = e_vin.execute(e*);
        final Value x_vout = x_result.value;
        bstm1*
        bstm2*
      ]|
    with
      x_resultclass := $[[<language>]_Result];
      x_result := <newname> "tmpresult";
      e* := <map(exp-to-java)> [read*, heap-in*];
      e_vin := <exp-to-java> ref;
      x_vout := v-out;
      bstm1* := <map-with-index(read-out-to-vardec(|x_result))> heap-out*
  
  read-out-to-vardec(|x_result):
  	(idx, LabelComp(ty, v@Var(_))) -> <read-out-to-vardec(|x_result)> (idx, v)
  
  read-out-to-vardec(|x_result):
    (idx, Var(v-out)) ->
      bstm |[
      	final x_type x_vout = x_result.x_idx;
      ]|
    with
    	x_type := <get-type; get-sort-java-name> v-out;
    	x_vout := v-out;
    	x_idx := $[_[idx]]

rules // term equality and inequality

  op-to-java:
    (f@Formula(TermEq(_, _)), bstm3*) ->
      bstm* |[
        bstm1*
        bstm2*
        if(e) {
        	bstm3*
        } else {
        	throw new InterpreterException("Equality check failed");
        }
      ]|
    with
      (bstm1*, bstm2*, e) := <eq-to-java> f
  
  op-to-java:
    (f@Formula(TermNeq(_, _)), bstm3*) ->
      bstm* |[
        bstm1*
        bstm2*
        if(e) {
          bstm3*
        } else {
          throw new InterpreterException("Inequality check failed");
        }
      ]|
    with
      (bstm1*, bstm2*, e) := <eq-to-java> f
  
  eq-to-java:
    Formula(TermEq(lhs, rhs)) -> (bstm1*, bstm2*, e |[ e_lvar.equals(e_rvar) ]|)
    where
      <get-type; not(is-sort-int)> lhs;
      <get-type; not(is-sort-int)> rhs
    with
      (bstm1*, e_lvar) := <build-to-var> lhs;
      (bstm2*, e_rvar) := <build-to-var> rhs

  eq-to-java:
    Formula(TermEq(lhs, rhs)) -> (bstm1*, bstm2*, e |[ e_lvar == e_rvar ]|)
    where
      <get-type; is-sort-int> lhs;
      <get-type; is-sort-int> rhs 
    with
      (bstm1*, e_lvar) := <build-to-var> lhs;
      (bstm2*, e_rvar) := <build-to-var> rhs

  eq-to-java:
    Formula(TermNeq(lhs, rhs)) -> (bstm1*, bstm2*, e |[ !e_lvar.equals(e_rvar) ]|)
    where
      <get-type; not(is-sort-int)> lhs;
      <get-type; not(is-sort-int)> rhs
    with
      (bstm1*, e_lvar) := <build-to-var> lhs;
      (bstm2*, e_rvar) := <build-to-var> rhs

  eq-to-java:
    Formula(TermNeq(lhs, rhs)) -> (bstm1*, bstm2*, e |[ e_lvar != e_rvar ]|)
    where
      <get-type; is-sort-int> lhs;
      <get-type; is-sort-int> rhs 
    with
      (bstm1*, e_lvar) := <build-to-var> lhs;
      (bstm2*, e_rvar) := <build-to-var> rhs
  
rules // merge alternative
  
  op-to-java:
    (MergePoint(guard, lbranch*@[lx | lxs], rbranch*@[rx | rxs]), bstm_rest*) ->
      bstm* |[
        bstm1*
        bstm2*
        if(e) {
          bstm_l*
        } else {
          bstm_r*
        }
      ]|
    with
      (bstm1*, bstm2*, e) := <eq-to-java> guard;
      lopweave := <foldr(!lx, \ (op, weave) -> OpSeq(op, weave) \)> lxs;
      ropweave := <foldr(!rx, \ (op, weave) -> OpSeq(op, weave) \)> rxs;
      bstm_l* := <ops-to-java> (lopweave, bstm_rest*);
      bstm_r* := <ops-to-java> (ropweave, bstm_rest*)

rules // fallback

  op-to-java:
    (something, bstm*) ->
      bstm* |[
        return "something unsupported";
        bstm*
      ]|
    with
      debug(!">>>> UNHANDLED OP >>>> ")


rules // expressions to java
  
  exp-to-java:
    VarRef(x_name) ->  e |[ x_name ]|
  
  exp-to-java:
  	LabelComp(_, VarRef(x_name)) -> e |[ x_name ]|




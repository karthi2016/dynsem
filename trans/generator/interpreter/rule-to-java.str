module generator/interpreter/rule-to-java

imports
  include/ds
  ds
  lib/editor-common.generated
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/nabl/-
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/types/-
  generator/interpreter/gen-interpreter
  generator/interpreter/constructors-to-java
  generator/interpreter/sorts-to-java
  generator/interpreter/pre-generation
  names
  names.manual
  libjava-front
  lib-ds
  
rules // generate a dummy-bodied evaluate method
	
	rule-to-java-dummy-evalmethod:
		rule* ->
		  class-body-dec |[
		  	public x_returnclass execute(param*) {
		  		throw new InterpreterException("Non executable node");
		  	}
		  ]|
		with
      x_returnclass := $[[<language>]_Result];
      env* := <collect-one(get-rule-conclusion-environments)> rule*;
      heap* := <collect-one(get-rule-conclusion-inheaps)> rule*;
      param* := <map(rule-reads-to-evaluate-params)> [env*, heap*]

signature
  constructors
    OpSeq: Op * Op -> Op
        
rules // generate a full-bodied evaluate method
  
  rule-to-java-evalmethod:
    r@Rule(prem*, _, Relation(reads, source, _, target)) ->
      class-body-dec |[
        public x_returnclass execute(param*) {
          bstm*
        }
      ]|
    with
      x_returnclass := $[[<language>]_Result];
      env* := <get-rule-conclusion-environments> r;
      heap* := <get-rule-conclusion-inheaps> r;
      param* := <map(rule-reads-to-evaluate-params)> [env*, heap*];
      opweave := <foldr(!target, \ (op, weave) -> OpSeq(op, weave) \)> [source, prem*];
      bstm* := <ops-to-java> (opweave, [])
      
  rule-reads-to-evaluate-params:
  	LabelComp(ty, Var(x_name)) -> param |[ ~type:jiface x_name ]|
  	with
  		x_sort := <get-sort-java-name> ty;
      jiface := type |[ x_sort ]|

rules // bottomup right to left compilation of operations
  
  ops-to-java:
    (OpSeq(op1, op2), stm-pre*) -> stm*
    with
      stm-down* := <ops-to-java> (op2, stm-pre*);
      stm* := <op-to-java> (op1, stm-down*)

  ops-to-java:
    (op, stm-pre*) -> <op-to-java> (op, stm-pre*)
    where
      <not(?OpSeq(_, _))> op
  
rules // compilation of individual operations
  
  // source part. we ignore data-part because it is bound in the execute header
  op-to-java:
    (Source(Con(_, arg*), _), stm*) -> [var-bind*, stm*]
    with
      var-bind* := <map-with-index(debug(!"IN "); field-to-varbind; debug(!"OUT "))> arg*

  field-to-varbind:
    (idx, var@Var(x_v)) -> bstm* |[ final x_type x_v = x_idx; ]|
    with
      x_idx := $[_[<int-to-string> idx]];
      var-ty := <get-type> var;
      x_type := <get-sort-java-name> var-ty

  op-to-java:
    (Target(VarRef(x_v), data-out*), []) ->
      bstm* |[
        bstm1*
        final x_langresult x_resname = new x_langresult(x_v, e*);
        return x_resname;
      ]|
    with
      x_langresult := $[[<language>]_Result];
      x_resname := <newname>;
      (e*, bstms*) := <map(?LabelComp(_, <id>); exp-to-java); unzip> data-out*;
      bstm1* := <concat> bstms*
  
  // numbered-assign-to-java(|e_parent):
  //   (idx, LabelComp(_, ref)) -> bstm* |[ bstm1* e_parent.x_idx = e; ]|
  //   with
  //     x_idx := $[_[idx]];
  //     (e, bstm1*) := <exp-to-java> ref 

  op-to-java:
    (Formula(Match(lhs, rvar@Var(x_rvar))), bstm2*) ->
      bstm* |[
        bstm1*
        final x_type x_rvar = e_lvar;
        bstm2*
      ]|
    with
      debug(!"A>>");
      (bstm1*, e_lvar) := <build-to-var> lhs;
      debug(!"B>>");
      x_type := <debug(!"Ba "); get-type; debug(!"Bb "); get-sort-java-name; debug(!"Bc ")> rvar
      ; debug(!"C>>")
  
  op-to-java:
    (Formula(Match(lhs, rhs@Con(cons, bound-var*))), bstm3*) ->
      bstm* |[
      	bstm1*
        final x_consname x_tempvar = e_lvar.match(x_consname.class);
      	if(x_tempvar != null) {
      		bstm2* // pattern-bound variables
      		bstm3* // rest of statements
      	} else {
      		throw new InterpreterException("Premise match failure");
      	}
      ]|
    with
    	(bstm1*, e_lvar) := <build-to-var> lhs;
    	x_consname := <get-cons-java-name> cons;
    	x_tempvar := <newname> "tmpbuild";
    	bstm2* := <map-with-index(read-out-to-vardec(|x_tempvar))> bound-var*
  
  build-to-var:
    Int(i) -> ([], e |[ i ]|)
  
  build-to-var:
    VarRef(x_vref) -> ([], e |[ x_vref ]|)
  
  build-to-var:
  	MapSelect(map, key) ->
  	 ([map-pre*, key-pre*, 
  	   bstm |[
  	     final IMatchable x_builtvar = e_map.read(e_key);
  	   ]|
  	  ], e |[ x_builtvar ]|)
  	with
  		(map-pre*, e_map) := <build-to-var> map;
  		(key-pre*, e_key) := <build-to-var> key;
  	  x_builtvar := <newname> "tmpbuild"
  
  build-to-var:
    Con(cons, args) -> 
      (
      	bstm* |[
      		bstm*
      		final x_consname x_builtvar = new x_consname(getSourceInfo(), e*);
        ]|, e |[ x_builtvar ]|
      )
    where
      cons-kind := <get-cons-kind> cons;
      <not(?NativeOperator() + ?Value())> cons-kind
    with
    	x_builtvar := <newname> "tmpbuild";
    	x_consname := <get-cons-java-name> cons;
    	(bstms*, e*) := <map(build-to-var); unzip> args;
    	bstm* := <concat> bstms*

  build-to-var:
    Con(cons, args) -> 
      (
        bstm* |[
          bstm*
          final x_consname x_builtvar = new x_consname(e*);
        ]|, e |[ x_builtvar ]|
      )
    where
      <get-cons-kind> cons => Value()
    with
      x_builtvar := <newname> "tmpbuild";
      x_consname := <get-cons-java-name> cons;
      (bstms*, e*) := <map(build-to-var); unzip> args;
      bstm* := <concat> bstms*

  build-to-var:
    Con(cons, args) ->
      (
        bstm* |[
          bstm*
          final x_type x_builtvar = x_pkg.Natives.x_consname(e*);
        ]|, e |[ x_builtvar ]|)
    where
      cons-kind := <get-cons-kind> cons;
      <?NativeOperator()> cons-kind
    with
      (_, ty) := <get-type> cons;
      x_type := <get-sort-java-name> ty;
      x_builtvar := <newname> "tmpbuild";
      x_consname := <get-cons-java-name> cons;
      x_pkg := <man-package-name>;
      (bstms*, e*) := <map(build-to-var); unzip> args;
      bstm* := <concat> bstms*
  
  op-to-java:
    (Formula(Relation(Reads(read*), Source(ref@VarRef(_), heap-in*), _, Target(Var(v-out), heap-out*))), bstm4*) ->
      bstm* |[
        bstm1*
        final x_resultclass x_result = e_vin.execute(e*);
        final AValue x_vout = x_result.value;
        bstm3*
        bstm4*
      ]|
    with
      x_resultclass := $[[<language>]_Result];
      x_result := <newname> "tmpresult";
      (e*, bstms1*) := <map(debug(!"3a "); exp-to-java; debug(!"3b ")); debug(!"3c "); unzip> [read*, heap-in*];
      bstm1* := <debug(!"4a "); concat> bstms1*;
      (e_vin, bstm2*) := <exp-to-java> ref;
      x_vout := v-out;
      bstm3* := <map-with-index(read-out-to-vardec(|x_result))> heap-out*
  
  read-out-to-vardec(|x_result):
  	(idx, LabelComp(ty, v@Var(_))) -> <read-out-to-vardec(|x_result)> (idx, v)
  
  read-out-to-vardec(|x_result):
    (idx, vdef@Var(v-out)) ->
      bstm |[
      	final x_type x_vout = x_result.x_getidx();
      ]|
    // where
    // 	debug(!1);
    //   sort-kind := <get-type; debug(!"1a "); get-sort-name; debug(!"1b "); get-sort-kind> vdef;
    // 	debug(!2);
    //   not(?Value())
    with
    	debug(!3);
    	x_type := <get-type; get-sort-java-name> vdef;
    	debug(!4);
    	x_vout := v-out;
    	debug(!5);
    	x_getidx := $[get_[idx]]
    	;debug(!6)

  // read-out-to-vardec(|x_result):
  //   (idx, vdef@Var(v-out)) ->
  //     bstm |[
  //     	final x_type x_vout = x_result.x_idx;
  //     ]|
  //   where
  //   	debug(!7);
  //     <get-type; debug(!"7a "); debug(!"7b "); get-sort-kind> vdef => Value()
  //   with
  //   	debug(!8);
  //   	x_type := <get-type; get-sort-java-name> vdef;
  //   	debug(!9);
  //   	x_vout := v-out;
  //   	debug(!10);
  //   	x_idx := $[_[idx]]
  //   	; debug(!11)

rules // term equality and inequality

  op-to-java:
    (f@Formula(TermEq(_, _)), bstm3*) ->
      bstm* |[
        bstm1*
        bstm2*
        if(e) {
        	bstm3*
        } else {
        	throw new InterpreterException("Equality check failed");
        }
      ]|
    with
      (bstm1*, bstm2*, e) := <eq-to-java> f
  
  op-to-java:
    (f@Formula(TermNeq(_, _)), bstm3*) ->
      bstm* |[
        bstm1*
        bstm2*
        if(e) {
          bstm3*
        } else {
          throw new InterpreterException("Inequality check failed");
        }
      ]|
    with
      (bstm1*, bstm2*, e) := <eq-to-java> f
  
  eq-to-java:
    Formula(TermEq(lhs, rhs)) -> (bstm1*, bstm2*, e |[ e_lvar.equals(e_rvar) ]|)
    where
      <get-type; not(is-sort-int)> lhs;
      <get-type; not(is-sort-int)> rhs
    with
      (bstm1*, e_lvar) := <build-to-var> lhs;
      (bstm2*, e_rvar) := <build-to-var> rhs

  eq-to-java:
    Formula(TermEq(lhs, rhs)) -> (bstm1*, bstm2*, e |[ e_lvar == e_rvar ]|)
    where
      <get-type; is-sort-int> lhs;
      <get-type; is-sort-int> rhs 
    with
      (bstm1*, e_lvar) := <build-to-var> lhs;
      (bstm2*, e_rvar) := <build-to-var> rhs

  eq-to-java:
    Formula(TermNeq(lhs, rhs)) -> (bstm1*, bstm2*, e |[ !e_lvar.equals(e_rvar) ]|)
    where
      <get-type; not(is-sort-int)> lhs;
      <get-type; not(is-sort-int)> rhs
    with
      (bstm1*, e_lvar) := <build-to-var> lhs;
      (bstm2*, e_rvar) := <build-to-var> rhs

  eq-to-java:
    Formula(TermNeq(lhs, rhs)) -> (bstm1*, bstm2*, e |[ e_lvar != e_rvar ]|)
    where
      <get-type; is-sort-int> lhs;
      <get-type; is-sort-int> rhs 
    with
      (bstm1*, e_lvar) := <build-to-var> lhs;
      (bstm2*, e_rvar) := <build-to-var> rhs
  
rules // backend for merge points
  
  op-to-java:
    (MergePoint(guard, lbranch*@[lx | lxs], rbranch*@[rx | rxs]), bstm_rest*) ->
      bstm* |[
        bstm1*
        bstm2*
        if(e) {
          bstm_l*
        } else {
          bstm_r*
        }
      ]|
    with
      (bstm1*, bstm2*, e) := <eq-to-java> guard;
      lopweave := <foldr(!lx, \ (op, weave) -> OpSeq(op, weave) \)> lxs;
      ropweave := <foldr(!rx, \ (op, weave) -> OpSeq(op, weave) \)> rxs;
      bstm_l* := <ops-to-java> (lopweave, bstm_rest*);
      bstm_r* := <ops-to-java> (ropweave, bstm_rest*)

rules // fallback

  op-to-java:
    (something, bstm*) ->
      bstm* |[
        return "something unsupported";
        bstm*
      ]|
    with
      debug(!">>>> UNHANDLED OP >>>> ")


rules // expressions to java
  
  exp-to-java:
    VarRef(x_name) ->  (e |[ x_name ]|, [])
  
  exp-to-java:
  	LabelComp(_, VarRef(x_name)) -> (e |[ x_name ]|, [])

  exp-to-java:
    LabelComp(_, OptMap(mapbit*)) -> <exp-to-java> mapbit*

  // special case for a single VarRef specified as an environment optimization
  exp-to-java:
    [ v@VarRef(_) ] -> <exp-to-java> v

  // special case for an environment with a single mapping
  exp-to-java:
    [ Bind(key, value) ] -> (e |[ new PersistentFrame().update(e_key, e_value) ]|, [key-pre*, value-pre*])
    with
      (e_key, key-pre*) := <exp-to-java> key;
      (value-pre*, e_value) := <build-to-var> value

  exp-to-java:
    [ v@VarRef(_) | xsbind ] -> ( Invoke(Method(e_xsbind, None(), Id("update")), [e_v]), [value-stm*, xsbind-stm*] )
    where
      <not(?[])> xsbind
    with
     (e_xsbind, xsbind-stm*) := <exp-to-java> xsbind;
     (value-stm*, e_v) := <build-to-var> v

  exp-to-java:
    [ Bind(key, value) | xsbind ] -> (Invoke(Method(e_xsbind, None(), Id("update")), [e_key, e_value]), [key-stm*, value-stm*, xsbind-stm*])
    where
      <not(?[])> xsbind
    with
      (e_xsbind, xsbind-stm*) := <exp-to-java> xsbind;
      (e_key, key-stm*) := <exp-to-java> key;
      (value-stm*, e_value) := <build-to-var> value




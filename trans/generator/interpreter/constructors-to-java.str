module generator/interpreter/constructors-to-java

imports
  include/ds
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/nabl/-
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/types/-
  generator/interpreter/gen-interpreter
  generator/interpreter/sorts-to-java
  lib/editor-common.generated
  
rules
  
  constructors-to-java-interpreter:
    Module(mod, body*) -> node-class*
    with
      rule* := <collect-all(?Rules(<id>)); concat> body*;
      node-name* := <collect-all(?ConsDecl(<id>, _, _))> body*;
      node-class* := <map(node-to-java-interpreter(|rule*))> node-name*

rules // generate a base interface extending INode with the language-specific evaluate function 
  
  reads-to-inode-interface:
  	Module(mod, body*) -> 
	  	compilation-unit |[
	  		package x_pkgname;
	  		
	  		import org.metaborg.meta.interpreter.framework.*;
	  		
	  		public interface x_inodeface extends INode {
	  			
	  			public x_returnclass evaluate(param*);
	  		}
	  	]|
  	with
  		x_pkgname := <gen-package-name>;
  		x_returnclass := $[[<language>]_Result];
  		x_inodeface := <get-basesort-java-name> "Term";
  		example-read* := <collect-one(get-rule-conclusion-environments)> body*;
  		example-heap* := <collect-one(get-rule-conclusion-inheaps)> body*;
  		param* := <map-with-index(read-to-inode-evaluate-params)> [example-read*, example-heap*]

  read-to-inode-evaluate-params:
    (idx, LabelComp(ty, _)) -> param |[ ~type:jiface x_idx ]|
    with
      x_idx := $[_[idx]];
      x_sort := <get-sort-java-name> ty;
      jiface := type |[ x_sort ]|

rules // generate a language-specific class for the source and target semantic components
  
  // inout-to-java-class:
  //   Module(mod, body*) ->
  //     compilation-unit |[
  //       package x_pkgname;
  //       import org.metaborg.meta.interpreter.framework.*;
  //       
  //       public class x_returnclass {
  //         ~fdec*
  //       }
  //     ]|
  //   with
  //     x_pkgname := <gen-package-name>;
  //     x_returnclass := $[[<language>]_Result]

rules // backend for normal constructor to Java

  node-to-java-interpreter(|rule*):
    node-name ->
      compilation-unit |[
        package x_pkgname;
        
        import org.metaborg.meta.interpreter.framework.*;

        public class x_consname extends AbstractNode implements x_sortname {
          
          ~fdec*
          
          ~body1
          
          // @Override
          // public Value evaluate(I_InterpreterFrame frame) {
          //   bstm1*
          // }
          
        }
      ]|
    with
      debug(!1);
      x_pkgname := <gen-package-name>;
      debug(!2);
      x_consname := <get-cons-java-name> node-name;
      debug(!3);
      (ty*, ty) := <get-type> node-name;
      debug(!4);
      x_sortname := <get-sort-java-name> ty;
      debug(!5);
      fdec* := <map-with-index(node-arg-to-java-field)> ty*;
      debug(!6);
      body1 := <node-args-to-java-constructor> (x_consname, ty*);
      debug(!7);
    	node-rule* := <filter(is-rule-matching-constructor(|node-name))> rule*
      ;debug(!8)

  node-args-to-java-constructor:
    (x_consname, ty*) ->
      class-body-dec |[
        public x_consname(INodeSource source, param*) {
          this.setSourceInfo(source);
          bstm*
        }
      ]|
    with
      param* := <map-with-index(node-arg-to-constr-param-decl)> ty*;
      bstm* := <map-with-index(node-arg-to-fieldinit)> ty*
  
  node-arg-to-constr-param-decl:
    (idx, ty) -> param |[ ~type:jiface x_idx ]|
    with
      x_idx := $[_[idx]];
      x_sort := <get-sort-java-name> ty;
      jiface := type |[ x_sort ]|

  node-arg-to-fieldinit:
    (idx, ty) -> stm |[ this.x_idx = adoptChild(x_idx); ]|
    where
      <not(is-sort-native)> ty
    with
      x_idx := $[_[idx]]

  node-arg-to-fieldinit:
    (idx, ty) -> stm |[ this.x_idx = x_idx; ]|
    where
      <is-sort-native> ty
    with
      x_idx := $[_[idx]]

  get-cons-java-name:
    term -> $[[name]_[arity]]
    where
      is-string
    with
      name := <strip-annos> term;
      (ty*, _) := <get-type> term;
      arity := <length> ty*
  
  node-arg-to-java-field:
    (idx, ty) ->
      class-body-dec |[
        @Child
        public ~type:jiface x_idx;
      ]|
    with
      x_idx := <conc-strings> ("_", <int-to-string> idx);
      x_sortname := <get-sort-java-name> ty;
      jiface := type |[ x_sortname ]|
  
rules // backend for value constructors to Java
  
  value-to-java-interpreter:
    value-name -> <fail> // TODO

rules // utilities for filtering rules

  is-rule-matching-constructor(|cons-name):
    rule -> rule
    with
      Con(cons-name', arg*) := <get-rule-matchedterm> rule;
      resolved-def := <nabl-collect-one-resolved-def> cons-name';
      cons-def := <get-annos; fetch-elem(?Def(_))> cons-name
    where
    	<eq> (cons-def, resolved-def);
    	(ty*, _) := <get-type> cons-def;
    	<eq> (<length> ty*, <length> arg*)
      
  get-rule-matchedterm:
    Rule(_, _, Relation(_, Source(ma, _), _, _)) -> ma
  
  get-rule-conclusion-environments:
    Rule(_, _, Relation(Reads(read*), _, _, _)) -> read*
  
  get-rule-conclusion-inheaps:
    Rule(_, _, Relation(_, Source(_, heap*), _, _)) -> heap*


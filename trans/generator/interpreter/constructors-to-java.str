module generator/interpreter/constructors-to-java

imports
  include/ds
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/nabl/-
  lib/runtime-libraries/org.spoofax.meta.runtime.libraries/types/-
  generator/interpreter/gen-interpreter
  generator/interpreter/sorts-to-java
  generator/interpreter/rule-to-java
  lib/editor-common.generated
  
rules
  
  constructors-to-java-interpreter:
    Module(mod, body*) -> [node-class*, value-class*]
    with
      rule* := <collect-all(?Rules(<id>)); concat> body*;
      node-name* := <collect-all(?ConsDecl(<id>, _, _) + ?InternalConsDecl(<id>, _, _))> body*;
      node-class* := <map(node-to-java-interpreter(|rule*))> node-name*;
      value-name* := <collect-all(?ValueDecl(<id>, _))> body*;
      value-class* := <map(value-to-java-interpreter)> value-name*

rules // generate a base interface extending INode with the language-specific evaluate function 
  
  reads-to-inode-interface:
  	Module(mod, body*) -> 
	  	compilation-unit |[
	  		package x_pkgname;
	  		
	  		import org.metaborg.meta.interpreter.framework.*;
	  		
	  		public interface x_inodeface extends INode {
	  			
	  			public x_returnclass execute(param*);
	  		}
	  	]|
  	with
  		x_pkgname := <gen-package-name>;
  		x_returnclass := $[[<language>]_Result];
  		x_inodeface := <get-basesort-java-name> "Term";
  		example-read* := <collect-one(get-rule-conclusion-environments)> body*;
  		example-heap* := <collect-one(get-rule-conclusion-inheaps)> body*;
  		param* := <map-with-index(read-to-inode-evaluate-params)> [example-read*, example-heap*]

  read-to-inode-evaluate-params:
    (idx, LabelComp(ty, _)) -> param |[ ~type:jiface x_idx ]|
    with
      x_idx := $[_[idx]];
      x_sort := <get-sort-java-name> ty;
      jiface := type |[ x_sort ]|

rules // generate a language-specific class for the result of an evaluation step
  
  step-result-to-java-class:
    Module(mod, body*) ->
      compilation-unit |[
        package x_pkgname;
        
        import org.metaborg.meta.interpreter.framework.*;
        
        public class x_resultclass {
          public final IValue value;
           
          ~fdec*
          
          public x_resultclass(IValue value, param*) {
            this.value = value;
            bstm*
          }
          
        }
      ]|
    with
      x_pkgname := <gen-package-name>;
      x_resultclass := $[[<language>]_Result];
      example-heap* := <collect-one(get-rule-conclusion-outheaps)> body*;
      fdec* := <map-with-index(step-result-to-java-field)> example-heap*;
      ty* := <map(?LabelComp(<id>, _))> example-heap*;
      param* := <map-with-index(node-arg-to-constr-param-decl)> ty*;
      bstm* := <map-with-index(node-arg-to-fieldinit)> ty*

  step-result-to-java-field:
    (idx, LabelComp(ty, _)) -> class-body-dec |[ public final ~type:jiface x_idx; ]|
    with
      x_idx := <conc-strings> ("_", <int-to-string> idx);
      x_sortname := <get-sort-java-name> ty;
      jiface := type |[ x_sortname ]|
  
rules // backend for normal constructor to Java

  node-to-java-interpreter(|rule*):
    node-name ->
      compilation-unit |[
        package x_pkgname;
        
        import org.metaborg.meta.interpreter.framework.*;

        public class x_consname extends AbstractNode implements x_sortname {
          
          ~fdec*
          
          ~body1
          
          ~evalmethod
          
          ~equalsmethod
          
        }
      ]|
    with
      x_pkgname := <gen-package-name>;
      x_consname := <get-cons-java-name> node-name;
      (ty*, ty) := <get-type> node-name;
      x_sortname := <get-sort-java-name> ty;
      fdec* := <map-with-index(node-arg-to-java-child-field)> ty*;
      body1 := <node-args-to-java-constructor> (x_consname, ty*);
    	node-rule* := <filter(is-rule-matching-constructor(|node-name))> rule*;
      if <?[]> node-rule* then
      	evalmethod := <rule-to-java-dummy-evalmethod> rule*
      else
        evalmethod := <Hd;rule-to-java-evalmethod> node-rule*
      end;
      equalsmethod := <node-to-java-equalsmethod> node-name
  
  node-to-java-equalsmethod:
    node-name -> 
      class-body-dec |[
        @Override
			  public boolean equals(Object obj) {
			    if (this == obj) {
			      return true;
			    }
			    if (obj == null) {
			      return false;
			    }
			    if (getClass() != obj.getClass()) {
			      return false;
			    }
			    
			    final x_nodename other = (x_nodename) obj;
			    
			    bstm*
			  
			    return true;
			  }
      ]|
    with
      x_nodename := <get-cons-java-name> node-name;
      (ty*, _) := <get-type> node-name;
      bstm* := <map-with-index(node-to-java-equalsmethods-fieldcheck)> ty*
  
  node-to-java-equalsmethods-fieldcheck:
    (idx, ty) -> 
      bstm* |[
        if (x_idx != other.x_idx) {
          return false;
        }
      ]|
    where
      <is-sort-native> ty
    with
      x_idx := $[_[idx]]

  node-to-java-equalsmethods-fieldcheck:
    (idx, ty) -> 
      bstm* |[
        if (x_idx == null) {
          if (other.x_idx != null) {
            return false;
          }
        } else if (!x_idx.equals(other.x_idx)) {
          return false;
        }
      ]|
    where
      <not(is-sort-native)> ty
    with
      x_idx := $[_[idx]]
 

  node-args-to-java-constructor:
    (x_consname, ty*) ->
      class-body-dec |[
        public x_consname(INodeSource source, param*) {
          this.setSourceInfo(source);
          bstm*
        }
      ]|
    with
      param* := <map-with-index(node-arg-to-constr-param-decl)> ty*;
      bstm* := <map-with-index(node-arg-to-fieldinit)> ty*
  
  node-arg-to-constr-param-decl:
    (idx, ty) -> param |[ ~type:jiface x_idx ]|
    with
      x_idx := $[_[idx]];
      x_sort := <get-sort-java-name> ty;
      jiface := type |[ x_sort ]|

  node-arg-to-fieldinit:
    (idx, ty) -> stm |[ this.x_idx = adoptChild(x_idx); ]|
    where
      <not(is-sort-native)> ty
    with
      x_idx := $[_[idx]]

  node-arg-to-fieldinit:
    (idx, ty) -> stm |[ this.x_idx = x_idx; ]|
    where
      <is-sort-native> ty
    with
      x_idx := $[_[idx]]

  get-cons-java-name:
    term -> $[[name]_[arity]]
    where
      is-string
    with
      name := <strip-annos> term;
      (ty*, _) := <get-type> term;
      arity := <length> ty*
  
  node-arg-to-java-child-field:
    (idx, ty) ->
      class-body-dec |[
        @Child
        public ~type:jiface x_idx;
      ]|
    where
      <not(is-sort-native)> ty
    with
      x_idx := <conc-strings> ("_", <int-to-string> idx);
      x_sortname := <get-sort-java-name> ty;
      jiface := type |[ x_sortname ]|
      
  node-arg-to-java-child-field:
    (idx, ty) -> <node-arg-to-java-field> (idx, ty)
    where
      <is-sort-native> ty 
    
rules // backend for value constructors to Java
  
  value-to-java-interpreter:
    value-name ->
      compilation-unit |[
        package x_pkgname;
        
        import org.metaborg.meta.interpreter.framework.*;
        
        public class x_value implements IValue {
          
          ~fdec*
          
          ~body1
        }
      ]|
    with
      x_pkgname := <gen-package-name>;
      x_value := <get-cons-java-name> value-name;
      (ty*, _) := <get-type> value-name;
      fdec* := <map-with-index(node-arg-to-java-field)> ty*;
      body1 := <value-args-to-java-constructor> (x_value, ty*)
  
  value-args-to-java-constructor:
    (x_consname, ty*) ->
      class-body-dec |[
        public x_consname(param*) {
          bstm*
        }
      ]|
    with
      param* := <map-with-index(node-arg-to-constr-param-decl)> ty*;
      bstm* := <map-with-index(value-arg-to-fieldinit)> ty*
  
  step-result-to-type:
    LabelComp(ty, _) -> ty

  node-arg-to-java-field:
    (idx, ty) ->
      class-body-dec |[
        public ~type:jiface x_idx;
      ]|
    with
      x_idx := <conc-strings> ("_", <int-to-string> idx);
      x_sortname := <get-sort-java-name> ty;
      jiface := type |[ x_sortname ]|

  value-arg-to-fieldinit:
    (idx, ty) -> stm |[ this.x_idx = x_idx; ]|
    with
      x_idx := $[_[idx]]

rules // utilities for filtering rules

  is-rule-matching-constructor(|cons-name):
    rule -> rule
    with
      Con(cons-name', arg*) := <get-rule-matchedterm> rule;
      resolved-def := <nabl-collect-one-resolved-def> cons-name';
      cons-def := <get-annos; fetch-elem(?Def(_))> cons-name
    where
    	<eq> (cons-def, resolved-def);
    	(ty*, _) := <get-type> cons-def;
    	<eq> (<length> ty*, <length> arg*)
      
  get-rule-matchedterm:
    Rule(_, _, Relation(_, Source(ma, _), _, _)) -> ma
  
  get-rule-conclusion-environments:
    Rule(_, _, Relation(Reads(read*), _, _, _)) -> read*
  
  get-rule-conclusion-inheaps:
    Rule(_, _, Relation(_, Source(_, heap*), _, _)) -> heap*

  get-rule-conclusion-outheaps:
    Rule(_, _, Relation(_, _, _, Target(_, heap*))) -> heap*


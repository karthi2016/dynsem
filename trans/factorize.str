module factorize

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/ds
  ds
  lib-ds
  lib/editor-common.generated
  sugar
  mark-references
  
strategies
    
  factorize-module :
    Module(name, section*) -> Module(name, section'*) 
    where
      section'* := <map(try(factorize-rules))> section*
        
  factorize-rules = alltd(factorize-rule; rename-rule-inputs)
    
rules
  
  factorize-rule :
    Rule(prem1*, infer, 
          Relation(reads, Source(lhs,sc*), NamedDynamicEmitted(arrow, em1*), Target(rhs,tc*))) -> 
    Rule(prem6*, infer, 
          Relation(reads, Source(lhs',sc*), NamedDynamicEmitted(arrow, em1*), Target(rhs',tc'*)))
    with
    	while-counting(
	      (prem2*, lhs') := <lift-constructors-from-match> lhs;
	      (prem3*, rhs') := <lift-constructors-from-rhs> rhs;
	      (prem4*, tc'*) := <lift-constructors-from-tc> tc*;
	      prem5* := <lift-constructors-from-premises> [prem2*, prem1*, prem3*, prem4*];
	      prem6* := <lift-mapselect-from-premises> prem5*
	    )
          
  factorize-rule :
    Rule(prem1*, infer, TermEq(lhs, rhs)) -> Rule(prem4*, infer, TermEq(lhs', rhs'))
    with
    	while-counting(
	    	(prem2*, lhs') := <lift-constructors-from-match> lhs;
	      (prem3*, rhs') := <lift-constructors-from-rhs> rhs;
	      prem4* := <lift-constructors-from-premises> [prem2*, prem1*, prem3*]
	    )
rules
  
  rename-rule-inputs:
    Rule(prem1*, infer, Relation(Reads(r1*), Source(lhs, sc1*), NamedDynamicEmitted(arrow, e1*), Target(rhs, tc1*))) ->
    Rule(prem2*, infer, Relation(Reads(r2*), Source(lhs, sc2*), NamedDynamicEmitted(arrow, e1*), Target(rhs', tc2*)))
    with
      while-counting(
        (r2*, extraprem1*) := <rename-inputs> r1*;
        (sc2*, extraprem2*) := <rename-inputs> sc1*
      );
      while-counting(
        (rhs', extraprem3*) := <rename-outputs> rhs;
        (tc2*, extraprem4*) := <rename-outputs> tc1*
      );
      prem2* := [extraprem1*, extraprem2*, prem1*, extraprem3*, extraprem4*]
  
  rename-inputs:
    [x | xs] -> ([x' | xs''], [p1, p2*])
    with
      (x', p1) := <rename-input> x;
      (xs'', p2*) := <rename-inputs> xs 
  
  rename-inputs:
    [] -> ([], [])  

  rename-input:
    LabelComp(name, Var(v-orig)) -> (LabelComp(name, Var(v-new)), Formula(Match(VarRef(v-new), MatchedVar(v-orig))) )
    with
      v-new := <next-variable(|"lifted_in")>

  rename-outputs:
    [x | xs] -> ([x' | xs''], [p1, p2*])
    with
      (x', p1) := <rename-output> x;
      (xs'', p2*) := <rename-outputs> xs 
  
  rename-outputs:
    Con(t, args) -> (Con(t, args'), p*)
    with
      (args', p*) := <rename-outputs> args
  
  rename-outputs:
    vref -> (vref', [p])
    where
      ?VarRef(_) + ?Var(_)
    with
      (vref', p) := <rename-output> vref
  
  rename-outputs:
    [] -> ([], [])  
  
  rename-output:
    LabelComp(name, VarRef(v-orig)) -> (LabelComp(name, VarRef(v-new)), Formula(Match(VarRef(v-orig), MatchedVar(v-new))) )
    with
      v-new := <next-variable(|"lifted_out")>
  
  rename-output:
    v -> (VarRef(v-new), Formula(Match(VarRef(v-orig), MatchedVar(v-new))))
    where
      ?VarRef(v-orig) + ?Var(v-orig)
    with
      v-new := <next-variable(|"lifted_out")>

rules // lift constructor sub-terms in match
      
  lift-constructors-from-match:
    t -> ([], t)
    where <not(?Con(_,_) + ?Var(_))> t
  
  lift-constructors-from-match:
    Con(c, t1*) -> (prem*, Con(c, t2*))
    where (prem*, t2*) := <map(lift-constructor-from-match); unzip; (concat, id)> t1*

  lift-constructor-from-match:
    t@Con(c, _) -> ([Formula(Match(Var(x), t))], Var(x))
    with x := <next-variable(|"lifted")>

  lift-constructor-from-match:
    Var(x) -> ([Formula(Match(VarRef(x-new), MatchedVar(x)))], Var(x-new))
    with x-new := <next-variable(|"lifted")>

  lift-constructor-from-match = lift-listtail-from-match
  
  lift-listtail-from-match:
  	l@List([]) -> ([Formula(Match(Var(x), l))], Var(x))
  	with x := <next-variable(|"lifted")>
  
  lift-listtail-from-match:
    lt@ListTail([elem], tl) -> ([Formula(Match(Var(x), lt))], Var(x))
    with
      x := <next-variable(|"lifted")>

  lift-constructor-from-match = lift-constant-from-match

  lift-constant-from-match:
    t@Int(i) -> ([Formula(TermEq(Var(x), t))], Var(x))
    with x := <next-variable(|"lifted")>

  lift-constant-from-match:
    t@String(s) -> ([Formula(TermEq(Var(x), t))], Var(x))
    with x := <next-variable(|"lifted")>

rules // lift constructor sub-terms in build
  
  lift-constructors-from-rhs:
    t@Con(c, t*) -> ([Formula(Match(t, Var(x)))], Var(x))
    where
      x := <next-variable(|"lifted")>

  lift-constructors-from-rhs:
    t -> ([], t)
    where <not(?Con(_,_))> t

rules // lift from output components
  
  lift-constructors-from-tc:
    [] -> ([], [])
  
  lift-constructors-from-tc:
    [ x | xs ] -> ([prem1*, prem2*], [x' | xs'])
    with
      (prem1*, x') := <lift-constructors-from-tc> x;
      (prem2*, xs') := <lift-constructors-from-tc> xs

  lift-constructors-from-tc:
    tc@LabelComp(name, VarRef(_)) -> ([], tc)
  
  lift-constructors-from-tc:
    LabelComp(name, t) -> ([Formula(Match(t, MatchedVar(x)))], LabelComp(name, VarRef(x)))
    with
      x := <next-variable(|"lifted")>
  
rules // lift from build
  
  lift-constructors-from-build :
    t -> ([], t)
    where <not(?Con(_,_))> t    
        
  lift-constructors-from-build :
    Con(c, t1*) -> (prem*, Con(c, t2*))
    where (prem*@[_|_], t2*) := <map(lift-constructor-from-build); unzip; (concat, id)> t1*
    
  lift-constructor-from-build :
    t@Con(c, _) -> ([Formula(TermEq(t, Var(x)))], Var(x))
    where x := <next-variable(|"lifted")>   
    
  lift-constructor-from-build :
    t -> ([], t)
    where <not(?Con(_,_))> t

rules // lift constructors from sub-terms in premises
  
  lift-constructors-from-premises :
    [] -> []  
    
  lift-constructors-from-premises :
    [prem | prem1*] -> prem3*
    where if prem2* := <lift-constructors-from-premise> prem then
            prem3* := <lift-constructors-from-premises> [prem2*, prem1*]
          else
            prem3* := [prem | <lift-constructors-from-premises> [prem1*]]
          end

  lift-constructors-from-premise :
    Formula(TermEq(lhs, rhs)) -> [prem1*, Formula(TermEq(lhs', rhs')), prem2*]  
    where (prem1*, lhs') := <lift-constructors-from-build> lhs;
          (prem2*, rhs') := <lift-constructors-from-match> rhs;
          (not(<?[]> prem1*) <+ not(<?[]> prem2*))

  lift-constructors-from-premise :
    Formula(TermEq(lhs, rhs)) -> [prem1*, Formula(TermEq(lhs', rhs')), prem2*]  
    where (prem1*, lhs') := <lift-constructors-from-build> lhs;
          (prem2*, rhs') := <lift-constructors-from-match> rhs;
          (not(<?[]> prem1*) <+ not(<?[]> prem2*))
  
  lift-constructors-from-premise :
    Formula(Match(lhs, Con(c, t1*))) -> [Formula(Match(lhs, Con(c, t2*))), ma*]
    where
      <fetch-elem(?Con(_, _))> t1*;
      (ma*, t2*) := <map(lift-constructor-from-match); unzip; (concat, id)> t1*
  
  lift-constructors-from-premise:
    Formula(Match(lhs, ListTail([elem], xs))) -> [Formula(Match(lhs, ListTail([elem], Var(xs-lifted)))), prem*]
    where
      <not(?Var(_) + ?VarRef(_))> xs
    where
      xs-lifted := <next-variable(|"lifted")>;
      prem* := <lift-constructors-from-premises> [Formula(Match(Var(xs-lifted), xs))]
  
  lift-constructors-from-premise :
    Formula(Relation(reads, source, relation, Target(con@Con(_, _), tc*))) ->
      <lift-constructors-from-premises> [Formula(Relation(reads, source, relation, Target(Var(x), tc*))), Formula(Match(Var(x), con)) ]
    with
      x := <next-variable(|"lifted")>

  lift-constructors-from-premise :
    Formula(Relation(reads, Source(s, sc*), relation, target)) ->
      <lift-constructors-from-premises> [prem*, Formula(Relation(reads, Source(s, sc'*), relation, target))]
    where
      <fetch-elem(?LabelComp(_, MapExtend(_, _)))> sc*
    with
      (prem*, sc'*) := <map(lift-mapextend-from-comp); unzip; (concat, id)> sc*
      
  lift-constructors-from-premise :
    Formula(Relation(reads, Source(con@Con(_, _), sc*), relation, target)) ->
      <lift-constructors-from-premises> [Formula(Match(con, MatchedVar(x))), Formula(Relation(reads, Source(VarRef(x), sc*), relation, target))]
    with
      x := <next-variable(|"lifted")>

  lift-mapextend-from-comp :
    LabelComp(name, mex@MapExtend(_, _)) -> ([Formula(Match(mex, MatchedVar(x)))], LabelComp(name, VarRef(x)))
    with
      x := <next-variable(|"lifted")>
  
  lift-mapextend-from-comp :
    lc@LabelComp(name, t) -> ([], lc)
    where
      <not(?MapExtend(_, _))> t 

rules // lift map access from premises that do both match and bind
  
  lift-mapselect-from-premises:
    [prem | prem1* ] -> prem3*
    with
      if prem2* := <lift-mapselect-from-premise> prem then
        prem3* := <lift-mapselect-from-premises> [prem2*, prem1*]
      else
        prem3* := [prem | <lift-mapselect-from-premises> prem1* ]
      end
  
  lift-mapselect-from-premises:
    [] -> []
  
  lift-mapselect-from-premise:
    Formula(TermEq(lhs@MapSelect(_, _), rhs)) ->
      [Formula(TermEq(lhs, Var(x))), Formula(TermEq(VarRef(x), rhs))]
    where
      <?Con(_, _)> rhs
      +
      <?String(_)> rhs
      +
      <?Int(_)> rhs
    with
      x := <next-variable(|"lifted")>
  
  lift-mapselect-from-premise:
    Formula(TermEq(lhs@MapSelect(_, _), rhs@VarRef(_))) ->
      [Formula(TermEq(lhs, Var(x))), Formula(TermEq(VarRef(x), rhs))]
    with
      x := <next-variable(|"lifted")>

	
module sugar

imports
	include/ds
	
signature
  constructors
    MapExtend : Map * Map -> Map
    MapEntry : Map -> Bind
	
rules // desugaring
	
  desugar-all = innermost(desugar); alltd(rules-concat)
  
  desugar :
    SortDecl(srt, Some(annos)) -> SortDecl(srt, annos)
  
  desugar :
    SortDecl(srt, None()) -> SortDecl(srt, SignatureAnnos([]))
  
  desugar:
    ConsDecl(cons, srtargs, srt, Some(annos)) -> ConsDecl(cons, srtargs, srt, annos)
  
  desugar:
    ConsDecl(cons, srtargs, srt, None()) -> ConsDecl(cons, srtargs, srt, SignatureAnnos([]))
  
  desugar:
    InjDecl(from, to, None()) -> InjDecl(from, to, SignatureAnnos([]))

  desugar:
    InjDecl(from, to, Some(annos)) -> InjDecl(from, to, annos)
  
  desugar :
    RuleW(form, prem*) -> Rule(prem*, "---", form)
    
  desugar :
    NoReads() -> Reads([])
   
  desugar :
    Source(lhs) -> Source(lhs, [])
    
  desugar :
    Target(rhs) -> Target(rhs, [])
    
  desugar :
    Dynamic() -> DynamicEmitted([])
    
  desugar :
    Axiom(form) -> Rule([], "---------", form)
    
  desugar :
    IsValue(term) -> TermEq(Con("IsValue",[term]),Con("True",[]))

  desugar :
    Strict(con,params1,params2) -> list
     where Cons(_,Cons(_,_)) := params1;
           list := <map( \ param -> Strict(con,[param],params2) \)> params1

  desugar :
    Seqstrict(con,params1,params2) -> list
     where Cons(_,Cons(_,_)) := params1;
           list := <map( \ param -> Seqstrict(con,[param],params2) \)> params1
     // this converts a Rule into a list of Rules
     // so they must later be concatenated, post-desugaring:
     
  rules-concat :
  	 Rules(list) -> Rules(list1)
  	 where list1 := <map(?Cons(_,_) <+ ( \ n -> Cons(n,Nil()) \)); concat> list
    
rules // sugaring
  
  sugar-all = innermost(sugar)
  
  sugar :
    SortDecl(srt, sa@SignatureAnnos(_)) -> SortDecl(srt, Some(sa))
  
  sugar :
    ConsDecl(cons, srtargs, srt, sa@SignatureAnnos(_)) -> ConsDecl(cons, srtargs, srt, Some(sa))
  
  sugar :
    InjDecl(from, to, sa@SignatureAnnos(_)) -> InjDecl(from, to, Some(sa))

  sugar :
  	Rule([],infer,conc) -> Axiom(conc)

  sugar :
  	Reads([]) -> NoReads()

  sugar :
  	DynamicEmitted([]) -> Dynamic()

  sugar :
  	Target(term,[]) -> Target(term)

  sugar :
  	Source(term,[]) -> Source(term)

  sugar :
    TermEq(Con("IsValue",[term]),Con("True",[])) -> IsValue(term)
  
rules // desugaring maps
  
  desugar :
    Map([b | b*@[_|_]]) -> MapExtend(Map([b]), Map(b*))
    
  desugar :
    Map([MapEntry(x)]) -> x
  
          
